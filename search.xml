<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的博客经营旅程</title>
    <url>/2020/03/21/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BB%8F%E8%90%A5%E6%97%85%E7%A8%8B/</url>
    <content><![CDATA[<p>庚子年清明，我把原来jekyll的博客迁到了hexo框架。</p>
<p>主题©<a href="https://jerryc.me/" target="_blank" rel="noopener">Butterfly</a>，目前只是根据配置文档做一些选择，尽量让界面清新简洁。</p>
<p>大佬们代码写得很好，得花一些时间研究一下配置文件，未来想再引进些什么。</p>
<p>未完待续…</p>
<hr>
]]></content>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-983 最低票价</title>
    <url>/2020/05/07/LeetCode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</span><br><span class="line"></span><br><span class="line">火车票有三种不同的销售方式：</span><br><span class="line"></span><br><span class="line">· 一张为期一天的通行证售价为 costs[0] 美元；</span><br><span class="line">· 一张为期七天的通行证售价为 costs[1] 美元；</span><br><span class="line">· 一张为期三十天的通行证售价为 costs[2] 美元。</span><br><span class="line"></span><br><span class="line">通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</span><br><span class="line"></span><br><span class="line">返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：days &#x3D; [1,2,3,4,5,6,7,8,9,10,30,31], costs &#x3D; [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] &#x3D; $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 1 &lt;&#x3D; days.length &lt;&#x3D; 365</span><br><span class="line">· 1 &lt;&#x3D; days[i] &lt;&#x3D; 365</span><br><span class="line">· days 按顺序严格递增</span><br><span class="line">· costs.length &#x3D;&#x3D; 3</span><br><span class="line">· 1 &lt;&#x3D; costs[i] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>主干思路：</p>
<ul>
<li>今天不需要出门，不用买票</li>
<li>今天如果要出门，需要买几天？<ul>
<li>看往后几天（最多30天内）要不要出门<ul>
<li>30天内都没有要出行的，那只买今天就好</li>
<li>有要出门的（不同决策）<ul>
<li>这次 和 后面几次 分开买更省</li>
<li>这次 和 后面几次 一起买更省</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上述思路显而易见，最关键在于：「今天买多少，得看后几天怎么安排」，即「前面依赖后面」——从后向前来买。<br/><br>如图所示，例如：$days = [1,4,6,7,8,20]$<br/></p>
<ul>
<li>第 21 及以后的日子都不需要出门，不用买票</li>
<li>第 20 需要出门，需要买几天？<ul>
<li>不考虑 20 之前要不要出门，否则与思路相违背</li>
<li>第 20 之后没有出门日，故买「一天」的 costs[0] 最省钱。</li>
</ul>
</li>
<li>第 9 - 19 不需要出门，则不用买</li>
<li>第 8 需要出门，需要买几天？<ul>
<li>往后（只需看往后30天）有出门的需求<ul>
<li>决策1：买一天期，后面的不包</li>
<li>决策2：买七天期，包到第 8 + 7 - 1 天，第 8 + 7 天往后的不包</li>
<li>决策3：买三十天期，包到第 8 + 30 - 1 天，第 8 + 30 天往后的不包<ul>
<li>可见，决策3 包三十天期的话，第 20 可不用花钱</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/983-1.png"  alt=""></p>
<ul>
<li>…</li>
<li>抽象，定义状态：dp[i] 为第 i 天开始，累计所需最小费用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] &#x3D; min(决策1, 决策2, 决策3);    </span><br><span class="line">      &#x3D; min(c[0] + 1天后不包, c[1] + 7天后不包, c[2] + 30天不包);</span><br><span class="line">      &#x3D; min(c[0] + dp[i + 1], c[1] + dp[i + 7], c[2] + dp[i + 30]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/983-2.png"  alt=""><br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123;</span><br><span class="line">    int len &#x3D; days.size();</span><br><span class="line">    int dp[400] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    for (int d &#x3D; days[len-1], i &#x3D; len-1; d &gt;&#x3D; days[0]; --d)&#123;</span><br><span class="line">        if (d &#x3D;&#x3D; days[i])&#123;</span><br><span class="line">            dp[d] &#x3D; min(costs[0]+dp[d+1], costs[1]+dp[d+7]);</span><br><span class="line">            dp[d] &#x3D; min(costs[2]+dp[d+30], dp[d]);</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        else dp[d] &#x3D; dp[d+1];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[days[0]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-101 对称二叉树</title>
    <url>/2020/05/07/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，检查它是否是镜像对称的。 </span><br><span class="line"></span><br><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   2</span><br><span class="line">  &#x2F; \ &#x2F; \</span><br><span class="line"> 3  4 4  3 </span><br><span class="line"></span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>递归，思路与 <a href="https://whitebeerhouse.github.io/2020/05/07/LeetCode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91" target="_blank" rel="noopener">LeetCode-572 另一个树的子树</a> 类似。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isSymmetricTree(TreeNode* root1, TreeNode* root2)&#123; &#x2F;&#x2F;辅助函数</span><br><span class="line">    if (root1 &#x3D;&#x3D; NULL &amp;&amp; root2 &#x3D;&#x3D; NULL) return true;</span><br><span class="line">    if (root1 &#x3D;&#x3D; NULL || root2 &#x3D;&#x3D; NULL) return false;</span><br><span class="line">    return (root1-&gt;val &#x3D;&#x3D; root2-&gt;val &amp;&amp; isSymmetricTree(root1-&gt;left, root2-&gt;right) &amp;&amp; isSymmetricTree(root1-&gt;right, root2-&gt;left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSymmetric(TreeNode* root)&#123; &#x2F;&#x2F;主函数</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)   return true;</span><br><span class="line">    return isSymmetricTree(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-572 另一个树的子树</title>
    <url>/2020/05/07/LeetCode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定的树 s:</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 t：</span><br><span class="line"></span><br><span class="line">   4 </span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定的树 s：</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">    &#x2F;</span><br><span class="line">   0</span><br><span class="line">给定的树 t：</span><br><span class="line"></span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">返回 false。</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>判断 t 是否为 s 的<strong>子树</strong>的三个条件：</p>
<ul>
<li>当前两棵树相等；</li>
<li><strong>或者</strong>，t 是 s 的左子树；</li>
<li><strong>或者</strong>，t 是 s 的右子树。</li>
</ul>
<p>而判断两个树是否<strong>相等</strong>的三个条件：</p>
<ul>
<li>当前两个树的根节点值相等；</li>
<li><strong>并且</strong>，s 的左子树和 t 的左子树相等；</li>
<li><strong>并且</strong>，s 的右子树和 t 的右子树相等。</li>
</ul>
<p>🐣：曾有过中序遍历得到所有节点值的序列的尝试，再一推敲发觉其实并不可行，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      3</span><br><span class="line">     &#x2F; \               </span><br><span class="line">    4   5                              4</span><br><span class="line">   &#x2F; \                &amp;               &#x2F; \</span><br><span class="line">  1   2                              1   2</span><br><span class="line"> &#x2F;                    </span><br><span class="line">0</span><br></pre></td></tr></table></figure><br><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isSametree(TreeNode* s, TreeNode* t)&#123; &#x2F;&#x2F;辅助函数</span><br><span class="line">    if (s &#x3D;&#x3D; NULL &amp;&amp; t &#x3D;&#x3D; NULL) return true;</span><br><span class="line">    if (s &#x3D;&#x3D; NULL || t &#x3D;&#x3D; NULL)  return false;</span><br><span class="line">    return (s-&gt;val &#x3D;&#x3D; t-&gt;val &amp;&amp; isSametree(s-&gt;left, t-&gt;left) &amp;&amp; isSametree(s-&gt;right, t-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSubtree(TreeNode* s, TreeNode* t)&#123; &#x2F;&#x2F;主函数</span><br><span class="line">    if (s &#x3D;&#x3D; NULL &amp;&amp; t &#x3D;&#x3D; NULL) return true;</span><br><span class="line">    if (s &#x3D;&#x3D; NULL || t &#x3D;&#x3D; NULL)  return false;</span><br><span class="line">    return isSametree(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-45 跳跃游戏II</title>
    <url>/2020/05/04/LeetCode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。</span><br><span class="line"></span><br><span class="line">数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><br><span class="line"></span><br><span class="line">你的目标是使用最少的跳跃次数到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">说明: 假设你总是可以到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>贪心算法，我们每次在可跳范围内选择可以使得跳的更远的位置。<br/>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4…<br/>在具体的实现中，维护当前能够到达的最大下标位置，记为边界。从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。<br/>遍历数组时，<strong>不访问最后一个元素</strong>，因为在访问最后一个元素之前，边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，会增加一次「不必要的跳跃次数」，因此不必访问最后一个元素。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len &#x3D; nums.size();</span><br><span class="line">    int end &#x3D; 0, result &#x3D; 0, maxPos &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len-1; ++i)&#123;</span><br><span class="line">        if(i &lt;&#x3D; maxPos)&#123;</span><br><span class="line">            maxPos &#x3D; max(maxPos, i+nums[i]);</span><br><span class="line">            if (i &gt;&#x3D; end)&#123;</span><br><span class="line">                end &#x3D; maxPos;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;      </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1386 安排电影院座位⭐</title>
    <url>/2020/05/02/LeetCode-1386-%E5%AE%89%E6%8E%92%E7%94%B5%E5%BD%B1%E9%99%A2%E5%BA%A7%E4%BD%8D%E2%AD%90/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如图一所示，电影院的观影厅中有 n 行座位，行编号从 1 到 n ，且每一行内总共有 10 个座位，列编号从 1 到 10 。</span><br><span class="line"></span><br><span class="line">给你数组 reservedSeats ，包含所有已经被预约了的座位。比如说，researvedSeats[i]&#x3D;[3,8] ，它表示第 3 行第 8 个座位被预约了。</span><br><span class="line"></span><br><span class="line">请你返回最多能安排多少个 4 人家庭 。4 人家庭要占据 同一行内连续 的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 3, reservedSeats &#x3D; [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]</span><br><span class="line">输出：4</span><br><span class="line">解释：图二所示是最优的安排方案，总共可以安排 4 个家庭。蓝色的叉表示被预约的座位，橙色的连续座位表示一个 4 人家庭。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 2, reservedSeats &#x3D; [[2,1],[1,8],[2,6]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 4, reservedSeats &#x3D; [[4,3],[1,4],[4,6],[1,7]]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">· 1 &lt;&#x3D; n &lt;&#x3D; 10^9</span><br><span class="line">· 1 &lt;&#x3D; reservedSeats.length &lt;&#x3D; min(10*n, 10^4)</span><br><span class="line">· reservedSeats[i].length &#x3D;&#x3D; 2</span><br><span class="line">· 1 &lt;&#x3D; reservedSeats[i][0] &lt;&#x3D; n</span><br><span class="line">· 1 &lt;&#x3D; reservedSeats[i][1] &lt;&#x3D; 10</span><br><span class="line">· 所有 reservedSeats[i] 都是互不相同的。</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1386-1.png"  alt="图一"><br/><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1386-2.png"  alt="图二"><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>对于一个家庭而言，只有以下三种给他们安排座位的方法：</p>
<ul>
<li>安排位置 2，3，4，5；</li>
<li>安排位置 4，5，6，7；</li>
<li>安排位置 6，7，8，9。</li>
</ul>
<p>因此每一排的位置 1 和位置 10 都是没有意义的，即使被预约了也对答案没有任何影响，所以，忽略所有在位置 1 和位置 10 的预约。同时可以发现，如果一排位置（不含位置 1 和位置 10 ，下同）没有被预约，那么恰好可以安排给两个家庭；如果一排位置被预约了至少一个座位，那么最多只能安排给一个家庭了。<br/>对于只能安排一个家庭的情况，有两种方法计算。<br/><br/>方法一：<strong>查找</strong>。即利用STL自定义的函数暴力查找。<br/><br/>方法二：<strong>位运算</strong>。<br>用<strong>哈希表</strong>来存储每一排以及它们的二进制数。对于哈希映射中的每个键值对，键表示电影院中的一排，值表示这一排对应的二进制数。如果某一排没有任何位置被预约（例如上面的第三排），那么这一排一定可以安排给两个家庭，因此可以不必将这个键值对存放在哈希映射中。也就是说，只有某一排的某一座位被预约了，才将这一排放入哈希映射。<br/>在处理完了所有的预约之后，遍历哈希映射。对于一个键值对 (row,bitmask)，如何知道 row 这一排可以安排给几个家庭呢？根据之前的分析，被存储在哈希映射中的这些排最多只能安排给一个家庭，那么对于三种安排座位的方法：</p>
<ul>
<li>对于安排位置 2，3，4，5，如果 bitmask 中第 0，1，2，3 个二进制位均为 0，那么就可以安排给一个家庭；也就是说，bitmask 和 (11110000)<sub>2</sub> 的按位或值保持为 (11110000)<sub>2</sub> 不变；</li>
<li>对于安排位置 4，5，6，7，如果 bitmask 中第 2，3，4，5 个二进制位均为 0，那么就可以安排给一个家庭；也就是说，bitmask 和 (11000011)<sub>2</sub> 的按位或值保持为 (11000011)<sub>2</sub> 不变；</li>
<li>对于安排位置 6，7，8，9，如果 bitmask 中第 4，5，6，7 个二进制位均为 0，那么就可以安排给一个家庭；也就是说，bitmask 和 (00001111)<sub>2</sub> 的按位或值保持为 (00001111)<sub>2</sub> 不变；</li>
</ul>
<p>这样以来，我们只需要将 bitmask 分别与 (11110000)<sub>2</sub>、 (11000011)<sub>2</sub> 和 (00001111)<sub>2</sub>进行按位或运算，如果其中有一个在运算后保持不变，那么 row 这一排就可以安排给一个家庭。<br/>🐣：auto冒号遍历为 C++11 新特性，参见 <a href="https://blog.csdn.net/qq_40213457/article/details/80720170" target="_blank" rel="noopener">C++11 auto冒号遍历</a>、<a href="https://blog.csdn.net/zyc2018/article/details/93591189" target="_blank" rel="noopener">C++之auto使用</a>；温习一下<a href="https://www.cnblogs.com/fightfor/p/3871624.html" target="_blank" rel="noopener">左移/右移运算符</a>。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">int maxNumberOfFamilies(int n, vector&lt;vector&lt;int&gt;&gt;&amp; reservedSeats) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    unordered_map&lt;int, unordered_set&lt;int&gt;&gt; record;</span><br><span class="line">    for (auto i : reservedSeats)&#123;</span><br><span class="line">        if (i[1] &gt;&#x3D; 2 &amp;&amp; i[1] &lt;&#x3D; 9)  </span><br><span class="line">            record[i[0]].insert(i[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    result +&#x3D; (n - record.size()) * 2;</span><br><span class="line"></span><br><span class="line">    for (auto i : record)&#123;</span><br><span class="line">        bool side &#x3D; false;</span><br><span class="line">        if (!(i.second.count(2) || i.second.count(3) || i.second.count(4) || i.second.count(5)))    ++result, side &#x3D; true;</span><br><span class="line">        if (!(i.second.count(6) || i.second.count(7) || i.second.count(8) || i.second.count(9)))    ++result, side &#x3D; true;</span><br><span class="line">        if (!(i.second.count(4) || i.second.count(5) || i.second.count(6) || i.second.count(7)) &amp;&amp; !side)    ++result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">int maxNumberOfFamilies(int n, vector&lt;vector&lt;int&gt;&gt;&amp; reservedSeats) &#123;</span><br><span class="line">    int left &#x3D; 0b11110000; &#x2F;&#x2F; 2~9</span><br><span class="line">    int middle &#x3D; 0b11000011;</span><br><span class="line">    int right &#x3D; 0b00001111;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;int, int&gt; record;</span><br><span class="line">    for (auto iter : reservedSeats)&#123;</span><br><span class="line">        if (iter[1] &gt;&#x3D; 2 &amp;&amp; iter[1] &lt;&#x3D; 9)</span><br><span class="line">            record[iter[0]] |&#x3D; (1 &lt;&lt; (iter[1]-2));</span><br><span class="line">    &#125;</span><br><span class="line">    result +&#x3D; (n - record.size()) * 2;</span><br><span class="line"></span><br><span class="line">    for (auto iter : record)&#123;</span><br><span class="line">        if ((iter.second | left) &#x3D;&#x3D; left || (iter.second | middle) &#x3D;&#x3D; middle || (iter.second | right) &#x3D;&#x3D; right)</span><br><span class="line">            ++result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>STL</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1029 两地调度</title>
    <url>/2020/04/30/LeetCode-1029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。</span><br><span class="line"></span><br><span class="line">返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">输出：110</span><br><span class="line">解释：</span><br><span class="line">第一个人去 A 市，费用为 10。</span><br><span class="line">第二个人去 A 市，费用为 30。</span><br><span class="line">第三个人去 B 市，费用为 50。</span><br><span class="line">第四个人去 B 市，费用为 20。</span><br><span class="line"></span><br><span class="line">最低总费用为 10 + 30 + 50 + 20 &#x3D; 110，每个城市都有一半的人在面试。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">· 1 &lt;&#x3D; costs.length &lt;&#x3D; 100</span><br><span class="line">· costs.length 为偶数</span><br><span class="line">· 1 &lt;&#x3D; costs[i][0], costs[i][1] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>这样来看这个问题，公司首先将这 2N 个人全都安排飞往 A 市，再选出 N 个人改变它们的行程，让他们飞往 A 市。因为全部去往 A 市的总费用 $Sum$ 是确定的，改变 N 个人的行程后总费用为 $Sum - \sum_{n=1}^{len/2} (cost[n][0] - cost[n][1])$，自然是每一组A、B费用差值越大越好了😃。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;</span><br><span class="line">    int len &#x3D; costs.size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    vector&lt;int&gt; diff;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        result +&#x3D; costs[i][0];</span><br><span class="line">        diff.push_back(costs[i][0]-costs[i][1]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(diff.begin(), diff.end());</span><br><span class="line">    for (int i &#x3D; len-1; i &gt;&#x3D; len&#x2F;2; --i)&#123;</span><br><span class="line">        result -&#x3D; diff[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1424 对角线遍历II⭐</title>
    <url>/2020/04/28/LeetCode-1424-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86II%E2%AD%90/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,4,2,7,5,3,8,6,9]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3],[4],[5,6,7],[8],[9,10,11]]</span><br><span class="line">输出：[1,4,2,5,3,8,6,9,7,10,11]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3,4,5,6]]</span><br><span class="line">输出：[1,2,3,4,5,6] </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">· 1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">· 1 &lt;&#x3D; nums[i].length &lt;&#x3D; 10^5</span><br><span class="line">· 1 &lt;&#x3D; nums[i][j] &lt;&#x3D; 10^9</span><br><span class="line">nums 中最多有 10^5 个数字。</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1424-1.png"  alt="示例1"><br><br/></p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1424-2.png"  alt="示例2"><br><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>因为矩阵不是完整填充的，所以不能直接遍历。考虑到是顺着对角线的同一方向，那么x+y就是相等的且次序一致，那么可以按照x+y去分类，建立一个二维数组ans[i] [j]，i表示（x+y），然后正常遍历这个nums，每遍历到一个元素，看看它的x+y，把它丢到ans[x+y]中。<br/>对角线遍历的另一种设定👉<a href="https://whitebeerhouse.github.io/2020/04/26/LeetCode-498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/#%F0%9F%93%9D%E9%A2%98%E7%9B%AE" target="_blank" rel="noopener">LeetCode-498 对角线遍历</a>。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    int row &#x3D; nums.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; arr;&#x2F;&#x2F;[i+j][count]</span><br><span class="line">    arr.resize(1e5);</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; row; ++i)&#123;            </span><br><span class="line">        int column &#x3D; nums[i].size();</span><br><span class="line">        for (int j &#x3D; 0; j &lt; column; ++j)&#123;</span><br><span class="line">            arr[i+j].push_back(nums[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        max &#x3D; column &gt; max ? column : max;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; row+max; ++i)&#123;</span><br><span class="line">        while (!arr[i].empty())&#123;</span><br><span class="line">            result.push_back(arr[i].back());</span><br><span class="line">            arr[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-27 移除元素</title>
    <url>/2020/04/28/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>被归类为“<strong>双指针</strong>”的一类吧…因为要求非暴力解法&amp;空间复杂度O(1)，那么就记录下不为val的那些值吧，<strong>原地记录</strong>。<br/>解法几乎一致的另一道题👉<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">LeetCode-26 删除排序数组中的重复项</a>。<br/>🐣：双指针究竟是哪些个流程至今还没系统了解，但我尝试了一下，朝着用双指针框住数组片段进行拷贝覆盖的死胡同里钻了…✊<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">    int len &#x3D; nums.size();</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (nums[i] !&#x3D; val)&#123;</span><br><span class="line">            nums[count] &#x3D; nums[i];</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-150 逆波兰表达式求值</title>
    <url>/2020/04/27/LeetCode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据逆波兰表示法，求表达式的值。</span><br><span class="line"></span><br><span class="line">有效的运算符包括 +, -, *, &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">· 整数除法只保留整数部分。</span><br><span class="line">· 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) &#x3D; 9</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p><strong>栈</strong>的经典应用。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">    int len &#x3D; tokens.size();</span><br><span class="line">    stack&lt;int&gt; record;        </span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (tokens[i] !&#x3D; &quot;+&quot; &amp;&amp; tokens[i] !&#x3D; &quot;-&quot; &amp;&amp; tokens[i] !&#x3D; &quot;*&quot; &amp;&amp; tokens[i] !&#x3D; &quot;&#x2F;&quot;)&#123;</span><br><span class="line">            int temp &#x3D; stoi(tokens[i], 0, 10);</span><br><span class="line">            record.push(temp);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;                </span><br><span class="line">        int temp_right &#x3D; record.top();</span><br><span class="line">        record.pop();</span><br><span class="line">        int temp_left &#x3D; record.top();</span><br><span class="line">        record.pop();</span><br><span class="line">        </span><br><span class="line">        if (tokens[i] &#x3D;&#x3D; &quot;+&quot;)   record.push(temp_left + temp_right);</span><br><span class="line">        else if (tokens[i] &#x3D;&#x3D; &quot;-&quot;)  record.push(temp_left - temp_right);</span><br><span class="line">        else if (tokens[i] &#x3D;&#x3D; &quot;*&quot;)  record.push(temp_left * temp_right); </span><br><span class="line">        else   record.push(temp_left &#x2F; temp_right);  </span><br><span class="line">        </span><br><span class="line">    &#125;        </span><br><span class="line">    return record.top();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-739 每日温度</title>
    <url>/2020/04/27/LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</span><br><span class="line"></span><br><span class="line">例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</span><br><span class="line"></span><br><span class="line">提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>准备两个<strong>栈</strong>保存还未得到匹配的温度和下标，遍历 temperatures 。如果该日温度超过栈顶的温度，则把栈中所有小于该日温度的数据都弹出（按照这个算法，栈中的数据必然是从大到小（底-&gt;顶）排列的）；如果该日温度低于栈顶温度，必然低于栈中所有温度，则 push 入栈中。注意栈空时的处理。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    int len &#x3D; T.size();</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    result.resize(len);</span><br><span class="line">    </span><br><span class="line">    stack&lt;int&gt; key;</span><br><span class="line">    stack&lt;int&gt; value;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        while (!value.empty() &amp;&amp; T[i] &gt; value.top())&#123;</span><br><span class="line">            int t_key &#x3D; key.top();</span><br><span class="line">            result[t_key] &#x3D; i-t_key;</span><br><span class="line">            value.pop();</span><br><span class="line">            key.pop();</span><br><span class="line">        &#125;       </span><br><span class="line">        key.push(i);</span><br><span class="line">        value.push(T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (!key.empty())&#123;</span><br><span class="line">        int temp &#x3D; key.top();</span><br><span class="line">        key.pop();</span><br><span class="line">        result[temp] &#x3D; 0;</span><br><span class="line">    &#125;      </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-892 三维形体的表面积</title>
    <url>/2020/04/27/LeetCode-892-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。</span><br><span class="line"></span><br><span class="line">每个值 v &#x3D; grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。</span><br><span class="line"></span><br><span class="line">请你返回最终形体的表面积。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">· 1 &lt;&#x3D; N &lt;&#x3D; 50</span><br><span class="line">· 0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 50</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>做加法</strong>。<br/>我们可以将单元格 (i, j) 上堆叠的 v 个正方体看成一个高度为 v 的柱子，然后分别计算每个柱子的表面积。<br/>首先，v &gt; 0 的话，柱子顶部、底部的表面积都是 1。<br/>然后是上、下、左、右四个侧面的表面积。以左侧的表面积为例：</p>
<ul>
<li>如果柱子位于网格左边缘，左侧没有其他柱子，那么左侧表面积为 v；</li>
<li>如果柱子比左边的柱子矮，那么左侧露不出来，表面积为 0；</li>
<li>如果柱子比左边的柱子高，假设左边柱子高度为 v’，那么左边露出来的表面积为 v - v’。</li>
</ul>
<p>其余的三个侧面以此类推。<br/><br>想法二：<strong>做减法</strong>。<br/>先计算全部的表面积，然后再减去重叠的部分。<br/>假设一共有 n 个立方体，每个立方体都有六个面，那么总的表面积应该是 6n。但是这些正方体堆叠在了一起，需要减掉一些因为堆叠而露不出来的表面积。每一对相邻的立方体接触在一起，都会让表面积减少 2。假设一共有 e 对相接触的立方体，即有 e 个接触面，表面积就会减少 2e。那么，最终的表面积就应该是 6n - 2e。<br/>那么如何计算立方体的接触面呢？很简单，我们还是把每个单元格上堆叠的 v 个立方体看成一个柱子。立方体的接触面可以分为柱子内部和柱子之间的接触面：</p>
<ul>
<li>v 个立方体的柱子内部，有 v - 1 个接触面</li>
<li>高度分别为 v、w 的两个立方体之间的接触面为 min(v, w)。</li>
</ul>
<p>🐣：Sicily线上赛有一道几乎一样的！！但当时我竟死磕用三视图去解🤦<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;加法</span><br><span class="line"></span><br><span class="line">int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123;</span><br><span class="line">    int n &#x3D; grid.size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; ++j)&#123;</span><br><span class="line">            &#x2F;&#x2F;上下</span><br><span class="line">            if (grid[i][j]) result +&#x3D; 2;</span><br><span class="line">            &#x2F;&#x2F;左右</span><br><span class="line">            if (j &#x3D;&#x3D; 0) result +&#x3D; grid[i][j];</span><br><span class="line">            if (j &#x3D;&#x3D; n-1) result +&#x3D; grid[i][j];</span><br><span class="line">            if (j &gt; 0 &amp;&amp; grid[i][j] &gt; grid[i][j-1]) result +&#x3D; (grid[i][j] - grid[i][j-1]);</span><br><span class="line">            if (j &lt; n-1 &amp;&amp; grid[i][j] &gt; grid[i][j+1])   result +&#x3D; (grid[i][j] - grid[i][j+1]);</span><br><span class="line">            &#x2F;&#x2F;前后</span><br><span class="line">            if (i &#x3D;&#x3D; 0) result +&#x3D; grid[i][j];</span><br><span class="line">            if (i &#x3D;&#x3D; n-1) result +&#x3D; grid[i][j];</span><br><span class="line">            if (i &gt; 0 &amp;&amp; grid[i][j] &gt; grid[i-1][j]) result +&#x3D; (grid[i][j] - grid[i-1][j]);</span><br><span class="line">            if (i &lt; n-1 &amp;&amp; grid[i][j] &gt; grid[i+1][j])   result +&#x3D; (grid[i][j] - grid[i+1][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;减法</span><br><span class="line"></span><br><span class="line">int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123;</span><br><span class="line">    int n &#x3D; grid.size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; ++j)&#123;</span><br><span class="line">            if (grid[i][j]) result +&#x3D; 4*grid[i][j]+2;</span><br><span class="line">            if (i &lt; n-1)</span><br><span class="line">                result -&#x3D; 2*min(grid[i][j], grid[i+1][j]);</span><br><span class="line">            if (j &lt; n-1)</span><br><span class="line">                result -&#x3D; 2*min(grid[i][j], grid[i][j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-498 对角线遍历</title>
    <url>/2020/04/26/LeetCode-498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出:  [1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/498.png"  alt=""><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>找规律，分奇偶讨论。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    int row &#x3D; matrix.size();</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    if (row &lt;&#x3D; 0)   return result;</span><br><span class="line">    int column &#x3D; matrix[0].size();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; row; ++i)&#123;</span><br><span class="line">        if (i % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; column; ++j)</span><br><span class="line">                if (i - j &gt;&#x3D; 0) result.push_back(matrix[i-j][j]);                </span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int j &#x3D; column-1; j &gt;&#x3D; 0; --j)</span><br><span class="line">                if (i - j &gt;&#x3D; 0) result.push_back(matrix[i-j][j]);                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 1; j &lt; column; ++j)&#123;</span><br><span class="line">        if ((row+j) % 2 &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; column-j; ++i)</span><br><span class="line">                if (row-1-i &gt;&#x3D; 0) result.push_back(matrix[row-1-i][j+i]);                 </span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int i &#x3D; column-j-1; i &gt;&#x3D; 0; --i)</span><br><span class="line">                if (row-1-i &gt;&#x3D; 0) result.push_back(matrix[row-1-i][j+i]);                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5393 可获得的最大点数</title>
    <url>/2020/04/26/LeetCode-5393-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</span><br><span class="line"></span><br><span class="line">每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</span><br><span class="line"></span><br><span class="line">你的点数就是你拿到手中的所有卡牌的点数之和。</span><br><span class="line"></span><br><span class="line">给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [1,1000,1], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [1,79,80,1,1,1,200,1], k &#x3D; 3</span><br><span class="line">输出：202</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 1 &lt;&#x3D; cardPoints.length &lt;&#x3D; 10^5</span><br><span class="line">· 1 &lt;&#x3D; cardPoints[i] &lt;&#x3D; 10^4</span><br><span class="line">· 1 &lt;&#x3D; k &lt;&#x3D; cardPoints.length</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>先求出前k个数的总和，然后前面去掉一个，后面加上一个，前面去掉一个，后面加上一个…每一次比较得到最大值就好了。<br/>🐣：天知道我试过多少种动态规划方案…是我迷糊了嘛动不动就dp🙇‍♀️<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int maxScore(vector&lt;int&gt;&amp; cardPoints, int k) &#123;</span><br><span class="line">    int len &#x3D; cardPoints.size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; ++i)&#123;</span><br><span class="line">        result +&#x3D; cardPoints[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp &#x3D; result;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; ++i)&#123;</span><br><span class="line">        temp -&#x3D; cardPoints[k-1-i];</span><br><span class="line">        temp +&#x3D; cardPoints[len-1-i];</span><br><span class="line">        if (temp &gt; result)  result &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-200 岛屿数量⭐</title>
    <url>/2020/04/25/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%E2%AD%90/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。 </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>深度优先遍历DFS</strong>。</p>
<ul>
<li>目标是找到矩阵中 “岛屿的数量” ，上下左右相连的 1 都被认为是连续岛屿。</li>
<li>dfs方法： 设目前指针指向一个岛屿中的某一点 (i, j)，寻找包括此点的岛屿边界。<ul>
<li>从 (i, j) 向此点的上下左右 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 做深度搜索。</li>
<li>终止条件：<ul>
<li>(i, j) 越过矩阵边界;</li>
<li>grid[i][j] == 0，代表此分支已越过岛屿边界。</li>
</ul>
</li>
<li>搜索岛屿的同时，执行 grid[i][j] = ‘0’，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。</li>
</ul>
</li>
<li>主循环：遍历整个矩阵，当遇到 grid[i][j] == ‘1’ 时，从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。</li>
</ul>
<p>想法二：<strong>广度优先遍历BFS</strong>。</p>
<ul>
<li>主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。</li>
<li>bfs 方法：<ul>
<li>借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1：<ul>
<li>若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列；</li>
<li>若不是则跳过此节点；</li>
</ul>
</li>
<li>循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿。<br><br/><br/></li>
</ul>
</li>
</ul>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;DFS（深度优先搜索）</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; copy, int i, int j)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; copy.size() || j &gt;&#x3D; copy[0].size() || copy[i][j] &#x3D;&#x3D; &#39;0&#39;) return;</span><br><span class="line">    copy[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">    dfs(copy, i, j-1);</span><br><span class="line">    dfs(copy, i, j+1);</span><br><span class="line">    dfs(copy, i-1, j);</span><br><span class="line">    dfs(copy, i+1, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int row_num &#x3D; grid.size();</span><br><span class="line">    if (row_num &#x3D;&#x3D; 0)   return 0;</span><br><span class="line">    int column_num &#x3D; grid[0].size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt;&amp; copy &#x3D; grid;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; row_num; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; column_num; ++j)&#123;</span><br><span class="line">            if (grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">                dfs(copy, i, j);</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;BFS（广度优先搜索）</span><br><span class="line"></span><br><span class="line">void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)&#123;</span><br><span class="line">    queue&lt;vector&lt;int&gt;&gt; q;</span><br><span class="line">    q.push(&#123;i, j&#125;);</span><br><span class="line">    while (!q.empty())&#123;</span><br><span class="line">        vector&lt;int&gt; first &#x3D; q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        i &#x3D; first[0];</span><br><span class="line">        j &#x3D; first[1];</span><br><span class="line">        if (i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0 &amp;&amp; i &lt; grid.size() &amp;&amp; j &lt; grid[0].size() &amp;&amp; grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">            grid[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">            q.push(&#123;i, j-1&#125;);</span><br><span class="line">            q.push(&#123;i, j+1&#125;);</span><br><span class="line">            q.push(&#123;i-1, j&#125;);</span><br><span class="line">            q.push(&#123;i+1, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int row_nums &#x3D; grid.size();</span><br><span class="line">    if (row_nums &#x3D;&#x3D; 0)  return 0;</span><br><span class="line">    int column_nums &#x3D; grid[0].size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; row_nums; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; column_nums; ++j)&#123;</span><br><span class="line">            if (grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">                bfs(grid, i, j);</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>手写，不在怕的；轮子，没想到的。</title>
    <url>/2020/04/25/%E6%89%8B%E5%86%99%EF%BC%8C%E4%B8%8D%E5%9C%A8%E6%80%95%E7%9A%84%EF%BC%9B%E8%BD%AE%E5%AD%90%EF%BC%8C%E6%B2%A1%E6%83%B3%E5%88%B0%E7%9A%84%E3%80%82/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;轮子</span><br><span class="line"></span><br><span class="line">string replaceSpace(string s) &#123;</span><br><span class="line">    return s.replace(&quot; &quot;,&quot;%20&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;手写</span><br><span class="line"></span><br><span class="line">string replaceSpace(string s) &#123;</span><br><span class="line">    int len &#x3D; s.size();</span><br><span class="line">    string result &#x3D; &quot;&quot;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39; &#39;)    result +&#x3D; &quot;%20&quot;;</span><br><span class="line">        else    result +&#x3D; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>

<hr>
<h2 id="📝题目-1"><a href="#📝题目-1" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝题解-1"><a href="#📝题解-1" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;轮子</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    ListNode* temp &#x3D; head;</span><br><span class="line">    while (temp)&#123;</span><br><span class="line">        result.push_back(temp-&gt;val);</span><br><span class="line">        temp &#x3D; temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;指的是下面这一步</span><br><span class="line">    reverse(result.begin(), result.end());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;手写</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; result, tmp;</span><br><span class="line">    ListNode* temp &#x3D; head;</span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line">    while (temp)&#123;</span><br><span class="line">        tmp.push_back(temp-&gt;val);</span><br><span class="line">        ++len;</span><br><span class="line">        temp &#x3D; temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;指的是下面这一步</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        result.push_back(tmp.back());</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>一些奇奇怪怪的原理/轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1541 数组中重复的数字</title>
    <url>/2020/04/25/LeetCode-1541-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[3, 1, 2, 3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>与<a href="https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fromtitle=%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86&fromid=731656&fr=aladdin" target="_blank" rel="noopener">抽屉原理</a>同理，即如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置。因为出现的元素值必然小于数组长度，所以可以把见到的元素放到索引的位置，如果交换时，发现索引处已存在该元素，则重复。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len &#x3D; nums.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        while (i !&#x3D; nums[i])&#123;</span><br><span class="line">            if (nums[i] &#x3D;&#x3D; nums[nums[i]])   return nums[i];</span><br><span class="line">            int temp &#x3D; nums[i];</span><br><span class="line">            nums[i] &#x3D; nums[temp];</span><br><span class="line">            nums[temp] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>一些奇奇怪怪的原理/轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-42 接雨水⭐</title>
    <url>/2020/04/23/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%AD%90/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/42.png"  alt=""><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>动态规划</strong>。对于每一列，找到该列左边最高的墙和右边最高的墙，根据木桶效应，取矮的那面墙与该列比较，若高于该列，则该列可蓄水。为避免重复计算左右最高墙高度，采用动态规划思想记忆化存储。<br/>想法二：<strong>栈</strong>。在遍历数组时维护一个栈。如果当前的条形块小于或等于栈顶的条形块，则将条形块的索引入栈，意思是当前的条形块被栈中的前一个条形块界定。如果一个条形块长于栈顶，可以确定栈顶的条形块被当前条形块和栈的前一个条形块界定，因此弹出栈顶元素并且累加。<br/><br>算法详细过程：</p>
<ul>
<li>使用栈来存储条形块的索引下标。</li>
<li>遍历数组：<ul>
<li>当栈非空且height[current] &gt; height[st.top()]<ul>
<li>意味着栈中元素可以被弹出。弹出栈顶元素top。</li>
<li>计算当前元素和栈顶元素的距离，准备进行填充操作: distance = current−st.top()−1</li>
<li>找出界定高度bounded_height = min(height[current], height[st.top()])</li>
<li>累加</li>
</ul>
</li>
<li>将当前索引下标入栈</li>
<li>将 current 移动到下个位置</li>
</ul>
</li>
</ul>
<p>🐣：看到题解前的乱七八糟的思路真是疯狂，疯狂WA，疯狂修改，脆败🙇‍♀️<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    if (len &lt; 3)    return 0;</span><br><span class="line">    int max_left[len], max_right[len];</span><br><span class="line">    max_left[0] &#x3D; height[0];</span><br><span class="line">    max_right[len-1] &#x3D; height[len-1];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; len-1; ++i)</span><br><span class="line">        max_left[i] &#x3D; max(max_left[i-1], height[i-1]);</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; len-2; i &gt;&#x3D; 0; --i)</span><br><span class="line">        max_right[i] &#x3D; max(max_right[i+1], height[i+1]);</span><br><span class="line"></span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; len-1; ++i)&#123;</span><br><span class="line">        int min_height &#x3D; min(max_left[i], max_right[i]);</span><br><span class="line">        if (height[i] &lt; min_height) result &#x3D; result+min_height-height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">int trap(vector&lt;int&gt;&amp; height) &#123;        </span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    int result &#x3D; 0, current &#x3D; 0;</span><br><span class="line">    stack&lt;int&gt; index;</span><br><span class="line">    while (current &lt; len)&#123;</span><br><span class="line">        while (!index.empty() &amp;&amp; height[current]&gt;height[index.top()])&#123;</span><br><span class="line">            int tmp_h &#x3D; height[index.top()];</span><br><span class="line">            index.pop();</span><br><span class="line">            if (index.empty())  break;</span><br><span class="line">            int distance &#x3D; current-index.top()-1;</span><br><span class="line">            int min_h &#x3D; min(height[current], height[index.top()]);</span><br><span class="line">            result +&#x3D; distance*(min_h-tmp_h);</span><br><span class="line">        &#125;</span><br><span class="line">        index.push(current);</span><br><span class="line">        ++current;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-884 两句话中的不常见单词</title>
    <url>/2020/04/21/LeetCode-884-%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个句子 A 和 B（句子是一串由空格分隔的单词。每个单词仅由小写字母组成）。</span><br><span class="line"></span><br><span class="line">如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。</span><br><span class="line"></span><br><span class="line">返回所有不常用单词的列表。</span><br><span class="line"></span><br><span class="line">您可以按任何顺序返回列表。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; &quot;this apple is sweet&quot;, B &#x3D; &quot;this apple is sour&quot;</span><br><span class="line">输出：[&quot;sweet&quot;,&quot;sour&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; &quot;apple apple&quot;, B &#x3D; &quot;banana&quot;</span><br><span class="line">输出：[&quot;banana&quot;]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 0 &lt;&#x3D; A.length &lt;&#x3D; 200</span><br><span class="line">· 0 &lt;&#x3D; B.length &lt;&#x3D; 200</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>学习一下map的用法，算法方面没啥好说的。<br/>🐣：STL强强强🤙<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; uncommonFromSentences(string A, string B) &#123;</span><br><span class="line">    unordered_map&lt;string, int&gt; record;</span><br><span class="line">    int lenA &#x3D; A.size(), lenB &#x3D; B.size();</span><br><span class="line">    string temp &#x3D; &quot;&quot;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; lenA; ++i)&#123;</span><br><span class="line">        if (A[i] &#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">            auto iter &#x3D; record.find(temp);</span><br><span class="line">            if (iter !&#x3D; record.end())   ++iter-&gt;second;</span><br><span class="line">            else    record.insert(pair&lt;string, int&gt;(temp, 1));</span><br><span class="line">            temp &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            temp +&#x3D; A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    auto iterator &#x3D; record.find(temp);</span><br><span class="line">    if (iterator !&#x3D; record.end())   ++iterator-&gt;second;</span><br><span class="line">    else    record.insert(pair&lt;string, int&gt;(temp, 1));</span><br><span class="line">    temp &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; lenB; ++i)&#123;</span><br><span class="line">        if (B[i] &#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">            auto iter &#x3D; record.find(temp);</span><br><span class="line">            if (iter !&#x3D; record.end())   ++iter-&gt;second;</span><br><span class="line">            else    record.insert(pair&lt;string, int&gt;(temp, 1));</span><br><span class="line">            temp &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            temp +&#x3D; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    iterator &#x3D; record.find(temp);</span><br><span class="line">    if (iterator !&#x3D; record.end())   ++iterator-&gt;second;</span><br><span class="line">    else    record.insert(pair&lt;string, int&gt;(temp, 1));</span><br><span class="line">    temp &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    auto iter &#x3D; record.begin();</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    for (; iter !&#x3D; record.end(); ++iter)&#123;</span><br><span class="line">        if (iter-&gt;second &#x3D;&#x3D; 1)  result.push_back(iter-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-11 盛最多水的容器</title>
    <url>/2020/04/18/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line"></span><br><span class="line">注意：你不能倾斜容器，且 n 的值至少为 2。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/11.jpg"  alt=""><br/></p>
<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>暴力的解法三两分钟写了出来，提交上去后超时了…超…时了…了…<br/>官方双指针思路：一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了1。这种情况下我们<strong>想要让指针移动后的容器体积增大，就要使移动后的容器的高尽量大</strong>，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会。<br/>🐣：（一开始我还觉得双指针还能咋用啊不就是跟暴力法一样控制个边而已吗打扰了原来有更进一步考虑（全个想无🙇‍♀️<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;O(n^2)</span><br><span class="line"></span><br><span class="line">int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len-1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; i+1; j &lt; len; ++j)&#123;</span><br><span class="line">            int sum &#x3D; (height[i] &lt; height[j] ? height[i]*(j-i) : height[j]*(j-i));</span><br><span class="line">            max &#x3D; max &gt; sum ? max : sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;O(n)</span><br><span class="line"></span><br><span class="line">int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; len-1;</span><br><span class="line">    while (left &lt; right)&#123;</span><br><span class="line">        int sum &#x3D; (height[left] &lt; height[right] ? height[left]*(right-left) : height[right]*(right-left));</span><br><span class="line">        max &#x3D; max &gt; sum ? max : sum;</span><br><span class="line">        if (height[left] &lt; height[right])   ++left;</span><br><span class="line">        else --right;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-877 石子游戏</title>
    <url>/2020/04/15/LeetCode-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</span><br><span class="line"></span><br><span class="line">游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</span><br><span class="line"></span><br><span class="line">亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</span><br><span class="line"></span><br><span class="line">假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">· 2 &lt;&#x3D; piles.length &lt;&#x3D; 500</span><br><span class="line">· 1 &lt;&#x3D; piles[i] &lt;&#x3D; 500</span><br><span class="line"> </span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</span><br><span class="line">如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>数学推<del>倒</del>导法</strong>。因为是偶数个堆，所以两个人最后拿到的堆数是一样的，但是因为石头的数量是奇数，所以最后两人拿到的石头数量肯定是一个多一个少，且和为奇数，所以先手的人只要选择多的那种方式拿就行了，所以先手必赢💪。<br/>想法二：<strong><del>标准</del>动态规划</strong>。跟<a href="https://whitebeerhouse.github.io/2020/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/#%F0%9F%93%9D%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">动态规划（一）</a>第一道例题算是同源，这里使用二维数组<strong>dp[i][j]表示从第i堆石子到第j堆石子先手和后手的最大分数差。</strong><br/>🐣：（靠…我是想做dp问题的怎么老遇上数学问题🙃<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;</span><br><span class="line">    &#x2F;&#x2F;dp[i][j]表示从i到j的最优分数差</span><br><span class="line"></span><br><span class="line">    int len &#x3D; piles.size();</span><br><span class="line">    int dp[len][len];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        dp[i][i] &#x3D; piles[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int length &#x3D; 1; length &lt;&#x3D; len-1; ++length)&#123;</span><br><span class="line">        for (int left &#x3D; 0; left &lt;&#x3D; len-length-1; ++left)&#123;</span><br><span class="line">            int right &#x3D; left + length;</span><br><span class="line">            dp[left][right] &#x3D; max(piles[left]-dp[left+1][right], piles[right]-dp[left][right-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[0][len-1] &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1277 统计全为1的正方形子矩阵</title>
    <url>/2020/04/15/LeetCode-1277-%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的正方形子矩阵的个数。</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">· 1 &lt;&#x3D; arr.length &lt;&#x3D; 300</span><br><span class="line">· 1 &lt;&#x3D; arr[0].length &lt;&#x3D; 300</span><br><span class="line">· 0 &lt;&#x3D; arr[i][j] &lt;&#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [0,1,1,1],</span><br><span class="line">  [1,1,1,1],</span><br><span class="line">  [0,1,1,1]</span><br><span class="line">]</span><br><span class="line">输出：15</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,0],</span><br><span class="line">  [1,1,0]</span><br><span class="line">]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>用 f[i][j] 表示以 (i, j) 为右下角的正方形的最大边长，那么除此定义之外，f[i][j] = x 也表示以 (i, j) 为右下角的正方形的数目为 x（即边长为 1, 2, …, x 的正方形各一个）。在计算出所有的 f[i][j] 后将它们进行累加，就可以得到矩阵中正方形的数目。<br/><br>不难得到 <strong>f[i][j] 的递推式：</strong><br/></p>
<ul>
<li>if i = 0 or j = 0 : f[i][j] = matrix[i][j];</li>
<li>if matrix[i][j] = 0 : f[i][j] = 0;</li>
<li>otherwise : f[i][j] = min(f[i-1][j], f[i][j-1], f[i-1][j-1]) + 1;<br><br/><br/></li>
</ul>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    int len1 &#x3D; matrix.size();</span><br><span class="line">    int len2 &#x3D; matrix[0].size();</span><br><span class="line">    int f[len1][len2];</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len2; ++j)&#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0)</span><br><span class="line">                f[i][j] &#x3D; matrix[i][j];</span><br><span class="line">            else &#123;</span><br><span class="line">                if (matrix[i][j])&#123;</span><br><span class="line">                    f[i][j] &#x3D; min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1])+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else    f[i][j] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            result +&#x3D; f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1025 除数博弈</title>
    <url>/2020/04/15/LeetCode-1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</span><br><span class="line"></span><br><span class="line">最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</span><br><span class="line"></span><br><span class="line">· 选出任一 x，满足 0 &lt; x &lt; N 且 N % x &#x3D;&#x3D; 0 。</span><br><span class="line">· 用 N - x 替换黑板上的数字 N 。</span><br><span class="line">· 如果玩家无法执行这些操作，就会输掉游戏。</span><br><span class="line"></span><br><span class="line">只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>👉震惊全场之“洋洋洒洒十来行，一看题解就一行”🤙🤙🤙<br/><strong>如果N是奇数，因为奇数的所有因数都是奇数，因此 N 进行一次 N-x 的操作结果一定是偶数，所以如果 a 拿到了一个奇数，那么轮到 b 的时候，b 拿到的肯定是偶数，这个时候 b 只要进行 -1， 还给 a 一个奇数，那么这样子 b 就会一直拿到偶数，到最后 b 一定会拿到最小偶数2，a 就输了。</strong><br/>所以如果游戏开始时Alice拿到N为奇数，那么她必输，也就是false。如果拿到N为偶数，她只用 -1，让Bob拿到奇数，最后Bob必输，结果就是true。<br/>🐣：（我不配（以及这个判断奇偶的方式也过于高效<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool divisorGame(int N) &#123;</span><br><span class="line">    return !(N&amp;1);</span><br><span class="line">    &#x2F;&#x2F;return (N % 2 &#x3D;&#x3D; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-2 两数相加</title>
    <url>/2020/04/15/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>原写法思路一样的，就是不够简洁，参考了评论区，这个三目运算符用得真是666啊！<br/>🐣：坐等一个困难版本的该题。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">    ListNode* head &#x3D; new ListNode(0, nullptr);</span><br><span class="line">    ListNode* now &#x3D; head;</span><br><span class="line">    int carry &#x3D; 0, sum &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;ListNode *p &#x3D; l1, *q &#x3D; l2;&#x2F;&#x2F;最好是不破坏参数</span><br><span class="line">    while (l1 || l2 || carry)&#123;</span><br><span class="line">        sum &#x3D; (l1?l1-&gt;val:0) + (l2?l2-&gt;val:0) + carry;</span><br><span class="line">        carry &#x3D; sum &#x2F; 10;</span><br><span class="line">        sum %&#x3D; 10;</span><br><span class="line">        ListNode*temp &#x3D; new ListNode(sum, nullptr);</span><br><span class="line">        now-&gt;next &#x3D; temp;</span><br><span class="line">        now &#x3D; now-&gt;next;</span><br><span class="line">        l1 &#x3D; l1?l1-&gt;next:l1;</span><br><span class="line">        l2 &#x3D; l2?l2-&gt;next:l2;</span><br><span class="line">    &#125;</span><br><span class="line">    return head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-62 不同路径</title>
    <url>/2020/04/14/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角，每次只能向下或者向右移动一步，机器人试图达到网格的右下角，总共有多少条不同的路径？（1 &lt;&#x3D; m, n &lt;&#x3D; 100；题目数据保证答案小于等于 2 * 10^9）</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>很简单入门的动态规划。不过最初想用排列组合公式解答的，无奈计算过程溢出了🤷‍♀️。<br/>🐣：评论区有大佬说遇到其他使用排列组合会溢出的题目可以转化成这个题👍思路清奇啊👍👍<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    int f[m][n];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; ++j)&#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0)   f[i][j] &#x3D; 1;</span><br><span class="line">            else    f[i][j] &#x3D; f[i-1][j]+f[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5382 HTML 实体解析器</title>
    <url>/2020/04/12/LeetCode-5382-HTML-%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>由于题目和代码中的特殊字符都被博客转义了，所以这篇先暂存在CSDN上<a href="https://blog.csdn.net/weixin_43864929/article/details/105468685" target="_blank" rel="noopener">LeetCode-5382 HTML 实体解析器</a>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-102 二叉树的层序遍历</title>
    <url>/2020/04/11/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，请你返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>递归</strong>遍历。难点大概就是如何加入新的一层。<br/>想法二：<strong>BFS（广度优先搜索）</strong>。利用<a href="https://en.cppreference.com/w/cpp/container/queue" target="_blank" rel="noopener">队列</a>先进先出的特性逐层存储、读取和弹出子节点。<br/>🐣：都是上学期数据结构的内容，有点遗忘了…<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">void traverse(vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth, TreeNode* root)&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)   return;</span><br><span class="line">    if (depth &gt;&#x3D; result.size())</span><br><span class="line">        result.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">    result[depth].push_back(root-&gt;val);</span><br><span class="line">    traverse(result, depth+1, root-&gt;left);</span><br><span class="line">    traverse(result, depth+1, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    traverse(result, 0, root);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    if (root !&#x3D; NULL)</span><br><span class="line">        q.push(root);</span><br><span class="line">    </span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int count &#x3D; q.size();</span><br><span class="line">        vector&lt;int&gt; layer;</span><br><span class="line">        while(count &gt; 0)&#123;</span><br><span class="line">            TreeNode* tmp &#x3D; q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            layer.push_back(tmp-&gt;val);</span><br><span class="line">            if (tmp-&gt;left !&#x3D; NULL)  q.push(tmp-&gt;left);</span><br><span class="line">            if (tmp-&gt;right !&#x3D; NULL)  q.push(tmp-&gt;right);</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(layer);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1419 旋转矩阵</title>
    <url>/2020/04/11/LeetCode-1419-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。（不占用额外空间能否做到？）</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：按照数学规律直接改变相应位置的值，需要额外拷贝一个副本作为数据来源。<br/>想法二：<strong>不占用额外空间，</strong> 先将矩阵以对角线为轴翻转再左右对称翻转。<br/>🐣：不考虑性能的话简直就一水题，强制缩减时空复杂度的话，倒真不容易想到这个翻转法…<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; c_matrix &#x3D; matrix;</span><br><span class="line">    int len &#x3D; matrix.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len; ++j)&#123;</span><br><span class="line">            matrix[i][j] &#x3D; c_matrix[len-1-j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    int len &#x3D; matrix.size();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;以对角线为轴翻转 </span><br><span class="line">    for (int i &#x3D; 0; i &lt; len-1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; i+1; j &lt; len; ++j)&#123;</span><br><span class="line">            int temp &#x3D; matrix[i][j];</span><br><span class="line">            matrix[i][j] &#x3D; matrix[j][i];</span><br><span class="line">            matrix[j][i] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;左右对称翻转</span><br><span class="line">    for (int j &#x3D; 0; j &lt; len&#x2F;2; ++j)&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">            int temp &#x3D; matrix[i][j];</span><br><span class="line">            matrix[i][j] &#x3D; matrix[i][len-1-j];</span><br><span class="line">            matrix[i][len-1-j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-151 翻转字符串里的单词</title>
    <url>/2020/04/10/LeetCode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>毫不费力的思路：分割出单词-&gt;反向拼接<br/>可以用很多方式完成。Java支持库函数split()可以直接以空格为分隔符拆解，trim()筛掉前后空格，几行代码搞定；C++选手可以用stringstream或者手动实现分割拼接，据说此题的出题目的是考察双指针操作字符数组…<br/>我用的正则表达式辅助实现分割，vector容器实现反向拼接…总之题目不是很难，但是手动实现时难免踩到很多坑🤦‍♀️<br/><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/" target="_blank" rel="noopener">官方思路和题解请戳此😃</a><br><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string reverseWords(string s) &#123;</span><br><span class="line">    vector&lt;string&gt; words;</span><br><span class="line">    int len &#x3D; s.size();</span><br><span class="line">    string tmp &#x3D; &quot;&quot;;</span><br><span class="line">    regex reg(&quot;[ ]*&quot;);&#x2F;&#x2F;空或纯空格时为真</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (regex_match(tmp, reg))	tmp &#x3D; &quot;&quot;;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; !regex_match(tmp, reg))&#123;</span><br><span class="line">            words.push_back(tmp);</span><br><span class="line">            tmp &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            tmp +&#x3D; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!regex_match(tmp, reg))	words.push_back(tmp);</span><br><span class="line"></span><br><span class="line">    int len2 &#x3D; words.size();</span><br><span class="line">    if (len2 &#x3D;&#x3D; 0) return &quot;&quot;;&#x2F;&#x2F;题目没有讲但是输入为全空格时输出为空，这里容易被坑</span><br><span class="line">    string temp &#x3D; &quot;&quot;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len2-1; ++i)&#123;</span><br><span class="line">        temp +&#x3D; words.back();</span><br><span class="line">        temp +&#x3D; &quot; &quot;;</span><br><span class="line">        words.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    temp +&#x3D; words.back();</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划（二）</title>
    <url>/2020/04/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><a href="#1121">soj 1121 –Tri Tiling</a><br><a href="#1527">soj 1527 –Tiling a Grid With Dominoes</a><br><a href="#1828">soj 1828 –Minimal</a></p>
<hr>
<p>⭐⭐⭐⭐<a name="1121"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1121 --Tri Tiling</span><br><span class="line">题目：用1*2的长方形铺满3*n的长方形，有多少种方法？（如下图）</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.9/image/1121-0.png"  alt=""><br/><br>初始状态，n=2时，可以平铺出矩形（3种情况）和非矩形（2种情况），如下图所示。<br/><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.1/image/1121-1.png"  alt=""><br/><br/><br><strong>题解一</strong>：用f[i]表示铺满3 * (2i)的长方形的方案数，用g[i]表示铺满3 * (2i)的长方形，并且向后伸展出部分形状的方案数。则有：</p>
<ul>
<li>f[i]=3 * f[i-1]+g[i-1]</li>
</ul>
<p>3 * f[i-1]即在f[i-1]的基础上要加上恰好的3 * 2矩形才能构成f[i]，而3 * 2矩形有3种情况（如上图）；g[i-1]即对于每一种非矩形都只有一种方式可以填补其使之恰为矩形。</p>
<ul>
<li>g[i]=2 * f[i-1]+g[i-1]</li>
</ul>
<p>2 * f[i-1]即在f[i-1]的基础上要加上2种非矩形之一才能构成g[i]；g[i-1]即对于每一种非矩形都只有一种方式可以填补其使之恰为非矩形。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 32;</span><br><span class="line">int f[maxn], g[maxn];</span><br><span class="line"></span><br><span class="line">int dp(int n) &#123;</span><br><span class="line">	if (n % 2 &#x3D;&#x3D; 1)	return 0;</span><br><span class="line">	if (n &#x3D;&#x3D; 0)	return f[0] &#x3D; 1;</span><br><span class="line">	f[1] &#x3D; 3;</span><br><span class="line">	g[1] &#x3D; 2;</span><br><span class="line">	int tmp &#x3D; n &#x2F; 2;</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; tmp; ++i) &#123;</span><br><span class="line">		f[i]&#x3D;3*f[i-1]+g[i-1];</span><br><span class="line">		g[i]&#x3D;2*f[i-1]+g[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	return f[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin &gt;&gt; n &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">		cout &lt;&lt; dp(n) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>

<p><strong>题解二：数学规律推算法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要使3*n是一个矩形，有两种可能:</span><br><span class="line">    1. 3*(n-2)也是一个矩形，那么只要再拼上一个3*2的就可以了。这个3*2有3种情况,所以是3*f(n-2);</span><br><span class="line"></span><br><span class="line">    2. 3*(n-2)不是一个矩形，这种情况下，你只有一种添加2*1块的方法使得3*n是矩形，还需要对3*(n-4)的形状做判断：</span><br><span class="line"></span><br><span class="line">        1. 3*(n-4)是一个矩形，那么只要再拼一个L形或者倒L形就可以使得3*(n-2)不是矩形了，这里就是2*f(n-4);</span><br><span class="line"></span><br><span class="line">        2. 3*(n-4)不是一个矩形，那么也是只有一种添加2*1块的方法能使3*(n-2)不是矩形，接下来就来考虑3*(n-6)：</span><br><span class="line"></span><br><span class="line">             1. 3*(n-6)是一个矩形，那么只要再拼一个L形或者倒L形就可以使得3*(n-4)不是矩形了，这里就是2*f(n-6);</span><br><span class="line"></span><br><span class="line">             2. 3*(n-6)不是一个矩形，……</span><br></pre></td></tr></table></figure>
<p>综上，可以得到递推式：<strong>f(n) = 3 * f(n-2) + 2 * f(n-4) + 2 * f(n-6) + … + 2 * f(0)</strong>，其中初始值<strong>f(0)=1</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 30;</span><br><span class="line">int f[maxn] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int dp(int n) &#123;</span><br><span class="line">	if (n % 2 &#x3D;&#x3D; 1)	return 0;</span><br><span class="line">	if (n &#x3D;&#x3D; 0)	return f[0] &#x3D; 1;</span><br><span class="line">	if (n &#x3D;&#x3D; 2)	return f[2] &#x3D; 3;</span><br><span class="line">	if (f[n] !&#x3D; 0)	return f[n];</span><br><span class="line">	f[n] +&#x3D; 3 * dp(n - 2);</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; n&#x2F;2; ++i) &#123;</span><br><span class="line">		f[n] +&#x3D; 2 * dp(n - 2 * i);</span><br><span class="line">	&#125;</span><br><span class="line">	return f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin &gt;&gt; n &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">		cout &lt;&lt; dp(n) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐⭐⭐<a name="1527"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1527 --Tiling a Grid With Dominoes</span><br><span class="line">题目：用1*2的长方形铺满4*n的长方形，有多少种方法？（如下图）</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1527-0.png"  alt=""><br/><br>处理方式与上题有些相似，但思路有所不同：<strong>用f[i][j]表示前4 * i列已经完全填满，并且第(i+1)列情况为第j种形状的方案数。</strong>其中，共有5种形状，分别是：<br/><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1527-1.jpg"  alt=""><br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1001;</span><br><span class="line">int f[maxn][5];</span><br><span class="line"></span><br><span class="line">int dp(int N) &#123;</span><br><span class="line">	f[0][0] &#x3D; f[1][0] &#x3D; f[1][1] &#x3D; f[1][3] &#x3D; f[1][4] &#x3D; 1;</span><br><span class="line">	f[1][2] &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">		f[i][0] &#x3D; f[i-2][0]+f[i-1][0]+f[i-1][1]+f[i-1][3]+f[i-1][4];</span><br><span class="line">		f[i][1] &#x3D; f[i-1][0]+f[i-1][4];</span><br><span class="line">		f[i][2] &#x3D; f[i-1][3];</span><br><span class="line">		f[i][3] &#x3D; f[i-1][0]+f[i-1][2];</span><br><span class="line">		f[i][4] &#x3D; f[i-1][0]+f[i-1][1];</span><br><span class="line">	&#125;</span><br><span class="line">	return f[N][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int cases;</span><br><span class="line">	cin &gt;&gt; cases;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; cases; ++i) &#123;</span><br><span class="line">		int N;</span><br><span class="line">		cin &gt;&gt; N;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dp(N) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐<a name="1828"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1828 --Minimal</span><br><span class="line">题目：There are two sets S1 and S2 subjecting to:</span><br><span class="line">(1) S1, S2 are both the subsets of &#123;x| x is an integer and 0 &lt; x &lt; 1,000,000&#125;</span><br><span class="line">(2) 0 &lt; |S1| &lt; |S2| &lt; 500</span><br><span class="line"> </span><br><span class="line">F(S1, S2) &#x3D; min &#123;|a1-b1| + |a2-b2| + … + |aN-bN|&#125; in which ai ∈S1, bi ∈S2, ai ≠aj if i≠j, bi ≠bj if i≠j (i, j &#x3D; 1, 2 … N，N &#x3D; |S1|)</span><br><span class="line"></span><br><span class="line">For each test case, print the result of F(S1 ,S2).</span><br></pre></td></tr></table></figure>
<p>最开始我的想法是，将S1和S2作笛卡尔积（定义X为两数差距），在一个二维数组里记录两两之差的绝对值，对S1每个元素都匹配以S2某个元素使得差距尽可能小。<strong>尝试了几个测例都过了，但是OJ上面WA了，这个解法个人觉得也有些牵强，无法证明，但又无法证伪😭。</strong><br/><br><font color='gray'>&lt; 以下解释参考相关资料信息 &gt;</font><br/><br>假设我们从S2中选择了某些数，假设选出的数组成S3，那么S3中最小的数肯定匹配S1中最小的数，S3中次小的数匹配S1中次小的数…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">证明：</span><br><span class="line">假设S1中有了a1,a2,S3中有b1,b2</span><br><span class="line">且a1&lt;&#x3D;a2,b1&lt;&#x3D;b2</span><br><span class="line">那么有|a1-b1|+|a2-b2|&lt;&#x3D;|a1-b2|+|a2-b1|（数学问题）</span><br><span class="line">所以从小到大一个个匹配不会更差，只会更好。</span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong><br>对S1和S2分别从小到大排序，用f[i][j]表示S1中的前i个数，与S2中的前j个数匹配（从j个数选i个数出来），显然有：<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i][j] &#x3D; inf(j &lt; i)</span><br><span class="line">f[0][0] &#x3D; 0</span><br><span class="line">f[i][j] &#x3D; min&#123;f[i-1][j-1]+|a[i]-b[j]|,f[i][j-1]&#125;,j&gt;&#x3D;i</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define inf 1&lt;&lt;30</span><br><span class="line">const int maxn &#x3D; 501;</span><br><span class="line">int f[maxn][maxn];</span><br><span class="line">int S1[maxn], S2[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int cases;</span><br><span class="line">	cin &gt;&gt; cases;</span><br><span class="line">	while (cases--) &#123;</span><br><span class="line">		int N, M;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">			cin &gt;&gt; S1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; M; ++i) &#123;</span><br><span class="line">			cin &gt;&gt; S2[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort(S1+1, S1+N+1);</span><br><span class="line">		sort(S2+1, S2+M+1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; M; ++j) &#123;</span><br><span class="line">				if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)</span><br><span class="line">					f[i][j] &#x3D; 0;</span><br><span class="line">				else if (i &gt; j) &#123;</span><br><span class="line">					f[i][j] &#x3D; inf;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					f[i][j] &#x3D; inf;</span><br><span class="line">					if (i &gt; 0)</span><br><span class="line">						f[i][j] &#x3D; min(f[i][j], f[i-1][j-1]+abs(S1[i]-S2[j]));</span><br><span class="line">					if (j &gt; 0)</span><br><span class="line">						f[i][j] &#x3D; min(f[i][j], f[i][j-1]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; f[N][M] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（未完待续）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-329 判断子序列</title>
    <url>/2020/04/08/LeetCode-329-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</span><br><span class="line">你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。</span><br><span class="line">字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 true.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 false.</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>注意，字符串t可能很长，所以不适合用下标去标记和遍历（大概率会溢出）。<br/>使用<strong>双指针</strong>方式进行遍历，判断方式以<strong>字符串s是否遍历完</strong>为标准。<br><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isSubsequence(string s, string t) &#123;</span><br><span class="line">    char* spt &#x3D; &amp;s[0];</span><br><span class="line">    char* tpt &#x3D; &amp;t[0];</span><br><span class="line">    while(*spt &amp;&amp; *tpt)&#123;</span><br><span class="line">        if (*spt &#x3D;&#x3D; *tpt)   spt++;</span><br><span class="line">        tpt++;</span><br><span class="line">    &#125;</span><br><span class="line">    return (*spt &#x3D;&#x3D; &#39;\0&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划（一）</title>
    <url>/2020/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="📝算法介绍"><a href="#📝算法介绍" class="headerlink" title="📝算法介绍"></a><strong>📝算法介绍</strong></h2><p><strong>动态规划</strong>（Dynamic programming）常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br/><br>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于<strong>优化递归问题</strong>，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。<br/><br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<strong>记忆化存储</strong>，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。<br/></p>
<hr>
<h2 id="👉一个例题"><a href="#👉一个例题" class="headerlink" title="👉一个例题"></a><strong>👉一个例题</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1176 --Two Ends</span><br><span class="line">题目：给一个长度为n的数列ai，两个人在上面做交替取数，每个人的每一轮从这个数列的两端中取出一个数（不能不操作）。先手可以自由选择策略，后手选择贪心策略。贪心策略是指，如果两端数大小不同，选择大的那个；如果相同选择左边那个。问最后先手能赢后手多少分。(1&lt;&#x3D;n&lt;&#x3D;1000且n为偶数)</span><br></pre></td></tr></table></figure>
<p>我们定义一个二维数组values储存所有的解的情况，定义一维数组num储存数字序列；然后定义动态规划函数dp(int left, int right)，其中left, right分别表示左右边界的牌，玩家每一次选择都有两种情况：选择最左边的牌或最右边的牌。故每一次动态规划都有两种方案：<br/></p>
<ul>
<li>第一种，先手选择最左边的牌a，那么后手就会进行贪心算法选择剩下的左右边界中最大的那张牌，如果最左边大，则后手取走牌left+1，下一次dp序列为left+2到right；如果最右边大，则后手取走牌right，下一次dp序列为left+1到right-1；<br/></li>
<li>第二种，先手选择最右边的牌right，那么后手就会进行贪心算法选择剩下的左右边界中最大的那张牌，如果最左边大，则后手取走牌left，下一次dp序列为left+1到right-1；如果最右边大，则后手取走牌right-1，下一次dp序列为left到right-2；<br/></li>
</ul>
<p>每一次dp都对上述两种方案进行比较，选择先手分值比较高的方案对values[left][right]进行赋值，最终找出最好的方案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000;</span><br><span class="line">int num[maxn];</span><br><span class="line">int values[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int dp(int left, int right) &#123;&#x2F;&#x2F;参数都是index</span><br><span class="line">	if (left &gt; right)	return 0;</span><br><span class="line">	if (values[left][right] !&#x3D; -1)	return values[left][right];</span><br><span class="line">	values[left][right] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	values[left][right] &#x3D; max(values[left][right], num[left+1] &gt;&#x3D; num[right] ? num[left]+dp(left+2,right) : num[left]+dp(left+1,right-1));&#x2F;&#x2F;先手拿了左边</span><br><span class="line">	values[left][right] &#x3D; max(values[left][right], num[left] &gt;&#x3D; num[right-1] ? num[right]+dp(left+1,right-1) : num[right]+dp(left,right-2));&#x2F;&#x2F;先手拿了右边</span><br><span class="line">	return values[left][right];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int count &#x3D; 0;</span><br><span class="line">	while (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">		count++;</span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">			cin &gt;&gt; num[i];</span><br><span class="line">			sum +&#x3D; num[i];</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n; ++j) &#123;</span><br><span class="line">				values[i][j] &#x3D; -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;In game &quot; &lt;&lt; count &lt;&lt; &quot;, the greedy strategy might lose by as many as &quot; &lt;&lt; 2*dp(0, n - 1)-sum &lt;&lt; &quot; points.&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="👉另一个例题"><a href="#👉另一个例题" class="headerlink" title="👉另一个例题"></a><strong>👉另一个例题</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1011 --Lenny&#39;s Lucky Lotto</span><br><span class="line">题目：给定N，M，问有多少个长度为N的整数序列，满足所有数都在[1,M]内，并且后一个数都至少是前一个数的两倍。</span><br></pre></td></tr></table></figure>
<p>用f[i][j]表示长度为i，最大数为j的序列的数目；用s[i][j]表示长度为i，最大数不超过j的序列的数目，那么可以推出：s[i][j]=s[i][j-1]+f[i][j]、f[i][j]=s[i-1][j/2]。<br/><br>在这组递推式中我们进行了<strong>记忆存储</strong>，长度每增加1，利用已记录的原长度的相关数据简单计算得到新长度的数据并记录，<strong>自底向上</strong>递推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long long dp(int n, int m) &#123;</span><br><span class="line">	long long s[11][2001] &#x3D; &#123;0&#125;;</span><br><span class="line">	long long f[11][2001] &#x3D; &#123;0&#125;;</span><br><span class="line">	for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">		f[1][j] &#x3D; 1;</span><br><span class="line">		s[1][j] &#x3D; j;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">		f[i][0] &#x3D; s[i][0] &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">			f[i][j] &#x3D; s[i-1][j&#x2F;2];</span><br><span class="line">			s[i][j] &#x3D; s[i][j-1] + f[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return s[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❗ Sicily的题设中意于很大的数，所以写的时候注意看看需不需要把int改成long long（没错我就时常因为这个问题WA）。<br><br/></p>
<hr>
<h2 id="📝小结"><a href="#📝小结" class="headerlink" title="📝小结"></a><strong>📝小结</strong></h2><p>可见，上述例题最主要的共同点：<strong>记忆存储</strong>，即建立二维数组-&gt;代入参数-&gt;逐层递推的过程。这是动态规划问题最常见的套路之一。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心法（二）</title>
    <url>/2020/03/28/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><a href="#1035">soj 1035 –DNA matching</a><br><a href="#1681">soj 1681 –Matchsticks</a><br><a href="#1620">soj 1620 –SCVs and minerals</a><br><a href="#2503">soj 2503 –最长字符串</a><br><a href="#1783">soj 1783 –Large is Better</a><br><a href="#8536">soj 8536 –Happy Camper</a><br><a href="#6771">soj 6771 –Class Packing</a></p>
<hr>
<p>⭐⭐⭐<a name="1035"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1035 --DNA matching</span><br><span class="line">题目：给定n个DNA单链，问最多能组成多少对DNA双链，每一个DNA单链只能使用一次，且不可翻转。两个DNA单链能够形成一对DNA双链的条件是对应位置A&#x2F;T，C&#x2F;G配对。（1&lt;&#x3D;n&lt;&#x3D;100）</span><br></pre></td></tr></table></figure>
<p>第一段乍一看有点不大好处理，其实可以利用数组来解决对应位配对的情况！而对于整体的求解，类似于遍历去找配对的一对对，只不过这里是读入数据时便确定了配对情况：与集合里已有的DNA若可配对则计数+1，否则将读入的DNA装进待配对集合里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">int matching(int n)&#123;</span><br><span class="line">	static char match_str[127];</span><br><span class="line">	match_str[&#39;A&#39;] &#x3D; &#39;T&#39;;</span><br><span class="line">	match_str[&#39;T&#39;] &#x3D; &#39;A&#39;;</span><br><span class="line">	match_str[&#39;G&#39;] &#x3D; &#39;C&#39;;</span><br><span class="line">	match_str[&#39;C&#39;] &#x3D; &#39;G&#39;;</span><br><span class="line">	</span><br><span class="line">	int matchNum &#x3D; 0;</span><br><span class="line">	multiset&lt;string&gt; S;</span><br><span class="line">	string str, matchedStr;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; ++i)&#123;&#x2F;&#x2F; n条DNA</span><br><span class="line">		cin &gt;&gt; str;</span><br><span class="line">		matchedStr &#x3D; &quot;&quot;;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; str.size(); ++j)&#123;</span><br><span class="line">			matchedStr +&#x3D; match_str[str[j]];</span><br><span class="line">		&#125;</span><br><span class="line">		if (S.count(matchedStr))&#123;</span><br><span class="line">			++ matchNum;</span><br><span class="line">			S.erase(S.lower_bound(matchedStr));</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			S.insert(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return matchNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐<a name="1681"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1681 --Matchsticks</span><br><span class="line">题目：如下图所示，给定n根火柴，求其可以摆出的最小的数和最大的数（2&lt;&#x3D;n&lt;&#x3D;100）</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.3/image/1681.jpg"  alt=""><br/><br>显然，由于数字1只需要2根火柴以及数字7只需要3根火柴，最大的数必然全为1（偶数根火柴）或打7开头后全为1（奇数根火柴）。<br/><br>而对于最小的数，先枚举火柴数少的情况，再通过递归对火柴数更多的情况进行选择。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string minNum(int matchsticks)&#123;&#x2F;&#x2F;不喜用switch-case语句</span><br><span class="line">	if (matchsticks &#x3D;&#x3D; 2)	return &quot;1&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 3)	return &quot;7&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 4)	return &quot;4&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 5)	return &quot;2&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 6)	return &quot;6&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 7)	return &quot;8&quot;;	</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 8) 	return &quot;10&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 10) 	return &quot;22&quot;;</span><br><span class="line">	else &#123;</span><br><span class="line">		string min1&#x3D; minNum(matchsticks - 7) + &quot;8&quot;;</span><br><span class="line">		string min2 &#x3D; minNum(matchsticks - 6) + &quot;0&quot;;</span><br><span class="line">		if (min1.size() &lt; min2.size() || min1 &lt; min2)	return min1;</span><br><span class="line">		else return min2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string maxNum(int matchsticks)&#123;</span><br><span class="line">	string tmp &#x3D; &quot;&quot;;</span><br><span class="line">	if (matchsticks % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; matchsticks&#x2F;2; ++i) &#123;</span><br><span class="line">			tmp +&#x3D; &quot;1&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		tmp &#x3D; &quot;7&quot;;</span><br><span class="line">		matchsticks -&#x3D; 3;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; matchsticks &#x2F; 2; ++i) &#123;</span><br><span class="line">			tmp +&#x3D; &quot;1&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此题有两个坑：<strong>1.</strong> 题目要求”no leading zeroes”，这里也包括了一位数的情况，即给定6根火柴棒时最小数不取0。<br><strong>2.</strong> 虽然火柴数为9的情况可以由递归解决但为10时不可，所以也需另外给出。</p>
<hr>
<p>⭐⭐⭐⭐<a name="1620"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1620 --SCVs and minerals</span><br><span class="line">题目：游戏“ StarCraft”设定为，最初您有N个SCV和M个mineral。每个SCV可以在一秒钟内获得C个mineral，而指挥中心可以立即用P个mineral生产1个SCV。求在S秒后可获得的最多的mineral数量。</span><br></pre></td></tr></table></figure>
<p>最开始的想法就是递归调用，想在每一步都得到最多的mineral。样例输出很快否定了这个方法，仔细一想才发现，这个问题可以转换成我们熟悉的场景——生意买卖，只要作为生产设备的SCV能够在剩下的时间内产出不少于成本价P的mineral，那么赚得的肯定就最多了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int testNum &#x3D; 0;</span><br><span class="line">	cin &gt;&gt; testNum;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; testNum; ++i) &#123;</span><br><span class="line">		int N, M, C, P, S;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M &gt;&gt; C &gt;&gt; P &gt;&gt; S;	</span><br><span class="line">		for (int j &#x3D; 0; j &lt; S; ++j) &#123;</span><br><span class="line">			if ((S - j) * C &gt;&#x3D; P) &#123;&#x2F;&#x2F;P是获得一个SCV的成本，(S-j)*C是该SCV能带来的收入</span><br><span class="line">				N +&#x3D; M &#x2F; P;</span><br><span class="line">				M %&#x3D; P;</span><br><span class="line">			&#125;</span><br><span class="line">			M +&#x3D; N * C;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; M &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐⭐<a name="2503"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 2503 --最长字符串</span><br><span class="line">题目：要求你构造一个由字符&#39;A&#39;,&#39;B&#39;组成的字符串, 满足以下几个条件:</span><br><span class="line">1) A的个数&lt;&#x3D;countA</span><br><span class="line">2) B的个数&lt;&#x3D;countB</span><br><span class="line">3) 连续的A的个数不可以超过maxA.</span><br><span class="line">4) 连续的B的个数不可以超过maxB.</span><br><span class="line">5) 这个字符串的长度最长.</span><br><span class="line">给定countA, countB, maxA, maxB, 求输出字符串的最大长度。</span><br></pre></td></tr></table></figure>
<p>不知道是不是被算法名字所束缚了，总想着在每一步都积累最多的’A’或’B’以求整体最大，这个想法最大的漏洞在于：两者的数量差可能是<strong>悬殊</strong>的，这个时候尽可能更多地分组才是最优解。<br/><br/><br>此题解法：将A或B作为基准，另外一个进行分组作为分隔符。如果非分隔符多于分组数量，尽可能填满分隔符之间的空隙；若分组数量多于非分隔符，则尽可能填充更多的空隙。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int handler(int countA, int countB, int maxA, int maxB) &#123;&#x2F;&#x2F;以A为基准，以B为分隔符</span><br><span class="line">	if (maxA &#x3D;&#x3D; 0)	return min(maxB, countB);</span><br><span class="line">	if (maxB &#x3D;&#x3D; 0)	return min(maxA, countA);</span><br><span class="line"></span><br><span class="line">	int despNum &#x3D; ceil(countB &#x2F; maxB);&#x2F;&#x2F;ceil()向上取整，即前n-1组B的数量同，最后一组可能不同</span><br><span class="line">	if (countA &gt; despNum)	return min(countA + countB, countB + (despNum + 1) * maxA);</span><br><span class="line">	else return	countA + min(countB, (countA+1)*maxB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int countA, countB, maxA, maxB;</span><br><span class="line">	cin &gt;&gt; countA &gt;&gt; countB &gt;&gt; maxA &gt;&gt; maxB;</span><br><span class="line">	int len1 &#x3D; handler(countA, countB, maxA, maxB);</span><br><span class="line">	int len2 &#x3D; handler(countB, countA, maxB, maxA);</span><br><span class="line">	cout &lt;&lt; max(len1, len2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐<a name="1783"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1783 --Large is Better</span><br><span class="line">题目：给定一个数字，除了0，可以交换任意数量的相邻数字，不允许用数字0去交换任何数字。求经过交换所能得到的最大数字。</span><br></pre></td></tr></table></figure>
<p>没有太大难度，就是分割排序。不过用<strong>迭代器</strong>这个骚操作真得学起来了啊…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int testNum;</span><br><span class="line">	cin &gt;&gt; testNum;</span><br><span class="line">	while (testNum--) &#123;</span><br><span class="line">		string str1;</span><br><span class="line">		cin &gt;&gt; str1;</span><br><span class="line">		int length &#x3D; str1.size();</span><br><span class="line"></span><br><span class="line">		if (length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;进一步优化：用iterator去指向每个分割的部分</span><br><span class="line">		string::iterator iter1 &#x3D; str1.begin();</span><br><span class="line">		string::iterator iter2 &#x3D; iter1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; length; ++i) &#123;</span><br><span class="line">			if (*iter2 &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">				sort(iter1, iter2, greater&lt;&gt;());</span><br><span class="line">				iter1 &#x3D; iter2+1;</span><br><span class="line">			&#125;</span><br><span class="line">			++iter2;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(iter1, iter2, greater&lt;&gt;());</span><br><span class="line">		cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐<a name="8536"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 8536 --Happy Camper</span><br><span class="line">题目：设整数1&lt;L&lt;P&lt;V，在任何连续的P天时间里，露营地的占用限于L天。Harry Camper拥有V天的假期。请问假期期间，他最多可以露营地住多少天？</span><br></pre></td></tr></table></figure>
<p>不知道为什么这么简单的题目会被放进课件里…就是分割啦跟上上道题同源的思想然而比那个水好多…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int L, P, V;</span><br><span class="line">	int caseNum &#x3D; 1;</span><br><span class="line">	while (cin &gt;&gt; L &gt;&gt; P &gt;&gt; V) &#123;</span><br><span class="line">		if (!(L &amp;&amp; P &amp;&amp; V))	return 0;</span><br><span class="line"></span><br><span class="line">		int maxDays &#x3D; 0;</span><br><span class="line">		int despNum &#x3D; V &#x2F; P;</span><br><span class="line">		maxDays +&#x3D; L * despNum;</span><br><span class="line"></span><br><span class="line">		if (despNum * P &lt; V) &#123;</span><br><span class="line">			maxDays +&#x3D; min(L, V - despNum * P);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; caseNum &lt;&lt; &quot;: &quot; &lt;&lt; maxDays &lt;&lt; endl;</span><br><span class="line">		++caseNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐⭐<a name="6771"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 6771 --Class Packing</span><br><span class="line">题目：年级为0~6共七个年级的学生，给定每个年级的学生数量。现为这些学生分配班级，需要满足以下条件：</span><br><span class="line">   1：一个班级只能有一个年级或两个相邻年级的学生，例如，四年级和五年级学生的班级人数不得超过25。</span><br><span class="line">   2: 拥有年级0-2的学生的班级，其人数最多为20。</span><br><span class="line">   3: 拥有年级3-4的学生的班级，其人数最多为25。</span><br><span class="line">   4: 拥有年级5-6的学生的班级，其人数最多为30。</span><br><span class="line">求至少需要分配多少个班级。</span><br></pre></td></tr></table></figure>
<p>emmm…看提示之前是思绪是非常乱的…纠结于how to divide them…Fine其实正确思路再简单不过了：<strong>如果人数多的话，将他们尽量分配到同一个班的结果是理想的（因为如果分配到其他的班，可能会影响到高年级的班级的容量）；如果人数有剩下的话，就从其上一年级中调派人员过来，使得该班的容量填满。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int grade[7];</span><br><span class="line">	while (cin &gt;&gt; grade[0] &gt;&gt; grade[1] &gt;&gt; grade[2] &gt;&gt; grade[3] &gt;&gt; grade[4] &gt;&gt; grade[5] &gt;&gt; grade[6]) &#123;</span><br><span class="line">		bool flag &#x3D; true;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 7; ++i) &#123;</span><br><span class="line">			if (grade[i] !&#x3D; 0) &#123;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)	return 0;</span><br><span class="line"></span><br><span class="line">		int limits[7] &#x3D; &#123; 20, 20, 20, 25, 25, 30, 30 &#125;;</span><br><span class="line"></span><br><span class="line">		int num &#x3D; 0;</span><br><span class="line">		int left &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 7; ++i) &#123;</span><br><span class="line">			while (grade[i] &gt; 0) &#123;</span><br><span class="line">				if (left !&#x3D; 0 &amp;&amp; grade[i-1] &lt; 0) &#123;</span><br><span class="line">					grade[i] -&#x3D; left;</span><br><span class="line">					left &#x3D; 0;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				if (grade[i] &lt; limits[i]) &#123;</span><br><span class="line">					left &#x3D; limits[i] - grade[i];</span><br><span class="line">				&#125;</span><br><span class="line">				++num;</span><br><span class="line">				grade[i] -&#x3D; limits[i];			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🐣最后一点点想法：C++标准库函数真的很实用！</p>
<p>（未完待续）</p>
<p>附录：</p>
<p><a href="https://blog.csdn.net/qq_28351609/article/details/84630535" target="_blank" rel="noopener">STL之map用法详解</a><br><a href="https://blog.csdn.net/sodacoco/article/details/84798621" target="_blank" rel="noopener">STL之multiset用法总结</a><br><a href="http://c.biancheng.net/view/545.html" target="_blank" rel="noopener">Multiset用法详解</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心法（一）</title>
    <url>/2020/03/22/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>久仰大名。没想到这么折腾人。先上定义 ↓</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">贪心算法：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</span><br><span class="line"></span><br><span class="line">贪心法的特点：</span><br><span class="line">· 不是对所有问题都能得到整体最优解，关键是贪心策略的选择</span><br><span class="line">· 选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</span><br></pre></td></tr></table></figure>
<p><br/>听起来挺简单对吧，但最优解的策略是真不好找，而且往往需要证明（哪怕不太严谨但也应说服自己信任该策略）。下面给出一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1198 --Substring</span><br><span class="line">题目：给定n个字符串，将其拼接形成一个字典序最小的字符串（1&lt;&#x3D;n&lt;&#x3D;8）</span><br></pre></td></tr></table></figure>
<p><br/>那么，我们可以考虑以下几种方案：</p>
<ul>
<li>直接对所有字符串按字典序大小排序后进行拼接。<br/></li>
<li>暴力枚举所有组合的可能性，再遍历得到字典序最小的组合。<br/></li>
<li><strong>传说中的贪心法</strong></li>
</ul>
<p>第一种方案咋一看可行，那么考虑这样一个输入：b、ba；按该方案得到的输出是”bba”，但实际上”bab”才是最优解。所以，存在反例，我们可以否定第一种方案。</p>
<p>显然，暴力枚举是可以得到正确结果的，时间复杂度O(n<sup>2</sup>)，相对于我们将要讨论的贪心法，既费时又费力。（文末会附上暴力枚举方案的代码）。</p>
<p>那么，在这个题目中贪心法的策略是如何呢？</p>
<p>合理的做法是先对这n个字符串进行某种<b>排序</b>再拼接。这里的排序方式是指，对于两个字符串str1、str2，如果str1+str2 &lt; str2+str1，那么把str1放在str2的前面所得到的字符串就是字典序更小的那个。当每两个字符串之间都按照这个标准进行比较并排序后，最终串起来的结果就是正确答案。</p>
<p>该策略证明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">证题：若a &lt;&#x3D; b，b &lt;&#x3D; c，那么a &lt;&#x3D; c(已重载比较符)。</span><br><span class="line">证明：</span><br><span class="line">    由 a &lt;&#x3D; b 得 ab &lt;&#x3D; ba； </span><br><span class="line">    由 b &lt;&#x3D; c 得 bc &lt;&#x3D; cb；</span><br><span class="line">    易得 ac &lt;&#x3D; ca，推出a &lt;&#x3D; c。证毕。</span><br></pre></td></tr></table></figure>
<p><br/>证明完成，将上述思想转化为代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool cmp(string str1, string str2)&#123;</span><br><span class="line">	return str1+str2 &lt; str2+str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string subStr(int n, string str[])&#123;</span><br><span class="line">	string ret &#x3D; &quot;&quot;;</span><br><span class="line">	sort(str, str+n, cmp);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; ++i)&#123;</span><br><span class="line">		ret +&#x3D; str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题写得略长了，之后的题目就点到为止吧。</p>
<p>附录：</p>
<p><a href="https://blog.csdn.net/weixin_43864929/article/details/105039150" target="_blank" rel="noopener">求字典序最小的拼接字符串之暴力枚举法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>贪心法</tag>
      </tags>
  </entry>
</search>
