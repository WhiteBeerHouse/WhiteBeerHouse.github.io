<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的博客经营旅程</title>
    <url>/2020/03/21/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BB%8F%E8%90%A5%E6%97%85%E7%A8%8B/</url>
    <content><![CDATA[<p>庚子年清明，我把原来jekyll的博客迁到了hexo框架。</p>
<p>主题©<a href="https://jerryc.me/" target="_blank" rel="noopener">Butterfly</a>，目前只是根据配置文档做一些选择，尽量让界面清新简洁。</p>
<p>大佬们代码写得很好，得花一些时间研究一下配置文件，未来想再引进些什么。</p>
<p>未完待续…</p>
<hr>
]]></content>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-11 盛最多水的容器</title>
    <url>/2020/04/18/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line"></span><br><span class="line">注意：你不能倾斜容器，且 n 的值至少为 2。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>暴力的解法三两分钟写了出来，提交上去后超时了…超…时了…了…<br/>官方双指针思路：一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了1。这种情况下我们<strong>想要让指针移动后的容器体积增大，就要使移动后的容器的高尽量大</strong>，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会。<br/>🐣：（一开始我还觉得双指针还能咋用啊不就是跟暴力法一样控制个边而已吗打扰了原来有更进一步考虑（全个想无🙇‍♀️<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;O(n^2)</span><br><span class="line"></span><br><span class="line">int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len-1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; i+1; j &lt; len; ++j)&#123;</span><br><span class="line">            int sum &#x3D; (height[i] &lt; height[j] ? height[i]*(j-i) : height[j]*(j-i));</span><br><span class="line">            max &#x3D; max &gt; sum ? max : sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;O(n)</span><br><span class="line"></span><br><span class="line">int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; len-1;</span><br><span class="line">    while (left &lt; right)&#123;</span><br><span class="line">        int sum &#x3D; (height[left] &lt; height[right] ? height[left]*(right-left) : height[right]*(right-left));</span><br><span class="line">        max &#x3D; max &gt; sum ? max : sum;</span><br><span class="line">        if (height[left] &lt; height[right])   ++left;</span><br><span class="line">        else --right;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-877 石子游戏</title>
    <url>/2020/04/15/LeetCode-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</span><br><span class="line"></span><br><span class="line">游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</span><br><span class="line"></span><br><span class="line">亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</span><br><span class="line"></span><br><span class="line">假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">· 2 &lt;&#x3D; piles.length &lt;&#x3D; 500</span><br><span class="line">· 1 &lt;&#x3D; piles[i] &lt;&#x3D; 500</span><br><span class="line"> </span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</span><br><span class="line">如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>数学推<del>倒</del>导法</strong>：因为是偶数个堆，所以两个人最后拿到的堆数是一样的，但是因为石头的数量是奇数，所以最后两人拿到的石头数量肯定是一个多一个少，且和为奇数，所以先手的人只要选择多的那种方式拿就行了，所以先手必赢💪。<br/>想法二：<strong><del>标准</del>动态规划</strong>。跟<a href="https://whitebeerhouse.github.io/2020/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/#%F0%9F%93%9D%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">动态规划（一）</a>第一道例题算是同源，这里使用二维数组<strong>dp[i][j]表示从第i堆石子到第j堆石子先手和后手的最大分数差。</strong><br/>🐣：（靠…我是想做dp问题的怎么老遇上数学问题🙃<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;</span><br><span class="line">    &#x2F;&#x2F;dp[i][j]表示从i到j的最优分数差</span><br><span class="line"></span><br><span class="line">    int len &#x3D; piles.size();</span><br><span class="line">    int dp[len][len];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        dp[i][i] &#x3D; piles[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int length &#x3D; 1; length &lt;&#x3D; len-1; ++length)&#123;</span><br><span class="line">        for (int left &#x3D; 0; left &lt;&#x3D; len-length-1; ++left)&#123;</span><br><span class="line">            int right &#x3D; left + length;</span><br><span class="line">            dp[left][right] &#x3D; max(piles[left]-dp[left+1][right], piles[right]-dp[left][right-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[0][len-1] &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1277 统计全为1的正方形子矩阵</title>
    <url>/2020/04/15/LeetCode-1277-%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的正方形子矩阵的个数。</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">· 1 &lt;&#x3D; arr.length &lt;&#x3D; 300</span><br><span class="line">· 1 &lt;&#x3D; arr[0].length &lt;&#x3D; 300</span><br><span class="line">· 0 &lt;&#x3D; arr[i][j] &lt;&#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [0,1,1,1],</span><br><span class="line">  [1,1,1,1],</span><br><span class="line">  [0,1,1,1]</span><br><span class="line">]</span><br><span class="line">输出：15</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,0],</span><br><span class="line">  [1,1,0]</span><br><span class="line">]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>用 f[i][j] 表示以 (i, j) 为右下角的正方形的最大边长，那么除此定义之外，f[i][j] = x 也表示以 (i, j) 为右下角的正方形的数目为 x（即边长为 1, 2, …, x 的正方形各一个）。在计算出所有的 f[i][j] 后将它们进行累加，就可以得到矩阵中正方形的数目。<br/><br>不难得到 <strong>f[i][j] 的递推式：</strong><br/></p>
<ul>
<li>if i = 0 or j = 0 : f[i][j] = matrix[i][j];</li>
<li>if matrix[i][j] = 0 : f[i][j] = 0;</li>
<li>otherwise : f[i][j] = min(f[i-1][j], f[i][j-1], f[i-1][j-1]) + 1;<br><br/><br/></li>
</ul>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    int len1 &#x3D; matrix.size();</span><br><span class="line">    int len2 &#x3D; matrix[0].size();</span><br><span class="line">    int f[len1][len2];</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len2; ++j)&#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0)</span><br><span class="line">                f[i][j] &#x3D; matrix[i][j];</span><br><span class="line">            else &#123;</span><br><span class="line">                if (matrix[i][j])&#123;</span><br><span class="line">                    f[i][j] &#x3D; min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1])+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else    f[i][j] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            result +&#x3D; f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1025 除数博弈</title>
    <url>/2020/04/15/LeetCode-1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</span><br><span class="line"></span><br><span class="line">最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</span><br><span class="line"></span><br><span class="line">· 选出任一 x，满足 0 &lt; x &lt; N 且 N % x &#x3D;&#x3D; 0 。</span><br><span class="line">· 用 N - x 替换黑板上的数字 N 。</span><br><span class="line">· 如果玩家无法执行这些操作，就会输掉游戏。</span><br><span class="line"></span><br><span class="line">只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>👉震惊全场之“洋洋洒洒十来行，一看题解就一行”🤙🤙🤙<br/><strong>如果N是奇数，因为奇数的所有因数都是奇数，因此 N 进行一次 N-x 的操作结果一定是偶数，所以如果 a 拿到了一个奇数，那么轮到 b 的时候，b 拿到的肯定是偶数，这个时候 b 只要进行 -1， 还给 a 一个奇数，那么这样子 b 就会一直拿到偶数，到最后 b 一定会拿到最小偶数2，a 就输了。</strong><br/>所以如果游戏开始时Alice拿到N为奇数，那么她必输，也就是false。如果拿到N为偶数，她只用 -1，让Bob拿到奇数，最后Bob必输，结果就是true。<br/>🐣：（我不配（以及这个判断奇偶的方式也过于高效<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool divisorGame(int N) &#123;</span><br><span class="line">    return !(N&amp;1);</span><br><span class="line">    &#x2F;&#x2F;return (N % 2 &#x3D;&#x3D; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-2 两数相加</title>
    <url>/2020/04/15/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>原写法思路一样的，就是不够简洁，参考了评论区，这个三目运算符用得真是666啊！<br/>🐣：坐等一个困难版本的该题。<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">    ListNode* head &#x3D; new ListNode(0, nullptr);</span><br><span class="line">    ListNode* now &#x3D; head;</span><br><span class="line">    int carry &#x3D; 0, sum &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;ListNode *p &#x3D; l1, *q &#x3D; l2;&#x2F;&#x2F;最好是不破坏参数</span><br><span class="line">    while (l1 || l2 || carry)&#123;</span><br><span class="line">        sum &#x3D; (l1?l1-&gt;val:0) + (l2?l2-&gt;val:0) + carry;</span><br><span class="line">        carry &#x3D; sum &#x2F; 10;</span><br><span class="line">        sum %&#x3D; 10;</span><br><span class="line">        ListNode*temp &#x3D; new ListNode(sum, nullptr);</span><br><span class="line">        now-&gt;next &#x3D; temp;</span><br><span class="line">        now &#x3D; now-&gt;next;</span><br><span class="line">        l1 &#x3D; l1?l1-&gt;next:l1;</span><br><span class="line">        l2 &#x3D; l2?l2-&gt;next:l2;</span><br><span class="line">    &#125;</span><br><span class="line">    return head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-62 不同路径</title>
    <url>/2020/04/14/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角，每次只能向下或者向右移动一步，机器人试图达到网格的右下角，总共有多少条不同的路径？（1 &lt;&#x3D; m, n &lt;&#x3D; 100；题目数据保证答案小于等于 2 * 10^9）</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>很简单入门的动态规划。不过最初想用排列组合公式解答的，无奈计算过程溢出了🤷‍♀️。<br/>🐣：评论区有大佬说遇到其他使用排列组合会溢出的题目可以转化成这个题👍思路清奇啊👍👍<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    int f[m][n];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; ++j)&#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0)   f[i][j] &#x3D; 1;</span><br><span class="line">            else    f[i][j] &#x3D; f[i-1][j]+f[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5382 HTML 实体解析器</title>
    <url>/2020/04/12/LeetCode-5382-HTML-%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>由于题目和代码中的特殊字符都被博客转义了，所以这篇先暂存在CSDN上<a href="https://blog.csdn.net/weixin_43864929/article/details/105468685" target="_blank" rel="noopener">LeetCode-5382 HTML 实体解析器</a>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-102 二叉树的层序遍历</title>
    <url>/2020/04/11/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，请你返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>递归</strong>遍历。难点大概就是如何加入新的一层。<br/>想法二：<strong>BFS（广度优先搜索）</strong>。利用<a href="https://en.cppreference.com/w/cpp/container/queue" target="_blank" rel="noopener">队列</a>先进先出的特性逐层存储、读取和弹出子节点。<br/>🐣：都是上学期数据结构的内容，有点遗忘了…<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">void traverse(vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth, TreeNode* root)&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)   return;</span><br><span class="line">    if (depth &gt;&#x3D; result.size())</span><br><span class="line">        result.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">    result[depth].push_back(root-&gt;val);</span><br><span class="line">    traverse(result, depth+1, root-&gt;left);</span><br><span class="line">    traverse(result, depth+1, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    traverse(result, 0, root);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    if (root !&#x3D; NULL)</span><br><span class="line">        q.push(root);</span><br><span class="line">    </span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int count &#x3D; q.size();</span><br><span class="line">        vector&lt;int&gt; layer;</span><br><span class="line">        while(count &gt; 0)&#123;</span><br><span class="line">            TreeNode* tmp &#x3D; q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            layer.push_back(tmp-&gt;val);</span><br><span class="line">            if (tmp-&gt;left !&#x3D; NULL)  q.push(tmp-&gt;left);</span><br><span class="line">            if (tmp-&gt;right !&#x3D; NULL)  q.push(tmp-&gt;right);</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(layer);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1419 旋转矩阵</title>
    <url>/2020/04/11/LeetCode-1419-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。（不占用额外空间能否做到？）</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：按照数学规律直接改变相应位置的值，需要额外拷贝一个副本作为数据来源。<br/>想法二：<strong>不占用额外空间，</strong> 先将矩阵以对角线为轴翻转再左右对称翻转。<br/>🐣：不考虑性能的话简直就一水题，强制缩减时空复杂度的话，倒真不容易想到这个翻转法…<br/><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; c_matrix &#x3D; matrix;</span><br><span class="line">    int len &#x3D; matrix.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len; ++j)&#123;</span><br><span class="line">            matrix[i][j] &#x3D; c_matrix[len-1-j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    int len &#x3D; matrix.size();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;以对角线为轴翻转 </span><br><span class="line">    for (int i &#x3D; 0; i &lt; len-1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; i+1; j &lt; len; ++j)&#123;</span><br><span class="line">            int temp &#x3D; matrix[i][j];</span><br><span class="line">            matrix[i][j] &#x3D; matrix[j][i];</span><br><span class="line">            matrix[j][i] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;左右对称翻转</span><br><span class="line">    for (int j &#x3D; 0; j &lt; len&#x2F;2; ++j)&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">            int temp &#x3D; matrix[i][j];</span><br><span class="line">            matrix[i][j] &#x3D; matrix[i][len-1-j];</span><br><span class="line">            matrix[i][len-1-j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-151 翻转字符串里的单词</title>
    <url>/2020/04/10/LeetCode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>毫不费力的思路：分割出单词-&gt;反向拼接<br/>可以用很多方式完成。Java支持库函数split()可以直接以空格为分隔符拆解，trim()筛掉前后空格，几行代码搞定；C++选手可以用stringstream或者手动实现分割拼接，据说此题的出题目的是考察双指针操作字符数组…<br/>我用的正则表达式辅助实现分割，vector容器实现反向拼接…总之题目不是很难，但是手动实现时难免踩到很多坑🤦‍♀️<br/><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/" target="_blank" rel="noopener">官方思路和题解请戳此😃</a><br><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string reverseWords(string s) &#123;</span><br><span class="line">    vector&lt;string&gt; words;</span><br><span class="line">    int len &#x3D; s.size();</span><br><span class="line">    string tmp &#x3D; &quot;&quot;;</span><br><span class="line">    regex reg(&quot;[ ]*&quot;);&#x2F;&#x2F;空或纯空格时为真</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (regex_match(tmp, reg))	tmp &#x3D; &quot;&quot;;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; !regex_match(tmp, reg))&#123;</span><br><span class="line">            words.push_back(tmp);</span><br><span class="line">            tmp &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            tmp +&#x3D; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!regex_match(tmp, reg))	words.push_back(tmp);</span><br><span class="line"></span><br><span class="line">    int len2 &#x3D; words.size();</span><br><span class="line">    if (len2 &#x3D;&#x3D; 0) return &quot;&quot;;&#x2F;&#x2F;题目没有讲但是输入为全空格时输出为空，这里容易被坑</span><br><span class="line">    string temp &#x3D; &quot;&quot;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len2-1; ++i)&#123;</span><br><span class="line">        temp +&#x3D; words.back();</span><br><span class="line">        temp +&#x3D; &quot; &quot;;</span><br><span class="line">        words.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    temp +&#x3D; words.back();</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划（二）</title>
    <url>/2020/04/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><a href="#1121">soj 1121 –Tri Tiling</a><br><a href="#1527">soj 1527 –Tiling a Grid With Dominoes</a><br><a href="#1828">soj 1828 –Minimal</a></p>
<hr>
<p>⭐⭐⭐⭐<a name="1121"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1121 --Tri Tiling</span><br><span class="line">题目：用1*2的长方形铺满3*n的长方形，有多少种方法？（如下图）</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.9/image/1121-0.png"  alt=""><br/><br>初始状态，n=2时，可以平铺出矩形（3种情况）和非矩形（2种情况），如下图所示。<br/><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1121-1.png"  alt=""><br/><br/><br><strong>题解一</strong>：用f[i]表示铺满3 * (2i)的长方形的方案数，用g[i]表示铺满3 * (2i)的长方形，并且向后伸展出部分形状的方案数。则有：</p>
<ul>
<li>f[i]=3 * f[i-1]+g[i-1]</li>
</ul>
<p>3 * f[i-1]即在f[i-1]的基础上要加上恰好的3 * 2矩形才能构成f[i]，而3 * 2矩形有3种情况（如上图）；g[i-1]即对于每一种非矩形都只有一种方式可以填补其使之恰为矩形。</p>
<ul>
<li>g[i]=2 * f[i-1]+g[i-1]</li>
</ul>
<p>2 * f[i-1]即在f[i-1]的基础上要加上2种非矩形之一才能构成g[i]；g[i-1]即对于每一种非矩形都只有一种方式可以填补其使之恰为非矩形。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 32;</span><br><span class="line">int f[maxn], g[maxn];</span><br><span class="line"></span><br><span class="line">int dp(int n) &#123;</span><br><span class="line">	if (n % 2 &#x3D;&#x3D; 1)	return 0;</span><br><span class="line">	if (n &#x3D;&#x3D; 0)	return f[0] &#x3D; 1;</span><br><span class="line">	f[1] &#x3D; 3;</span><br><span class="line">	g[1] &#x3D; 2;</span><br><span class="line">	int tmp &#x3D; n &#x2F; 2;</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; tmp; ++i) &#123;</span><br><span class="line">		f[i]&#x3D;3*f[i-1]+g[i-1];</span><br><span class="line">		g[i]&#x3D;2*f[i-1]+g[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	return f[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin &gt;&gt; n &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">		cout &lt;&lt; dp(n) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>

<p><strong>题解二：数学规律推算法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要使3*n是一个矩形，有两种可能:</span><br><span class="line">    1. 3*(n-2)也是一个矩形，那么只要再拼上一个3*2的就可以了。这个3*2有3种情况,所以是3*f(n-2);</span><br><span class="line"></span><br><span class="line">    2. 3*(n-2)不是一个矩形，这种情况下，你只有一种添加2*1块的方法使得3*n是矩形，还需要对3*(n-4)的形状做判断：</span><br><span class="line"></span><br><span class="line">        1. 3*(n-4)是一个矩形，那么只要再拼一个L形或者倒L形就可以使得3*(n-2)不是矩形了，这里就是2*f(n-4);</span><br><span class="line"></span><br><span class="line">        2. 3*(n-4)不是一个矩形，那么也是只有一种添加2*1块的方法能使3*(n-2)不是矩形，接下来就来考虑3*(n-6)：</span><br><span class="line"></span><br><span class="line">             1. 3*(n-6)是一个矩形，那么只要再拼一个L形或者倒L形就可以使得3*(n-4)不是矩形了，这里就是2*f(n-6);</span><br><span class="line"></span><br><span class="line">             2. 3*(n-6)不是一个矩形，……</span><br></pre></td></tr></table></figure>
<p>综上，可以得到递推式：<strong>f(n) = 3 * f(n-2) + 2 * f(n-4) + 2 * f(n-6) + … + 2 * f(0)</strong>，其中初始值<strong>f(0)=1</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 30;</span><br><span class="line">int f[maxn] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int dp(int n) &#123;</span><br><span class="line">	if (n % 2 &#x3D;&#x3D; 1)	return 0;</span><br><span class="line">	if (n &#x3D;&#x3D; 0)	return f[0] &#x3D; 1;</span><br><span class="line">	if (n &#x3D;&#x3D; 2)	return f[2] &#x3D; 3;</span><br><span class="line">	if (f[n] !&#x3D; 0)	return f[n];</span><br><span class="line">	f[n] +&#x3D; 3 * dp(n - 2);</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; n&#x2F;2; ++i) &#123;</span><br><span class="line">		f[n] +&#x3D; 2 * dp(n - 2 * i);</span><br><span class="line">	&#125;</span><br><span class="line">	return f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin &gt;&gt; n &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">		cout &lt;&lt; dp(n) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐⭐⭐<a name="1527"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1527 --Tiling a Grid With Dominoes</span><br><span class="line">题目：用1*2的长方形铺满4*n的长方形，有多少种方法？（如下图）</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1527-0.png"  alt=""><br/><br>处理方式与上题有些相似，但思路有所不同：<strong>用f[i][j]表示前4 * i列已经完全填满，并且第(i+1)列情况为第j种形状的方案数。</strong>其中，共有5种形状，分别是：<br/><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1527-1.jpg"  alt=""><br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1001;</span><br><span class="line">int f[maxn][5];</span><br><span class="line"></span><br><span class="line">int dp(int N) &#123;</span><br><span class="line">	f[0][0] &#x3D; f[1][0] &#x3D; f[1][1] &#x3D; f[1][3] &#x3D; f[1][4] &#x3D; 1;</span><br><span class="line">	f[1][2] &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">		f[i][0] &#x3D; f[i-2][0]+f[i-1][0]+f[i-1][1]+f[i-1][3]+f[i-1][4];</span><br><span class="line">		f[i][1] &#x3D; f[i-1][0]+f[i-1][4];</span><br><span class="line">		f[i][2] &#x3D; f[i-1][3];</span><br><span class="line">		f[i][3] &#x3D; f[i-1][0]+f[i-1][2];</span><br><span class="line">		f[i][4] &#x3D; f[i-1][0]+f[i-1][1];</span><br><span class="line">	&#125;</span><br><span class="line">	return f[N][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int cases;</span><br><span class="line">	cin &gt;&gt; cases;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; cases; ++i) &#123;</span><br><span class="line">		int N;</span><br><span class="line">		cin &gt;&gt; N;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dp(N) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐<a name="1828"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1828 --Minimal</span><br><span class="line">题目：There are two sets S1 and S2 subjecting to:</span><br><span class="line">(1) S1, S2 are both the subsets of &#123;x| x is an integer and 0 &lt; x &lt; 1,000,000&#125;</span><br><span class="line">(2) 0 &lt; |S1| &lt; |S2| &lt; 500</span><br><span class="line"> </span><br><span class="line">F(S1, S2) &#x3D; min &#123;|a1-b1| + |a2-b2| + … + |aN-bN|&#125; in which ai ∈S1, bi ∈S2, ai ≠aj if i≠j, bi ≠bj if i≠j (i, j &#x3D; 1, 2 … N，N &#x3D; |S1|)</span><br><span class="line"></span><br><span class="line">For each test case, print the result of F(S1 ,S2).</span><br></pre></td></tr></table></figure>
<p>最开始我的想法是，将S1和S2作笛卡尔积（定义X为两数差距），在一个二维数组里记录两两之差的绝对值，对S1每个元素都匹配以S2某个元素使得差距尽可能小。<strong>尝试了几个测例都过了，但是OJ上面WA了，这个解法个人觉得也有些牵强，无法证明，但又无法证伪😭。</strong><br/><br><font color='gray'>&lt; 以下解释参考相关资料信息 &gt;</font><br/><br>假设我们从S2中选择了某些数，假设选出的数组成S3，那么S3中最小的数肯定匹配S1中最小的数，S3中次小的数匹配S1中次小的数…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">证明：</span><br><span class="line">假设S1中有了a1,a2,S3中有b1,b2</span><br><span class="line">且a1&lt;&#x3D;a2,b1&lt;&#x3D;b2</span><br><span class="line">那么有|a1-b1|+|a2-b2|&lt;&#x3D;|a1-b2|+|a2-b1|（数学问题）</span><br><span class="line">所以从小到大一个个匹配不会更差，只会更好。</span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong><br>对S1和S2分别从小到大排序，用f[i][j]表示S1中的前i个数，与S2中的前j个数匹配（从j个数选i个数出来），显然有：<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i][j] &#x3D; inf(j &lt; i)</span><br><span class="line">f[0][0] &#x3D; 0</span><br><span class="line">f[i][j] &#x3D; min&#123;f[i-1][j-1]+|a[i]-b[j]|,f[i][j-1]&#125;,j&gt;&#x3D;i</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define inf 1&lt;&lt;30</span><br><span class="line">const int maxn &#x3D; 501;</span><br><span class="line">int f[maxn][maxn];</span><br><span class="line">int S1[maxn], S2[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int cases;</span><br><span class="line">	cin &gt;&gt; cases;</span><br><span class="line">	while (cases--) &#123;</span><br><span class="line">		int N, M;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">			cin &gt;&gt; S1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; M; ++i) &#123;</span><br><span class="line">			cin &gt;&gt; S2[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort(S1+1, S1+N+1);</span><br><span class="line">		sort(S2+1, S2+M+1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; M; ++j) &#123;</span><br><span class="line">				if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)</span><br><span class="line">					f[i][j] &#x3D; 0;</span><br><span class="line">				else if (i &gt; j) &#123;</span><br><span class="line">					f[i][j] &#x3D; inf;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					f[i][j] &#x3D; inf;</span><br><span class="line">					if (i &gt; 0)</span><br><span class="line">						f[i][j] &#x3D; min(f[i][j], f[i-1][j-1]+abs(S1[i]-S2[j]));</span><br><span class="line">					if (j &gt; 0)</span><br><span class="line">						f[i][j] &#x3D; min(f[i][j], f[i][j-1]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; f[N][M] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（未完待续）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-329 判断子序列</title>
    <url>/2020/04/08/LeetCode-329-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</span><br><span class="line">你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。</span><br><span class="line">字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 true.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 false.</span><br></pre></td></tr></table></figure>
<br/>

<h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>注意，字符串t可能很长，所以不适合用下标去标记和遍历（大概率会溢出）。<br/>使用<strong>双指针</strong>方式进行遍历，判断方式以<strong>字符串s是否遍历完</strong>为标准。<br><br/></p>
<h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isSubsequence(string s, string t) &#123;</span><br><span class="line">    char* spt &#x3D; &amp;s[0];</span><br><span class="line">    char* tpt &#x3D; &amp;t[0];</span><br><span class="line">    while(*spt &amp;&amp; *tpt)&#123;</span><br><span class="line">        if (*spt &#x3D;&#x3D; *tpt)   spt++;</span><br><span class="line">        tpt++;</span><br><span class="line">    &#125;</span><br><span class="line">    return (*spt &#x3D;&#x3D; &#39;\0&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划（一）</title>
    <url>/2020/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="📝算法介绍"><a href="#📝算法介绍" class="headerlink" title="📝算法介绍"></a><strong>📝算法介绍</strong></h2><p><strong>动态规划</strong>（Dynamic programming）常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br/><br>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于<strong>优化递归问题</strong>，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。<br/><br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<strong>记忆化存储</strong>，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。<br/></p>
<hr>
<h2 id="👉一个例题"><a href="#👉一个例题" class="headerlink" title="👉一个例题"></a><strong>👉一个例题</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1176 --Two Ends</span><br><span class="line">题目：给一个长度为n的数列ai，两个人在上面做交替取数，每个人的每一轮从这个数列的两端中取出一个数（不能不操作）。先手可以自由选择策略，后手选择贪心策略。贪心策略是指，如果两端数大小不同，选择大的那个；如果相同选择左边那个。问最后先手能赢后手多少分。(1&lt;&#x3D;n&lt;&#x3D;1000且n为偶数)</span><br></pre></td></tr></table></figure>
<p>我们定义一个二维数组values储存所有的解的情况，定义一维数组num储存数字序列；然后定义动态规划函数dp(int left, int right)，其中left, right分别表示左右边界的牌，玩家每一次选择都有两种情况：选择最左边的牌或最右边的牌。故每一次动态规划都有两种方案：<br/></p>
<ul>
<li>第一种，先手选择最左边的牌a，那么后手就会进行贪心算法选择剩下的左右边界中最大的那张牌，如果最左边大，则后手取走牌left+1，下一次dp序列为left+2到right；如果最右边大，则后手取走牌right，下一次dp序列为left+1到right-1；<br/></li>
<li>第二种，先手选择最右边的牌right，那么后手就会进行贪心算法选择剩下的左右边界中最大的那张牌，如果最左边大，则后手取走牌left，下一次dp序列为left+1到right-1；如果最右边大，则后手取走牌right-1，下一次dp序列为left到right-2；<br/></li>
</ul>
<p>每一次dp都对上述两种方案进行比较，选择先手分值比较高的方案对values[left][right]进行赋值，最终找出最好的方案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000;</span><br><span class="line">int num[maxn];</span><br><span class="line">int values[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int dp(int left, int right) &#123;&#x2F;&#x2F;参数都是index</span><br><span class="line">	if (left &gt; right)	return 0;</span><br><span class="line">	if (values[left][right] !&#x3D; -1)	return values[left][right];</span><br><span class="line">	values[left][right] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	values[left][right] &#x3D; max(values[left][right], num[left+1] &gt;&#x3D; num[right] ? num[left]+dp(left+2,right) : num[left]+dp(left+1,right-1));&#x2F;&#x2F;先手拿了左边</span><br><span class="line">	values[left][right] &#x3D; max(values[left][right], num[left] &gt;&#x3D; num[right-1] ? num[right]+dp(left+1,right-1) : num[right]+dp(left,right-2));&#x2F;&#x2F;先手拿了右边</span><br><span class="line">	return values[left][right];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int count &#x3D; 0;</span><br><span class="line">	while (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">		count++;</span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">			cin &gt;&gt; num[i];</span><br><span class="line">			sum +&#x3D; num[i];</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n; ++j) &#123;</span><br><span class="line">				values[i][j] &#x3D; -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;In game &quot; &lt;&lt; count &lt;&lt; &quot;, the greedy strategy might lose by as many as &quot; &lt;&lt; 2*dp(0, n - 1)-sum &lt;&lt; &quot; points.&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="👉另一个例题"><a href="#👉另一个例题" class="headerlink" title="👉另一个例题"></a><strong>👉另一个例题</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1011 --Lenny&#39;s Lucky Lotto</span><br><span class="line">题目：给定N，M，问有多少个长度为N的整数序列，满足所有数都在[1,M]内，并且后一个数都至少是前一个数的两倍。</span><br></pre></td></tr></table></figure>
<p>用f[i][j]表示长度为i，最大数为j的序列的数目；用s[i][j]表示长度为i，最大数不超过j的序列的数目，那么可以推出：s[i][j]=s[i][j-1]+f[i][j]、f[i][j]=s[i-1][j/2]。<br/><br>在这组递推式中我们进行了<strong>记忆存储</strong>，长度每增加1，利用已记录的原长度的相关数据简单计算得到新长度的数据并记录，<strong>自底向上</strong>递推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long long dp(int n, int m) &#123;</span><br><span class="line">	long long s[11][2001] &#x3D; &#123;0&#125;;</span><br><span class="line">	long long f[11][2001] &#x3D; &#123;0&#125;;</span><br><span class="line">	for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">		f[1][j] &#x3D; 1;</span><br><span class="line">		s[1][j] &#x3D; j;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">		f[i][0] &#x3D; s[i][0] &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">			f[i][j] &#x3D; s[i-1][j&#x2F;2];</span><br><span class="line">			s[i][j] &#x3D; s[i][j-1] + f[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return s[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❗ Sicily的题设中意于很大的数，所以写的时候注意看看需不需要把int改成long long（没错我就时常因为这个问题WA）。<br><br/></p>
<hr>
<h2 id="📝小结"><a href="#📝小结" class="headerlink" title="📝小结"></a><strong>📝小结</strong></h2><p>可见，上述例题最主要的共同点：<strong>记忆存储</strong>，即建立二维数组-&gt;代入参数-&gt;逐层递推的过程。这是动态规划问题最常见的套路之一。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心法（二）</title>
    <url>/2020/03/28/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><a href="#1035">soj 1035 –DNA matching</a><br><a href="#1681">soj 1681 –Matchsticks</a><br><a href="#1620">soj 1620 –SCVs and minerals</a><br><a href="#2503">soj 2503 –最长字符串</a><br><a href="#1783">soj 1783 –Large is Better</a><br><a href="#8536">soj 8536 –Happy Camper</a><br><a href="#6771">soj 6771 –Class Packing</a></p>
<hr>
<p>⭐⭐⭐<a name="1035"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1035 --DNA matching</span><br><span class="line">题目：给定n个DNA单链，问最多能组成多少对DNA双链，每一个DNA单链只能使用一次，且不可翻转。两个DNA单链能够形成一对DNA双链的条件是对应位置A&#x2F;T，C&#x2F;G配对。（1&lt;&#x3D;n&lt;&#x3D;100）</span><br></pre></td></tr></table></figure>
<p>第一段乍一看有点不大好处理，其实可以利用数组来解决对应位配对的情况！而对于整体的求解，类似于遍历去找配对的一对对，只不过这里是读入数据时便确定了配对情况：与集合里已有的DNA若可配对则计数+1，否则将读入的DNA装进待配对集合里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">int matching(int n)&#123;</span><br><span class="line">	static char match_str[127];</span><br><span class="line">	match_str[&#39;A&#39;] &#x3D; &#39;T&#39;;</span><br><span class="line">	match_str[&#39;T&#39;] &#x3D; &#39;A&#39;;</span><br><span class="line">	match_str[&#39;G&#39;] &#x3D; &#39;C&#39;;</span><br><span class="line">	match_str[&#39;C&#39;] &#x3D; &#39;G&#39;;</span><br><span class="line">	</span><br><span class="line">	int matchNum &#x3D; 0;</span><br><span class="line">	multiset&lt;string&gt; S;</span><br><span class="line">	string str, matchedStr;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; ++i)&#123;&#x2F;&#x2F; n条DNA</span><br><span class="line">		cin &gt;&gt; str;</span><br><span class="line">		matchedStr &#x3D; &quot;&quot;;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; str.size(); ++j)&#123;</span><br><span class="line">			matchedStr +&#x3D; match_str[str[j]];</span><br><span class="line">		&#125;</span><br><span class="line">		if (S.count(matchedStr))&#123;</span><br><span class="line">			++ matchNum;</span><br><span class="line">			S.erase(S.lower_bound(matchedStr));</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			S.insert(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return matchNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐<a name="1681"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1681 --Matchsticks</span><br><span class="line">题目：如下图所示，给定n根火柴，求其可以摆出的最小的数和最大的数（2&lt;&#x3D;n&lt;&#x3D;100）</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.3/image/1681.jpg"  alt=""><br/><br>显然，由于数字1只需要2根火柴以及数字7只需要3根火柴，最大的数必然全为1（偶数根火柴）或打7开头后全为1（奇数根火柴）。<br/><br>而对于最小的数，先枚举火柴数少的情况，再通过递归对火柴数更多的情况进行选择。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string minNum(int matchsticks)&#123;&#x2F;&#x2F;不喜用switch-case语句</span><br><span class="line">	if (matchsticks &#x3D;&#x3D; 2)	return &quot;1&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 3)	return &quot;7&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 4)	return &quot;4&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 5)	return &quot;2&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 6)	return &quot;6&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 7)	return &quot;8&quot;;	</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 8) 	return &quot;10&quot;;</span><br><span class="line">	else if (matchsticks &#x3D;&#x3D; 10) 	return &quot;22&quot;;</span><br><span class="line">	else &#123;</span><br><span class="line">		string min1&#x3D; minNum(matchsticks - 7) + &quot;8&quot;;</span><br><span class="line">		string min2 &#x3D; minNum(matchsticks - 6) + &quot;0&quot;;</span><br><span class="line">		if (min1.size() &lt; min2.size() || min1 &lt; min2)	return min1;</span><br><span class="line">		else return min2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string maxNum(int matchsticks)&#123;</span><br><span class="line">	string tmp &#x3D; &quot;&quot;;</span><br><span class="line">	if (matchsticks % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; matchsticks&#x2F;2; ++i) &#123;</span><br><span class="line">			tmp +&#x3D; &quot;1&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		tmp &#x3D; &quot;7&quot;;</span><br><span class="line">		matchsticks -&#x3D; 3;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; matchsticks &#x2F; 2; ++i) &#123;</span><br><span class="line">			tmp +&#x3D; &quot;1&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此题有两个坑：<strong>1.</strong> 题目要求”no leading zeroes”，这里也包括了一位数的情况，即给定6根火柴棒时最小数不取0。<br><strong>2.</strong> 虽然火柴数为9的情况可以由递归解决但为10时不可，所以也需另外给出。</p>
<hr>
<p>⭐⭐⭐⭐<a name="1620"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1620 --SCVs and minerals</span><br><span class="line">题目：游戏“ StarCraft”设定为，最初您有N个SCV和M个mineral。每个SCV可以在一秒钟内获得C个mineral，而指挥中心可以立即用P个mineral生产1个SCV。求在S秒后可获得的最多的mineral数量。</span><br></pre></td></tr></table></figure>
<p>最开始的想法就是递归调用，想在每一步都得到最多的mineral。样例输出很快否定了这个方法，仔细一想才发现，这个问题可以转换成我们熟悉的场景——生意买卖，只要作为生产设备的SCV能够在剩下的时间内产出不少于成本价P的mineral，那么赚得的肯定就最多了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int testNum &#x3D; 0;</span><br><span class="line">	cin &gt;&gt; testNum;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; testNum; ++i) &#123;</span><br><span class="line">		int N, M, C, P, S;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M &gt;&gt; C &gt;&gt; P &gt;&gt; S;	</span><br><span class="line">		for (int j &#x3D; 0; j &lt; S; ++j) &#123;</span><br><span class="line">			if ((S - j) * C &gt;&#x3D; P) &#123;&#x2F;&#x2F;P是获得一个SCV的成本，(S-j)*C是该SCV能带来的收入</span><br><span class="line">				N +&#x3D; M &#x2F; P;</span><br><span class="line">				M %&#x3D; P;</span><br><span class="line">			&#125;</span><br><span class="line">			M +&#x3D; N * C;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; M &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐⭐<a name="2503"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 2503 --最长字符串</span><br><span class="line">题目：要求你构造一个由字符&#39;A&#39;,&#39;B&#39;组成的字符串, 满足以下几个条件:</span><br><span class="line">1) A的个数&lt;&#x3D;countA</span><br><span class="line">2) B的个数&lt;&#x3D;countB</span><br><span class="line">3) 连续的A的个数不可以超过maxA.</span><br><span class="line">4) 连续的B的个数不可以超过maxB.</span><br><span class="line">5) 这个字符串的长度最长.</span><br><span class="line">给定countA, countB, maxA, maxB, 求输出字符串的最大长度。</span><br></pre></td></tr></table></figure>
<p>不知道是不是被算法名字所束缚了，总想着在每一步都积累最多的’A’或’B’以求整体最大，这个想法最大的漏洞在于：两者的数量差可能是<strong>悬殊</strong>的，这个时候尽可能更多地分组才是最优解。<br/><br/><br>此题解法：将A或B作为基准，另外一个进行分组作为分隔符。如果非分隔符多于分组数量，尽可能填满分隔符之间的空隙；若分组数量多于非分隔符，则尽可能填充更多的空隙。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int handler(int countA, int countB, int maxA, int maxB) &#123;&#x2F;&#x2F;以A为基准，以B为分隔符</span><br><span class="line">	if (maxA &#x3D;&#x3D; 0)	return min(maxB, countB);</span><br><span class="line">	if (maxB &#x3D;&#x3D; 0)	return min(maxA, countA);</span><br><span class="line"></span><br><span class="line">	int despNum &#x3D; ceil(countB &#x2F; maxB);&#x2F;&#x2F;ceil()向上取整，即前n-1组B的数量同，最后一组可能不同</span><br><span class="line">	if (countA &gt; despNum)	return min(countA + countB, countB + (despNum + 1) * maxA);</span><br><span class="line">	else return	countA + min(countB, (countA+1)*maxB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int countA, countB, maxA, maxB;</span><br><span class="line">	cin &gt;&gt; countA &gt;&gt; countB &gt;&gt; maxA &gt;&gt; maxB;</span><br><span class="line">	int len1 &#x3D; handler(countA, countB, maxA, maxB);</span><br><span class="line">	int len2 &#x3D; handler(countB, countA, maxB, maxA);</span><br><span class="line">	cout &lt;&lt; max(len1, len2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐<a name="1783"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1783 --Large is Better</span><br><span class="line">题目：给定一个数字，除了0，可以交换任意数量的相邻数字，不允许用数字0去交换任何数字。求经过交换所能得到的最大数字。</span><br></pre></td></tr></table></figure>
<p>没有太大难度，就是分割排序。不过用<strong>迭代器</strong>这个骚操作真得学起来了啊…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int testNum;</span><br><span class="line">	cin &gt;&gt; testNum;</span><br><span class="line">	while (testNum--) &#123;</span><br><span class="line">		string str1;</span><br><span class="line">		cin &gt;&gt; str1;</span><br><span class="line">		int length &#x3D; str1.size();</span><br><span class="line"></span><br><span class="line">		if (length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;进一步优化：用iterator去指向每个分割的部分</span><br><span class="line">		string::iterator iter1 &#x3D; str1.begin();</span><br><span class="line">		string::iterator iter2 &#x3D; iter1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; length; ++i) &#123;</span><br><span class="line">			if (*iter2 &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">				sort(iter1, iter2, greater&lt;&gt;());</span><br><span class="line">				iter1 &#x3D; iter2+1;</span><br><span class="line">			&#125;</span><br><span class="line">			++iter2;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(iter1, iter2, greater&lt;&gt;());</span><br><span class="line">		cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐<a name="8536"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 8536 --Happy Camper</span><br><span class="line">题目：设整数1&lt;L&lt;P&lt;V，在任何连续的P天时间里，露营地的占用限于L天。Harry Camper拥有V天的假期。请问假期期间，他最多可以露营地住多少天？</span><br></pre></td></tr></table></figure>
<p>不知道为什么这么简单的题目会被放进课件里…就是分割啦跟上上道题同源的思想然而比那个水好多…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int L, P, V;</span><br><span class="line">	int caseNum &#x3D; 1;</span><br><span class="line">	while (cin &gt;&gt; L &gt;&gt; P &gt;&gt; V) &#123;</span><br><span class="line">		if (!(L &amp;&amp; P &amp;&amp; V))	return 0;</span><br><span class="line"></span><br><span class="line">		int maxDays &#x3D; 0;</span><br><span class="line">		int despNum &#x3D; V &#x2F; P;</span><br><span class="line">		maxDays +&#x3D; L * despNum;</span><br><span class="line"></span><br><span class="line">		if (despNum * P &lt; V) &#123;</span><br><span class="line">			maxDays +&#x3D; min(L, V - despNum * P);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; caseNum &lt;&lt; &quot;: &quot; &lt;&lt; maxDays &lt;&lt; endl;</span><br><span class="line">		++caseNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐⭐<a name="6771"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 6771 --Class Packing</span><br><span class="line">题目：年级为0~6共七个年级的学生，给定每个年级的学生数量。现为这些学生分配班级，需要满足以下条件：</span><br><span class="line">   1：一个班级只能有一个年级或两个相邻年级的学生，例如，四年级和五年级学生的班级人数不得超过25。</span><br><span class="line">   2: 拥有年级0-2的学生的班级，其人数最多为20。</span><br><span class="line">   3: 拥有年级3-4的学生的班级，其人数最多为25。</span><br><span class="line">   4: 拥有年级5-6的学生的班级，其人数最多为30。</span><br><span class="line">求至少需要分配多少个班级。</span><br></pre></td></tr></table></figure>
<p>emmm…看提示之前是思绪是非常乱的…纠结于how to divide them…Fine其实正确思路再简单不过了：<strong>如果人数多的话，将他们尽量分配到同一个班的结果是理想的（因为如果分配到其他的班，可能会影响到高年级的班级的容量）；如果人数有剩下的话，就从其上一年级中调派人员过来，使得该班的容量填满。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int grade[7];</span><br><span class="line">	while (cin &gt;&gt; grade[0] &gt;&gt; grade[1] &gt;&gt; grade[2] &gt;&gt; grade[3] &gt;&gt; grade[4] &gt;&gt; grade[5] &gt;&gt; grade[6]) &#123;</span><br><span class="line">		bool flag &#x3D; true;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 7; ++i) &#123;</span><br><span class="line">			if (grade[i] !&#x3D; 0) &#123;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)	return 0;</span><br><span class="line"></span><br><span class="line">		int limits[7] &#x3D; &#123; 20, 20, 20, 25, 25, 30, 30 &#125;;</span><br><span class="line"></span><br><span class="line">		int num &#x3D; 0;</span><br><span class="line">		int left &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 7; ++i) &#123;</span><br><span class="line">			while (grade[i] &gt; 0) &#123;</span><br><span class="line">				if (left !&#x3D; 0 &amp;&amp; grade[i-1] &lt; 0) &#123;</span><br><span class="line">					grade[i] -&#x3D; left;</span><br><span class="line">					left &#x3D; 0;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				if (grade[i] &lt; limits[i]) &#123;</span><br><span class="line">					left &#x3D; limits[i] - grade[i];</span><br><span class="line">				&#125;</span><br><span class="line">				++num;</span><br><span class="line">				grade[i] -&#x3D; limits[i];			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🐣最后一点点想法：C++标准库函数真的很实用！</p>
<p>（未完待续）</p>
<p>附录：</p>
<p><a href="https://blog.csdn.net/qq_28351609/article/details/84630535" target="_blank" rel="noopener">STL之map用法详解</a><br><a href="https://blog.csdn.net/sodacoco/article/details/84798621" target="_blank" rel="noopener">STL之multiset用法总结</a><br><a href="http://c.biancheng.net/view/545.html" target="_blank" rel="noopener">Multiset用法详解</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>贪心法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心法（一）</title>
    <url>/2020/03/22/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>久仰大名。没想到这么折腾人。先上定义 ↓</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">贪心算法：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</span><br><span class="line"></span><br><span class="line">贪心法的特点：</span><br><span class="line">· 不是对所有问题都能得到整体最优解，关键是贪心策略的选择</span><br><span class="line">· 选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</span><br></pre></td></tr></table></figure>
<p><br/>听起来挺简单对吧，但最优解的策略是真不好找，而且往往需要证明（哪怕不太严谨但也应说服自己信任该策略）。下面给出一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题号：soj 1198 --Substring</span><br><span class="line">题目：给定n个字符串，将其拼接形成一个字典序最小的字符串（1&lt;&#x3D;n&lt;&#x3D;8）</span><br></pre></td></tr></table></figure>
<p><br/>那么，我们可以考虑以下几种方案：</p>
<ul>
<li>直接对所有字符串按字典序大小排序后进行拼接。<br/></li>
<li>暴力枚举所有组合的可能性，再遍历得到字典序最小的组合。<br/></li>
<li><strong>传说中的贪心法</strong></li>
</ul>
<p>第一种方案咋一看可行，那么考虑这样一个输入：b、ba；按该方案得到的输出是”bba”，但实际上”bab”才是最优解。所以，存在反例，我们可以否定第一种方案。</p>
<p>显然，暴力枚举是可以得到正确结果的，时间复杂度O(n<sup>2</sup>)，相对于我们将要讨论的贪心法，既费时又费力。（文末会附上暴力枚举方案的代码）。</p>
<p>那么，在这个题目中贪心法的策略是如何呢？</p>
<p>合理的做法是先对这n个字符串进行某种<b>排序</b>再拼接。这里的排序方式是指，对于两个字符串str1、str2，如果str1+str2 &lt; str2+str1，那么把str1放在str2的前面所得到的字符串就是字典序更小的那个。当每两个字符串之间都按照这个标准进行比较并排序后，最终串起来的结果就是正确答案。</p>
<p>该策略证明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">证题：若a &lt;&#x3D; b，b &lt;&#x3D; c，那么a &lt;&#x3D; c(已重载比较符)。</span><br><span class="line">证明：</span><br><span class="line">    由 a &lt;&#x3D; b 得 ab &lt;&#x3D; ba； </span><br><span class="line">    由 b &lt;&#x3D; c 得 bc &lt;&#x3D; cb；</span><br><span class="line">    易得 ac &lt;&#x3D; ca，推出a &lt;&#x3D; c。证毕。</span><br></pre></td></tr></table></figure>
<p><br/>证明完成，将上述思想转化为代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool cmp(string str1, string str2)&#123;</span><br><span class="line">	return str1+str2 &lt; str2+str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string subStr(int n, string str[])&#123;</span><br><span class="line">	string ret &#x3D; &quot;&quot;;</span><br><span class="line">	sort(str, str+n, cmp);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; ++i)&#123;</span><br><span class="line">		ret +&#x3D; str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题写得略长了，之后的题目就点到为止吧。</p>
<p>附录：</p>
<p><a href="https://blog.csdn.net/weixin_43864929/article/details/105039150" target="_blank" rel="noopener">求字典序最小的拼接字符串之暴力枚举法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>贪心法</tag>
      </tags>
  </entry>
</search>
