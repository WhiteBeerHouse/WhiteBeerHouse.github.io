<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>贪心法（一）</title>
    <url>/2020/03/22/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>久仰大名。没想到这么折腾人。先上定义 ↓</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">贪心算法：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</span><br><span class="line"></span><br><span class="line">贪心法的特点：</span><br><span class="line">· 不是对所有问题都能得到整体最优解，关键是贪心策略的选择</span><br><span class="line">· 选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</span><br></pre></td></tr></table></figure>
<p><br/>听起来挺简单对吧，但最优解的策略是真不好找，而且往往需要证明（哪怕不太严谨但也应说服自己信任该策略）。下面给出一个例子。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">题号：soj <span class="number">1198</span> <span class="comment">--Substring</span></span><br><span class="line">题目：给定n个字符串，将其拼接形成一个字典序最小的字符串（<span class="number">1</span>&lt;=n&lt;=<span class="number">8</span>）</span><br></pre></td></tr></table></figure>
<p><br/>那么，我们可以考虑以下几种方案：</p>
<p>– 直接对所有字符串按字典序大小排序后进行拼接。<br/><br>– 暴力枚举所有组合的可能性，再遍历得到字典序最小的组合。<br/><br>– <b>传说中的贪心法</b></p>
<p>第一种方案咋一看可行，那么考虑这样一个输入：b、ba；按该方案得到的输出是”bba”，但实际上”bab”才是最优解。所以，存在反例，我们可以否定第一种方案。</p>
<p>显然，暴力枚举是可以得到正确结果的，时间复杂度O(n<sup>2</sup>)，相对于我们将要讨论的贪心法，既费时又费力。（文末会附上暴力枚举方案的代码）。</p>
<p>那么，在这个题目中贪心法的策略是如何呢？</p>
<p>合理的做法是先对这n个字符串进行某种<b>排序</b>再拼接。这里的排序方式是指，对于两个字符串str1、str2，如果str1+str2 &lt; str2+str1，那么把str1放在str2的前面所得到的字符串就是字典序更小的那个。当每两个字符串之间都按照这个标准进行比较并排序后，最终串起来的结果就是正确答案。</p>
<p>该策略证明如下：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">证题：若a &lt;= b，b &lt;= c，那么a &lt;= c(已重载比较符)。</span><br><span class="line">证明：</span><br><span class="line">    由 a &lt;= b 得 ab &lt;= ba； </span><br><span class="line">    由 b &lt;= c 得 bc &lt;= cb；</span><br><span class="line">    易得 ac &lt;= ca，推出a &lt;= c。证毕。</span><br></pre></td></tr></table></figure>
<p><br/>证明完成，将上述思想转化为代码。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bool</span> cmp(string str1, string str2)&#123;</span><br><span class="line">	return str1+str2 &lt; str2+str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">string</span> subStr(int n, string str[])&#123;</span><br><span class="line">	string ret = <span class="string">""</span>;</span><br><span class="line">	sort(str, str+n, cmp);</span><br><span class="line">	for (int i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">		ret += str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题写得略长了，之后的题目就点到为止吧。</p>
<p>（未完待续）</p>
<p>附录：</p>
<p><a href="https://blog.csdn.net/weixin_43864929/article/details/105039150" target="_blank" rel="noopener">求字典序最小的拼接字符串之暴力枚举法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二零贰零年初</title>
    <url>/2020/03/21/%E4%BA%8C%E9%9B%B6%E8%B4%B0%E9%9B%B6%E5%B9%B4%E5%88%9D/</url>
    <content><![CDATA[<p>庚子年清明，我把原来jekyll的博客迁到了hexo框架。</p>
<hr>
<p>很久之前就想经营一下博客了，在校时苦于任务繁多，迟迟没有动手；如今受疫情影响，赋闲在家，才又拾起了这个想法，开始动手。</p>
<p>可能待到重新开学后又疏于打理了，但终究迈出了第一步，不是吗？</p>
<p>这一年想打通一下算法，自己实在是太太太太太菜了，专业又不受重视，只能自己挣扎。希望不是“想”而已。</p>
<p>所以应该会以记录题目为主吧。</p>
<p>不过首要可能是给它好好打扮一番。</p>
<p>最后吐槽一下折腾了好一波404的缘由竟是库名和账号名不一致！</p>
]]></content>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心法（二）</title>
    <url>/2020/03/28/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><a href="#1035">soj 1035 –DNA matching</a><br><a href="#1681">soj 1681 –Matchsticks</a><br><a href="#1620">soj 1620 –SCVs and minerals</a><br><a href="#2503">soj 2503 –最长字符串</a><br><a href="#1783">soj 1783 –Large is Better</a><br><a href="#8536">soj 8536 –Happy Camper</a><br><a href="#6771">soj 6771 –Class Packing</a></p>
<hr>
<p>⭐⭐⭐<a name="1035"></a></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">题号：soj <span class="number">1035</span> <span class="comment">--DNA matching</span></span><br><span class="line">题目：给定n个<span class="type">DNA</span>单链，问最多能组成多少对<span class="type">DNA</span>双链，每一个<span class="type">DNA</span>单链只能使用一次，且不可翻转。两个<span class="type">DNA</span>单链能够形成一对<span class="type">DNA</span>双链的条件是对应位置<span class="type">A</span>/<span class="type">T</span>，<span class="type">C</span>/<span class="type">G</span>配对。（<span class="number">1</span>&lt;=n&lt;=<span class="number">100</span>）</span><br></pre></td></tr></table></figure>
<p>第一段乍一看有点不大好处理，其实可以利用数组来解决对应位配对的情况！而对于整体的求解，类似于遍历去找配对的一对对，只不过这里是读入数据时便确定了配对情况：与集合里已有的DNA若可配对则计数+1，否则将读入的DNA装进待配对集合里。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;set&gt;</span></span><br><span class="line"><span class="title">int</span> matching(int n)&#123;</span><br><span class="line">	static char match_str[<span class="number">127</span>];</span><br><span class="line">	match_str['<span class="type">A'</span>] = '<span class="type">T'</span>;</span><br><span class="line">	match_str['<span class="type">T'</span>] = '<span class="type">A'</span>;</span><br><span class="line">	match_str['<span class="type">G'</span>] = '<span class="type">C'</span>;</span><br><span class="line">	match_str['<span class="type">C'</span>] = '<span class="type">G'</span>;</span><br><span class="line">	</span><br><span class="line">	int matchNum = <span class="number">0</span>;</span><br><span class="line">	multiset&lt;string&gt; <span class="type">S</span>;</span><br><span class="line">	string str, matchedStr;</span><br><span class="line">	for (int i = <span class="number">0</span>; i &lt; n; ++i)&#123;// n条<span class="type">DNA</span></span><br><span class="line">		cin &gt;&gt; str;</span><br><span class="line">		matchedStr = <span class="string">""</span>;</span><br><span class="line">		for (int j = <span class="number">0</span>; j &lt; str.size(); ++j)&#123;</span><br><span class="line">			matchedStr += match_str[str[j]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="type">S</span>.count(matchedStr))&#123;</span><br><span class="line">			++ matchNum;</span><br><span class="line">			<span class="type">S</span>.erase(<span class="type">S</span>.lower_bound(matchedStr));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">S</span>.insert(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return matchNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐<a name="1681"></a></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">题号：soj <span class="number">1681</span> <span class="comment">--Matchsticks</span></span><br><span class="line">题目：如下图所示，给定n根火柴，求其可以摆出的最小的数和最大的数（<span class="number">2</span>&lt;=n&lt;=<span class="number">100</span>）</span><br></pre></td></tr></table></figure>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.3/image/1681.jpg"  alt=""><br/><br>显然，由于数字1只需要2根火柴以及数字7只需要3根火柴，最大的数必然全为1（偶数根火柴）或打7开头后全为1（奇数根火柴）。<br/><br>而对于最小的数，先枚举火柴数少的情况，再通过递归对火柴数更多的情况进行选择。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">string</span> minNum(int matchsticks)&#123;//不喜用switch-<span class="keyword">case</span>语句</span><br><span class="line">	<span class="keyword">if</span> (matchsticks == <span class="number">2</span>)	return <span class="string">"1"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (matchsticks == <span class="number">3</span>)	return <span class="string">"7"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (matchsticks == <span class="number">4</span>)	return <span class="string">"4"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (matchsticks == <span class="number">5</span>)	return <span class="string">"2"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (matchsticks == <span class="number">6</span>)	return <span class="string">"6"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (matchsticks == <span class="number">7</span>)	return <span class="string">"8"</span>;	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (matchsticks == <span class="number">8</span>) 	return <span class="string">"10"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (matchsticks == <span class="number">10</span>) 	return <span class="string">"22"</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		string min1= minNum(matchsticks - <span class="number">7</span>) + <span class="string">"8"</span>;</span><br><span class="line">		string min2 = minNum(matchsticks - <span class="number">6</span>) + <span class="string">"0"</span>;</span><br><span class="line">		<span class="keyword">if</span> (min1.size() &lt; min2.size() || min1 &lt; min2)	return min1;</span><br><span class="line">		<span class="keyword">else</span> return min2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">string</span> maxNum(int matchsticks)&#123;</span><br><span class="line">	string tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">if</span> (matchsticks % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		for (int i = <span class="number">0</span>; i &lt; matchsticks/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">			tmp += <span class="string">"1"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		tmp = <span class="string">"7"</span>;</span><br><span class="line">		matchsticks -= <span class="number">3</span>;</span><br><span class="line">		for (int i = <span class="number">0</span>; i &lt; matchsticks / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">			tmp += <span class="string">"1"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此题有两个坑：<strong>1.</strong> 题目要求”no leading zeroes”，这里也包括了一位数的情况，即给定6根火柴棒时最小数不取0。<br><strong>2.</strong> 虽然火柴数为9的情况可以由递归解决但为10时不可，所以也需另外给出。</p>
<hr>
<p>⭐⭐⭐⭐<a name="1620"></a></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">题号：soj <span class="number">1620</span> <span class="comment">--SCVs and minerals</span></span><br><span class="line">题目：游戏“ <span class="type">StarCraft</span>”设定为，最初您有<span class="type">N</span>个<span class="type">SCV</span>和<span class="type">M</span>个mineral。每个<span class="type">SCV</span>可以在一秒钟内获得<span class="type">C</span>个mineral，而指挥中心可以立即用<span class="type">P</span>个mineral生产<span class="number">1</span>个<span class="type">SCV</span>。求在<span class="type">S</span>秒后可获得的最多的mineral数量。</span><br></pre></td></tr></table></figure>
<p>最开始的想法就是递归调用，想在每一步都得到最多的mineral。样例输出很快否定了这个方法，仔细一想才发现，这个问题可以转换成我们熟悉的场景——生意买卖，只要作为生产设备的SCV能够在剩下的时间内产出不少于成本价P的mineral，那么赚得的肯定就最多了。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="title">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"><span class="title">int</span> main() &#123;</span><br><span class="line">	int testNum = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; testNum;</span><br><span class="line">	for (int i = <span class="number">0</span>; i &lt; testNum; ++i) &#123;</span><br><span class="line">		int <span class="type">N</span>, <span class="type">M</span>, <span class="type">C</span>, <span class="type">P</span>, <span class="type">S</span>;</span><br><span class="line">		cin &gt;&gt; <span class="type">N</span> &gt;&gt; <span class="type">M</span> &gt;&gt; <span class="type">C</span> &gt;&gt; <span class="type">P</span> &gt;&gt; <span class="type">S</span>;	</span><br><span class="line">		for (int j = <span class="number">0</span>; j &lt; <span class="type">S</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="type">S</span> - j) * <span class="type">C</span> &gt;= <span class="type">P</span>) &#123;//<span class="type">P</span>是获得一个<span class="type">SCV</span>的成本，(<span class="type">S</span>-j)*<span class="type">C</span>是该<span class="type">SCV</span>能带来的收入</span><br><span class="line">				<span class="type">N</span> += <span class="type">M</span> / <span class="type">P</span>;</span><br><span class="line">				<span class="type">M</span> %= <span class="type">P</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">M</span> += <span class="type">N</span> * <span class="type">C</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="type">M</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐⭐<a name="2503"></a></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">题号：soj <span class="number">2503</span> <span class="comment">--最长字符串</span></span><br><span class="line">题目：要求你构造一个由字符'<span class="type">A'</span>,'<span class="type">B'</span>组成的字符串, 满足以下几个条件:</span><br><span class="line"><span class="number">1</span>) <span class="type">A</span>的个数&lt;=countA</span><br><span class="line"><span class="number">2</span>) <span class="type">B</span>的个数&lt;=countB</span><br><span class="line"><span class="number">3</span>) 连续的<span class="type">A</span>的个数不可以超过maxA.</span><br><span class="line"><span class="number">4</span>) 连续的<span class="type">B</span>的个数不可以超过maxB.</span><br><span class="line"><span class="number">5</span>) 这个字符串的长度最长.</span><br><span class="line">给定countA, countB, maxA, maxB, 求输出字符串的最大长度。</span><br></pre></td></tr></table></figure>
<p>不知道是不是被算法名字所束缚了，总想着在每一步都积累最多的’A’或’B’以求整体最大，这个想法最大的漏洞在于：两者的数量差可能是<strong>悬殊</strong>的，这个时候尽可能更多地分组才是最优解。<br/><br/><br>此题解法：将A或B作为基准，另外一个进行分组作为分隔符。如果非分隔符多于分组数量，尽可能填满分隔符之间的空隙；若分组数量多于非分隔符，则尽可能填充更多的空隙。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#include &lt;math.h&gt;</span></span><br><span class="line"><span class="title">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"><span class="title">int</span> handler(int countA, int countB, int maxA, int maxB) &#123;//以<span class="type">A</span>为基准，以<span class="type">B</span>为分隔符</span><br><span class="line">	<span class="keyword">if</span> (maxA == <span class="number">0</span>)	return min(maxB, countB);</span><br><span class="line">	<span class="keyword">if</span> (maxB == <span class="number">0</span>)	return min(maxA, countA);</span><br><span class="line"></span><br><span class="line">	int despNum = ceil(countB / maxB);//ceil()向上取整，即前n<span class="number">-1</span>组<span class="type">B</span>的数量同，最后一组可能不同</span><br><span class="line">	<span class="keyword">if</span> (countA &gt; despNum)	return min(countA + countB, countB + (despNum + <span class="number">1</span>) * maxA);</span><br><span class="line">	<span class="keyword">else</span> return	countA + min(countB, (countA+<span class="number">1</span>)*maxB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">int</span> main() &#123;</span><br><span class="line">	int countA, countB, maxA, maxB;</span><br><span class="line">	cin &gt;&gt; countA &gt;&gt; countB &gt;&gt; maxA &gt;&gt; maxB;</span><br><span class="line">	int len1 = handler(countA, countB, maxA, maxB);</span><br><span class="line">	int len2 = handler(countB, countA, maxB, maxA);</span><br><span class="line">	cout &lt;&lt; max(len1, len2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐<a name="1783"></a></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">题号：soj <span class="number">1783</span> <span class="comment">--Large is Better</span></span><br><span class="line">题目：给定一个数字，除了<span class="number">0</span>，可以交换任意数量的相邻数字，不允许用数字<span class="number">0</span>去交换任何数字。求经过交换所能得到的最大数字。</span><br></pre></td></tr></table></figure>
<p>没有太大难度，就是分割排序。不过用<strong>迭代器</strong>这个骚操作真得学起来了啊…</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#include &lt;string&gt;</span></span><br><span class="line"><span class="title">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"><span class="title">int</span> main() &#123;</span><br><span class="line">	int testNum;</span><br><span class="line">	cin &gt;&gt; testNum;</span><br><span class="line">	while (testNum<span class="comment">--) &#123;</span></span><br><span class="line">		string str1;</span><br><span class="line">		cin &gt;&gt; str1;</span><br><span class="line">		int length = str1.size();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//进一步优化：用iterator去指向每个分割的部分</span><br><span class="line">		string::iterator iter1 = str1.begin();</span><br><span class="line">		string::iterator iter2 = iter1;</span><br><span class="line">		for (int i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (*iter2 == '<span class="number">0</span>') &#123;</span><br><span class="line">				sort(iter1, iter2, greater&lt;&gt;());</span><br><span class="line">				iter1 = iter2+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			++iter2;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(iter1, iter2, greater&lt;&gt;());</span><br><span class="line">		cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐<a name="8536"></a></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">题号：soj <span class="number">8536</span> <span class="comment">--Happy Camper</span></span><br><span class="line">题目：设整数<span class="number">1</span>&lt;<span class="type">L</span>&lt;<span class="type">P</span>&lt;<span class="type">V</span>，在任何连续的<span class="type">P</span>天时间里，露营地的占用限于<span class="type">L</span>天。<span class="type">Harry</span> <span class="type">Camper</span>拥有<span class="type">V</span>天的假期。请问假期期间，他最多可以露营地住多少天？</span><br></pre></td></tr></table></figure>
<p>不知道为什么这么简单的题目会被放进课件里…就是分割啦跟上上道题同源的思想然而比那个水好多…</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="title">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"><span class="title">int</span> main() &#123;</span><br><span class="line">	int <span class="type">L</span>, <span class="type">P</span>, <span class="type">V</span>;</span><br><span class="line">	int caseNum = <span class="number">1</span>;</span><br><span class="line">	while (cin &gt;&gt; <span class="type">L</span> &gt;&gt; <span class="type">P</span> &gt;&gt; <span class="type">V</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="type">L</span> &amp;&amp; <span class="type">P</span> &amp;&amp; <span class="type">V</span>))	return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		int maxDays = <span class="number">0</span>;</span><br><span class="line">		int despNum = <span class="type">V</span> / <span class="type">P</span>;</span><br><span class="line">		maxDays += <span class="type">L</span> * despNum;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (despNum * <span class="type">P</span> &lt; <span class="type">V</span>) &#123;</span><br><span class="line">			maxDays += min(<span class="type">L</span>, <span class="type">V</span> - despNum * <span class="type">P</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">"Case "</span> &lt;&lt; caseNum &lt;&lt; <span class="string">": "</span> &lt;&lt; maxDays &lt;&lt; endl;</span><br><span class="line">		++caseNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>⭐⭐⭐⭐<a name="6771"></a></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">题号：soj <span class="number">6771</span> <span class="comment">--Class Packing</span></span><br><span class="line">题目：年级为<span class="number">0</span>~<span class="number">6</span>共七个年级的学生，给定每个年级的学生数量。现为这些学生分配班级，需要满足以下条件：</span><br><span class="line">   <span class="number">1</span>：一个班级只能有一个年级或两个相邻年级的学生，例如，四年级和五年级学生的班级人数不得超过<span class="number">25</span>。</span><br><span class="line">   <span class="number">2</span>: 拥有年级<span class="number">0</span><span class="number">-2</span>的学生的班级，其人数最多为<span class="number">20</span>。</span><br><span class="line">   <span class="number">3</span>: 拥有年级<span class="number">3</span><span class="number">-4</span>的学生的班级，其人数最多为<span class="number">25</span>。</span><br><span class="line">   <span class="number">4</span>: 拥有年级<span class="number">5</span><span class="number">-6</span>的学生的班级，其人数最多为<span class="number">30</span>。</span><br><span class="line">求至少需要分配多少个班级。</span><br></pre></td></tr></table></figure>
<p>emmm…看提示之前是思绪是非常乱的…纠结于how to divide them…Fine其实正确思路再简单不过了：<strong>如果人数多的话，将他们尽量分配到同一个班的结果是理想的（因为如果分配到其他的班，可能会影响到高年级的班级的容量）；如果人数有剩下的话，就从其上一年级中调派人员过来，使得该班的容量填满。</strong></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="title">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"><span class="title">int</span> main() &#123;</span><br><span class="line">	int grade[<span class="number">7</span>];</span><br><span class="line">	while (cin &gt;&gt; grade[<span class="number">0</span>] &gt;&gt; grade[<span class="number">1</span>] &gt;&gt; grade[<span class="number">2</span>] &gt;&gt; grade[<span class="number">3</span>] &gt;&gt; grade[<span class="number">4</span>] &gt;&gt; grade[<span class="number">5</span>] &gt;&gt; grade[<span class="number">6</span>]) &#123;</span><br><span class="line">		bool flag = true;</span><br><span class="line">		for (int i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (grade[i] != <span class="number">0</span>) &#123;</span><br><span class="line">				flag = false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag)	return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		int limits[<span class="number">7</span>] = &#123; <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">		int num = <span class="number">0</span>;</span><br><span class="line">		int left = <span class="number">0</span>;</span><br><span class="line">		for (int i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">			while (grade[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (left != <span class="number">0</span> &amp;&amp; grade[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					grade[i] -= left;</span><br><span class="line">					left = <span class="number">0</span>;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (grade[i] &lt; limits[i]) &#123;</span><br><span class="line">					left = limits[i] - grade[i];</span><br><span class="line">				&#125;</span><br><span class="line">				++num;</span><br><span class="line">				grade[i] -= limits[i];			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🐣最后一点点想法：C++标准库函数真的很实用！</p>
<p>（未完待续）</p>
<p>附录：</p>
<p><a href="https://blog.csdn.net/qq_28351609/article/details/84630535" target="_blank" rel="noopener">STL之map用法详解</a><br><a href="https://blog.csdn.net/sodacoco/article/details/84798621" target="_blank" rel="noopener">STL之multiset用法总结</a><br><a href="http://c.biancheng.net/view/545.html" target="_blank" rel="noopener">Multiset用法详解</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
