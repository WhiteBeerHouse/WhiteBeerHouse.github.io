<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统实验ucore-lab-5</title>
      <link href="/2020/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8Cucore-lab-5/"/>
      <url>/2020/07/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8Cucore-lab-5/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统实验报告（实验六）"><a href="#操作系统实验报告（实验六）" class="headerlink" title="操作系统实验报告（实验六）"></a>操作系统实验报告（实验六）</h1><h4 id="emsp-练习0"><a href="#emsp-练习0" class="headerlink" title="&emsp;练习0"></a>&emsp;<strong>练习0</strong></h4><p>&emsp;&emsp;将 lab1、lab2、lab3、lab4 完成的代码移植到 lab5 中，涉及到的文件有：kern/debug/kdebug.c、kern/trap/trap.c、kern/mm/default_pmm.c、kern/mm/pmm.c、kern/mm/vmm.c、kern/mm/swap_fifo.c、kern/process/proc.c。<br>&emsp;&emsp;其中，需要对 kern/trap/trap.c、kern/process/proc.c 进行补充和修改。<br>&emsp;&emsp;kern/trap/trap.c：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">idt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc))&#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//更新以下语句：</span></span><br><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);<span class="comment">//设置特定中断号的中断门，使用户进程能够进行系统调用</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;为使用户态进程能够进行系统调用以及从用户态切换到内核态，需要设置中断描述符 idt[T_SYSCALL]，其特权级设置为 DPL_USER，中断向量处理地址设置为 __vectors[T_SYSCALL] 处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct trapframe *tf) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  <span class="keyword">if</span> ((++ticks) % TICK_NUM == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//更新以下语句：</span></span><br><span class="line">assert(current != <span class="literal">NULL</span>);<span class="comment">//检查当前进程是否合法</span></span><br><span class="line"><span class="comment">//增加以下语句：</span></span><br><span class="line">current-&gt;need_resched = <span class="number">1</span>;<span class="comment">//当分配给进程的时间片用完时将当前进程设置为需要被调度</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/*...*/</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在中断时将当前进程设置为需要被调度的，以便在下一个时间片重新选择进程。<br/><br>&emsp;&emsp;kern/process/proc.c：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="comment">//增加以下语句：</span></span><br><span class="line">proc-&gt;wait_state = <span class="number">0</span>;<span class="comment">//设置进程为等待态</span></span><br><span class="line">proc-&gt;cptr = <span class="literal">NULL</span>;<span class="comment">//设置进程的父进程为空</span></span><br><span class="line">proc-&gt;yptr = <span class="literal">NULL</span>;<span class="comment">//设置进程的弟进程为空</span></span><br><span class="line">proc-&gt;optr = <span class="literal">NULL</span>;<span class="comment">//设置进程的兄进程为空</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;用户进程的进程控制块增加了进程等待状态和相关指针的条目，因此需要对应进行初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">proc-&gt;parent = current;</span><br><span class="line"><span class="comment">//增加以下语句：</span></span><br><span class="line">assert(proc-&gt;wait_state == <span class="number">0</span>);<span class="comment">//确保当前进程正在等待</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">proc-&gt;pid = get_pid();</span><br><span class="line">hash_proc(proc);</span><br><span class="line"><span class="comment">//删除以下语句：</span></span><br><span class="line"><span class="comment">//++nr_process;</span></span><br><span class="line"><span class="comment">//list_add(&amp;(proc_list), &amp;(proc-&gt;list_link));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//增加以下语句：</span></span><br><span class="line">set_links(proc);<span class="comment">//将新进程添加到进程列表中并设置相关连接</span></span><br><span class="line">&#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;需要注意的是 set_links 函数中已经实现了将进程添加到进程列表并使进程总数加 1，因此需要删减 lab4 对应的代码。<br><br/></p><h4 id="emsp-练习1"><a href="#emsp-练习1" class="headerlink" title="&emsp;练习1"></a>&emsp;<strong>练习1</strong></h4><ul><li><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">load_icode(<span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> <span class="built_in">size</span>) &#123;</span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">tf-&gt;tf_cs = USER_CS;<span class="comment">//中断帧指向的代码段设为 USER_CS</span></span><br><span class="line">tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<span class="comment">//中断帧指向的数据段和堆栈段等设为 USER_DS</span></span><br><span class="line">tf-&gt;tf_esp = USTACKTOP;<span class="comment">//中断帧指向的 ESP 寄存器存放用户栈的栈顶</span></span><br><span class="line">tf-&gt;tf_eip = elf-&gt;e_entry;<span class="comment">//中断帧指向的 EIP 寄存器存放 ELF 可执行文件加载到内存的入口</span></span><br><span class="line">tf-&gt;tf_eflags = FL_IF;<span class="comment">//中断帧指向的 EFLAGS 寄存器存放中断使能的标志</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure><p>为了使用户进程能够从内核态跳转到用户态，需要正确设置中断帧的段寄存器、ESP 寄存器、EIP 寄存器以及 EFLAGS 寄存器。根据提示填写代码，具体实现的理解已作注释。<br/> </p></li><li><p>描述当创建一个用户态进程并加载了应用程序后，CPU 是如何让这个应用程序最终在用户态执行起来的，即该用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的整个经过。</p></li></ul><p>&emsp;&emsp;①. init_main 内核线程通过 user_main 函数调用 kernel_tread 创建用户进程，user_main 函数调用 kernel_execve 函数将具体应用程序的执行内容放入内存。<br>&emsp;&emsp;②. kernel_execve 函数执行 exec 系统调用，CPU 保存中断现场，根据中断号查找中断向量表，进入中断处理例程，之后进入 do_execve 函数。<br>&emsp;&emsp;③. do_execve 函数保证用户态虚拟内存空间合法后，回收旧进程的空间，调用 load_icode 函数。<br>&emsp;&emsp;④. load_icode 函数初始化新用户进程的内存空间，并修改中断帧，使中断返回时能够进入用户态并将控制权转移到应用程序入口处。<br>&emsp;&emsp;⑤. 通过 load_icode 函数完成用户进程的环境搭建后沿函数调用路径返回中断处理例程，待中断处理例程执行 iret 指令后完成特权级的转换，并跳转到应用程序的入口处，开始执行应用程序的的第一条指令。<br><br/></p><h4 id="emsp-练习2"><a href="#emsp-练习2" class="headerlink" title="&emsp;练习2"></a>&emsp;<strong>练习2</strong></h4><ul><li><p>补充 copy_range 的实现，确保能够正确执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copy_range(<span class="keyword">pde_t</span> *to, <span class="keyword">pde_t</span> *from, <span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> <span class="built_in">end</span>, <span class="keyword">bool</span> share) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"><span class="keyword">void</span> *src_kvaddr = page2kva(page);<span class="comment">//获得父进程的物理页 page 对应的内核虚拟地址 src_kvaddr</span></span><br><span class="line"><span class="keyword">void</span> *dst_kvaddr = page2kva(npage);<span class="comment">//获得子进程物理页 npage 对应的内核虚拟地址 dst_kvaddr</span></span><br><span class="line"><span class="built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);<span class="comment">//将父进程物理页的内容复制到子进程的物理页</span></span><br><span class="line"><span class="comment">/* 以下语句参考答案之后已作修改 */</span></span><br><span class="line"><span class="comment">//page_insert(to, npage, start, perm);</span></span><br><span class="line">ret = page_insert(to, npage, start, perm);<span class="comment">//建立子进程的物理页与虚拟页的映射关系</span></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy_range 函数用于将父进程的指定内存范围的虚拟页的内容复制到创建的子进程的物理页中，并为子进程的物理页和对应的虚拟页建立映射关系。根据提示填写代码，具体实现的理解已作注释。<br/></p></li><li><p>简要说明如何设计实现 “Copy on Write” 机制，给出概要设计，鼓励给出详细设计。</p></li></ul><p>&emsp;&emsp;“Copy on Write” 机制是指如果有多个使用者对一个资源 A 进行读操作，则每个使用者只需获得一个指向同一个资源 A 的指针就可以实现；若某使用者需要对该资源进行写操作，则系统会拷贝资源 A 到资源 B，使该使用者对其私有的资源 B 进行写操作。<br>&emsp;&emsp;因此可以在现有代码的基础上作如下修改来实现 “Copy on Write” 机制：<br>&emsp;&emsp;①. 在创建子进程时，复制内存部分暂不实际复制所有内存，而是使子进程的虚拟页指向父进程的可共享的物理页。<br>&emsp;&emsp;②. 取消父进程和子进程对共享页的写权限，使父进程或子进程试图对只读共享页执行写操作时会产生页访问异常，执行页异常处理，此时再复制需要进行写操作的页面，恢复进程对这部分页面的写权限。<br><br/></p><h4 id="emsp-练习3"><a href="#emsp-练习3" class="headerlink" title="&emsp;练习3"></a>&emsp;<strong>练习3</strong></h4><ul><li>对 fork/exec/wait/exit 函数的详细分析：</li></ul><p>&emsp;&emsp;①. fork 函数完成进程的拷贝工作。查看文件 /user/libs/ulib.c、/user/libs/syscall.c 和 /kern/process/proc.c 可知，fork 函数调用了 sys_fork 函数，sys_fork 函数执行系统调用 SYS_fork，该系统调用的实现由 do_fork 函数完成。<br>&emsp;&emsp;do_fork 函数的主要工作是：分配并初始化进程控制块-&gt;为子进程分配并初始化内核栈-&gt;复制原进程的内存管理信息到新进程-&gt;复制原进程上下文到新进程-&gt;为新进程分配进程号-&gt;将新进程添加到进程列表中-&gt;调用 wakeup_proc 函数将进程的状态设置为 PROC_RUNNABLE-&gt;将新进程的 id 作为返回码并返回。<br>&emsp;&emsp;②. exec 函数完成用户进程的创建及加载进程进入执行的工作。查看文件 /kern/process/proc.c 可知 kernel_execve 函数执行系统调用 SYS_exec，该系统调用的实现由 do_execve 函数完成。<br>&emsp;&emsp;do_execve 函数的主要工作是：保证用户态虚拟内存空间合法-&gt;调用 exit_mmap、put_pgdir 和 mm_destroy 函数清空当前进程内存空间的内存映射关系、页表信息和内存管理信息等-&gt;调用 load_icode 函数加载应用程序进入内存并建立新的内存映射关系-&gt;设置新加载的进程的名字然后返回。<br>&emsp;&emsp;③. wait 函数完成等待子进程结束以释放子进程占用的资源的工作。查看文件 /user/libs/ulib.c、/user/libs/syscall.c 和 /kern/process/proc.c 可知，wait 函数调用了 sys_wait 函数，sys_wait 函数执行系统调用 SYS_wait，该系统调用的实现由 do_wait 函数完成。<br>&emsp;&emsp;do_wait 函数的主要工作是：查找指定进程号或任意的一个状态为 PROC_ZOMBIE 的进程-&gt;如果找到则回收该进程，具体包括从进程队列中删除该进程、释放该进程的内核堆栈和进程控制块；如果找不到，则将当前进程状态修改为 PROC_SLEEPING，等待状态设置为 WT_CHILD 并调用 schedule 函数调度执行其他进程，直到其子进程结束唤醒该进程再重复寻找状态为 PROC_ZOMBIE 的进程。<br>&emsp;&emsp;④. exit 函数完成当前进程的退出和资源回收的工作。查看文件 /user/libs/ulib.c、/user/libs/syscall.c 和 /kern/process/proc.c 可知，exit 函数调用了 sys_exit 函数，sys_exit 函数执行系统调用 SYS_exit，该系统调用的实现由 do_exit 函数完成。<br>&emsp;&emsp;do_exit 函数的主要工作是：回收当前用户进程的大部分内存空间-&gt;将当前进程状态修改为 PROC_ZOMBIE，退出码设置为指定的 error_code-&gt;如果其父进程处于 WT_CHILD 的等待状态，则调用 wakeup_proc 函数唤醒其父进程完成当前进程的资源回收工作；如果当前进程有子进程，则将这些子进程设置为 initproc 的子进程，在有子进程处于 PROC_ZOMBIE 的情况下唤醒 initproc 完成这些子进程的资源回收工作-&gt;调用 schedule 函数调度新的进程执行。<br/></p><ul><li>对 fork/exec/wait/exit 函数在实现中如何影响进程的执行状态的分析：</li></ul><p>&emsp;&emsp;fork 函数创建子进程后将子进程的执行状态设置为 PROC_RUNNABLE，不改变父进程的执行状态。<br>&emsp;&emsp;exec 函数不改变进程的执行状态。<br>&emsp;&emsp;wait 函数在找到状态为 PROC_ZOMBIE 的进程的情况下回收该进程的资源，但不改变其他进程的执行状态；在找不到状态为 PROC_ZOMBIE 的进程的情况下会将当前进程的执行状态修改为 PROC_SLEEPING。<br>&emsp;&emsp;exit 函数将当前进程的执行状态修改为 PROC_ZOMBIE，唤醒父进程或 initproc，即将执行状态修改为 PROC_RUNNABLE。<br/></p><ul><li>ucore 中一个用户态进程的执行状态生命周期图：</li></ul><p><img width='120%px' height='120%' src='https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab5-010.png'/></p><p>&emsp;&emsp;在 lab5 目录下执行”make grade”，结果如下：<br>&emsp;&emsp;&emsp;&emsp;<img width='55%' height='55%' src='https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab5-001.png'/><br>&emsp;&emsp;实验顺利完成。<br/></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统的知识集合</title>
      <link href="/2020/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/"/>
      <url>/2020/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾"><a href="#因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾" class="headerlink" title="因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾"></a>因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾</h3><p><a href="https://www.cnblogs.com/imysql/p/5487213.html" target="_blank" rel="noopener">数据库之闭包，范式</a><br><a href="https://www.cnblogs.com/yuelien/p/9934645.html" target="_blank" rel="noopener">【模式分解】无损连接&amp;保持函数依赖</a><br><a href="https://blog.csdn.net/legendaryhaha/article/details/80649234" target="_blank" rel="noopener">数据库中的无损连接分解和是否保持函数依赖的判定</a><br><a href="https://www.baidu.com/s?wd=%E4%BE%9D%E8%B5%96%E4%BF%9D%E6%8C%81%E5%88%86%E8%A7%A3&amp;rsv_spt=1&amp;rsv_iqid=0xa09a7c2c0012ea4f&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=78040160_5_pg&amp;ch=8&amp;rsv_enter=0&amp;rsv_dl=tb&amp;rsv_sug3=18&amp;rsv_sug1=16&amp;rsv_sug7=101&amp;rsv_btype=i&amp;inputT=7210&amp;rsv_sug4=9026" target="_blank" rel="noopener">百度搜索-依赖保持分解</a><br><a href="https://www.cnblogs.com/phpzhou/articles/4871550.html" target="_blank" rel="noopener">集合论中关系的闭包</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络理论的知识集合</title>
      <link href="/2020/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E7%9A%84%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/"/>
      <url>/2020/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E7%9A%84%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾"><a href="#因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾" class="headerlink" title="因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾"></a>因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾</h3><p><a href="https://blog.csdn.net/syzdev/article/details/104721401/" target="_blank" rel="noopener">计算机网络-TCP拥塞控制</a><br><a href="https://blog.csdn.net/a3192048/article/details/84671340" target="_blank" rel="noopener">报文、报文段、分组、包、数据报、帧、数据流的概念区别</a><br><a href="https://www.cnblogs.com/wxgblogs/p/5616829.html" target="_blank" rel="noopener">TCP流量控制和拥塞控制</a><br><a href="https://www.cnblogs.com/redsmith/p/5461677.html" target="_blank" rel="noopener">TCP的流量控制</a><br><a href="https://blog.csdn.net/qq_44807642/article/details/103054914" target="_blank" rel="noopener">【动图讲解】计算机网络之回退N步与选择重传</a></p><p><a href="https://blog.csdn.net/code_tree/article/details/107310887" target="_blank" rel="noopener">计算机基础之计算机网络学习笔记</a><br><a href="https://blog.csdn.net/ustczyy/article/details/19337251?utm_source=blogxgwz6" target="_blank" rel="noopener">IPv4与IPv6数据报格式解析</a><br><a href="https://blog.csdn.net/suwei19870312/article/details/5618234?utm_source=blogxgwz7" target="_blank" rel="noopener">网络层，传输层都提供了面向连接和无连接的服务方式</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统实验ucore-lab-1</title>
      <link href="/2020/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8Cucore-lab-1/"/>
      <url>/2020/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8Cucore-lab-1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统实验报告（实验二第一部分）"><a href="#操作系统实验报告（实验二第一部分）" class="headerlink" title="操作系统实验报告（实验二第一部分）"></a>操作系统实验报告（实验二第一部分）</h1><h4 id="emsp-练习1"><a href="#emsp-练习1" class="headerlink" title="&emsp;练习1"></a>&emsp;<strong>练习1</strong></h4><p>1.操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)<br/></p><ul><li>Makefile 通过以下命令最终生成 ucore.img：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UCOREIMG        := <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">        <span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br><span class="line">        <span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">        <span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UCOREIMG        := <span class="variable">$(<span class="built_in">call</span> totarget,ucore.img)</span></span><br></pre></td></tr></table></figure><p>表示如果变量 UCOREIMG 未定义，就把调用函数 totarget 的返回值赋值给变量 UCOREIMG。函数 totarget 定义在 tools/function.mk 中。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br></pre></td></tr></table></figure><p>表示 UCOREIMG 的生成依赖于 kernel 和 bootblock。<br/><br/></p><ul><li>生成 kernel 的主要命令：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="variable">$(<span class="built_in">call</span> totarget,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: tools/kernel.ld</span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span></span><br><span class="line">@echo + ld <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span></span><br><span class="line">@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel = <span class="variable">$(<span class="built_in">call</span> totarget,kernel)</span></span><br></pre></td></tr></table></figure><p>指定 kernel 存放的目录。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(kernel)</span>: tools/kernel.ld</span><br></pre></td></tr></table></figure><p>表示生成 kernel 依赖于 tools/kernel.ld。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span></span><br><span class="line">@echo + ld <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span></span><br><span class="line">@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br></pre></td></tr></table></figure><p>表示生成 kernel 依赖于一些 .o 文件，具体文件通过在终端执行 make “V=” 命令查看。-T 表示使链接器使用指定脚本，此处指定脚本为 tools/kernel.ld。-o 指定了输出文件为变量 kernel, KOBJS 所引用的对象。使用 objdump 反汇编得到 kernel 的汇编代码，-S 表示将反汇编得到的汇编代码与源代码混合并最终保存在 kernel.asm 中。-t 表示打印文件的符号表表项，通过管道将带有符号表的反汇编结果作为 sed 命令的标准输入进行处理，最终将符号表信息保存到 kernel.sym 中。<br/></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o obj/libs/printfmt.o obj/libs/string.o</span><br></pre></td></tr></table></figure><p>以上通过在终端执行 make “V=” 得到的部分已执行命令展示了 kernel 的生成，所依赖的 .o 文件有 init.o, readline.o, stdio.o, kdebug.o, kmonitor.o, panic.o, clock.o, console.o, intr.o, picirq.o, trap.o, trapentry.o, vectors.o, pmm.o, printfmt.o, string.o。<br/><br>其中，命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_cc,$(<span class="built_in">call</span> listf_cc,<span class="variable">$(LIBDIR)</span>)</span>,libs,)</span><br></pre></td></tr></table></figure><p>指定生成的 libs 目录下包含的CTYPE文件（.c文件和.S文件）所对应的 .o 文件以及 .d 文件的存放（相关函数定义在 tools/function.mk 中）。<br/><br>命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_cc,$(<span class="built_in">call</span> listf_cc,<span class="variable">$(KSRCDIR)</span>)</span>,kernel,<span class="variable">$(KCFLAGS)</span>)</span><br></pre></td></tr></table></figure><p>指定生成的 kern 所有子目录下包含的CTYPE文件（.c 文件和 .S 文件）所对应的 .o 文件以及 .d 文件的存放（相关函数定义在 tools/function.mk 中）。<br/></p><p>以生成 libs/printfmt.o 为例，经层层参数传递调用函数最终执行的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -c libs/printfmt.c -o obj/libs/printfmt.o</span><br></pre></td></tr></table></figure><p>表示 libs/printfmt.o 由 libs/printfmt.c 生成。<br/><br/></p><ul><li>生成 bootblock 的主要命令：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">@echo + ld <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br></pre></td></tr></table></figure><p>bootblock 的生成依赖于一些 .o 文件和 sign。其中，这些 .o 文件由 bootfiles 引用的对象生成。bootfiles 由命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>)</span><br></pre></td></tr></table></figure><p>定义。上述命令表示由 boot 目录下包含的CTYPE文件（bootmain.c 和 bootasm.s）生成所对应的 .o 文件（bootmain.o 和 bootasm.o）。<br/></p><p>经层层参数传递调用函数最终执行的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br></pre></td></tr></table></figure><p>表示 obj/boot/bootmain.o 由 boot/bootmain.c 生成；<br/></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br></pre></td></tr></table></figure><p>表示obj/boot/bootasm.o 由 boot/bootasm.S 生成。<br/><br>其中，指定的 gcc 参数含义如下：</p><ul><li>-Iboot: 增加 boot/ 为搜索头文件的路径；</li><li>-fno-builtin: 不接受不是两个下划线开头的内建函数；</li><li>-Wall: 使 gcc 生成尽可能多的警告信息；</li><li>-ggdb: 以本地格式（如果支持）输出调试信息，尽可能包括 gdb 扩展，以便供 gdb 调试；</li><li>-m32: 生成能在32位机器上运行的代码；</li><li>-gstabs: 以stabs格式(如果支持)输出调试信息；</li><li>-nostdinc: 不搜索标准系统头文件；</li><li>-fno-stack-protector: 禁用栈溢出保护；</li><li>-Os: 启用所有不增加代码大小的 -O2 优化；</li></ul><p>sign 由命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> add_files_host,tools/sign.c,sign,sign)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target_host,sign,sign)</span></span><br></pre></td></tr></table></figure><p>定义。经层层参数传递调用函数最终执行的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o </span><br><span class="line">gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br></pre></td></tr></table></figure><p>表示 bin/sign 由 obj/sign/tools/sign.o 优化编译生成，obj/sign/tools/sign.o 由 tools/sign.c 生成。<br/><br>其中，指定的 gcc 参数含义如下：</p><ul><li>-Itools: 增加 tools/ 为搜索头文件的路径；</li><li>-g: 以操作系统的本地格式产生调试信息，供 gdb 使用；</li><li>-Wall: 使 gcc 生成尽可能多的警告信息；</li><li>-O2: 启用 O2 优化，执行除了时间和空间交换的几乎所有优化工作；</li></ul><p>接下来生成bootblock:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span></span><br></pre></td></tr></table></figure><p>指定 bootblock 存放的目录。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">@echo + ld <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br></pre></td></tr></table></figure><p>表示生成 bootblock 依赖于bootmain.o, bootasm.o, sign。-N 表示将代码段和数据段设置为可读可写；-e 设置程序入口；-Ttext 设置代码段的起始地址；-o 指定了输出文件为 obj/bootblock.o。<br/><br/></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br></pre></td></tr></table></figure><p>生成 bootblock.o 的实际执行命令如上。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br></pre></td></tr></table></figure><p>表示使用 objdump 反汇编得到 bootblock.o 的汇编代码，-S 表示将得到的汇编代码保存在 bootblock.asm 中。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br></pre></td></tr></table></figure><p>表示使用 objcopy 将 bootblock.o 二进制拷贝到 bootblock.out。<br/><br>其中，-S 表示不从源文件中复制重定位信息和符号信息；-O binary 表示指定的输出格式为二进制。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br></pre></td></tr></table></figure><p>表示使用 sign 工具用 bootblock.out 生成 bootblock。<br/><br/></p><ul><li>依赖文件 kernel 和 bootblock 已存在，生成 ucore.img：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br></pre></td></tr></table></figure><p>从 /dev/zero 获取大小为10000个块的文件空间，每个块默认大小为512字节，且均为空字符，输出到目标文件 bin/ucore.img。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br></pre></td></tr></table></figure><p>将 bootblock 中的数据写到 bin/ucore.img 第一个块。conv=notrunuc 表示不截断输出文件。<br/></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br></pre></td></tr></table></figure><p>将 kernel 中的数据写到 bin/ucore.img 第二个块。seek=1 表示跳过 bin/ucore.img 的第一个块。<br/><br>至此，ucore.img 生成。<br/></p><p>2.一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？<br/></p><ul><li>一个硬盘主引导扇区占据一个扇区，大小为 512 个字节。</li><li>该扇区最后两个字节分别为 0x55 和 0xAA。</li></ul><p><br/></p><h3 id="emsp-练习2"><a href="#emsp-练习2" class="headerlink" title="&emsp;练习2"></a>&emsp;<strong>练习2</strong></h3><p>1.从 CPU 加电后执行的第一条指令开始，单步跟踪 BIOS 的执行。</p><ul><li>将 lab1/tools/gdbinit 文件内容修改为:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set architecture i8086</span><br><span class="line">target remote: 1234</span><br></pre></td></tr></table></figure><ul><li>在 lab1 目录下执行：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make debug</span><br></pre></td></tr></table></figure><ul><li>进入 gdb 调试页面：</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-001.png"  alt=""></p><ul><li>使用命令 layout regs 查看 CS:EIP 可知 CPU 加电后执行的第一条指令地址为 0xffff0，使用命令 x /i 0xffff0 查看对应汇编代码：</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-002.png"  alt=""></p><ul><li>使用命令 si 单步跟踪：</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-003.png"  alt=""></p><p>&emsp;&emsp;&emsp;可知第一条指令已经执行，后续单步跟踪与上述步骤一致。<br/><br/></p><p>2.在初始化位置 0x7c00 设置实地址断点，测试断点正常。</p><ul><li>在 lab1/tools/gdbinit 文件内容后面加上:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b *0x7c00</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><ul><li>在 lab1 目录下执行 make debug 后进入 gdb 调试页面：</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-004.png"  alt=""></p><p>&emsp;&emsp;&emsp;显示断点 1 在地址 0x7c00 处，查看 CS:EIP 可知当前指令指向地址 0x7c00 处，可知断点正常。<br/></p><p>3.在调用 qemu 时增加-d in_asm -D q.log 参数，便可以将运行的汇编指令保存在 q.log 中。从 0x7c00 开始跟踪代码运行,将单步跟踪反汇编得到的代码与 bootasm.S 和 bootblock.asm 进行比较，看看二者是否一致。</p><ul><li><p>修改 Makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">debug: <span class="variable">$(UCOREIMG)</span></span></span><br><span class="line"><span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">"<span class="variable">$(QEMU)</span> -S -s -d in_asm -D <span class="variable">$(BINDIR)</span>/q.log -parallel stdio -hda <span class="variable">$&lt;</span> -serial null"</span> </span><br><span class="line"><span class="variable">$(V)</span>sleep 2</span><br><span class="line"><span class="variable">$(V)</span><span class="variable">$(TERMINAL)</span> -e <span class="string">"gdb -q -tui -x tools/gdbinit"</span></span><br></pre></td></tr></table></figure></li><li><p>在 lab1 目录下执行 make debug 后再查看 q.log 文件：</p></li></ul><p>&emsp;&emsp;&emsp;<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-010.png"  alt=""> </p><p>&emsp;&emsp;&emsp;<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-011.png"  alt=""> </p><p>&emsp;&emsp;&emsp;<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-012.png"  alt=""> </p><p>&emsp;&emsp;&emsp;<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-013.png"  alt=""> </p><p>&emsp;&emsp;&emsp;<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-014.png"  alt=""> </p><p>&emsp;&emsp;&emsp;<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/lab1-015.png"  alt=""> </p><p>&emsp;&emsp;&emsp;与 bootasm.S 和 bootblock.asm 比较可知一致。<br/></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理的知识集合</title>
      <link href="/2020/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾"><a href="#因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾" class="headerlink" title="因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾"></a>因为做作业需要查阅，也为了日后再学习，记录一些拓展内容🐾</h3><p><a href="https://cloud.tencent.com/developer/article/1499667" target="_blank" rel="noopener">彻底解决分布式系统一致性问题整理(下)</a><br><a href="https://www.cnblogs.com/liangdejiu/articles/11255201.html" target="_blank" rel="noopener">分布式系统如何保证数据一致性</a><br><a href="https://www.cnblogs.com/snow826520/p/8574824.html" target="_blank" rel="noopener">CPU中的cache结构以及cache一致性</a><br><a href="https://wenku.baidu.com/view/10de194fe518964bcf847c3b.html" target="_blank" rel="noopener">内存/存储保护的重要性及实现</a><br><a href="https://www.sohu.com/a/326903100_652662" target="_blank" rel="noopener">集群与分布式的区别</a><br><a href="https://blog.csdn.net/Patrick_Xie/article/details/79515340" target="_blank" rel="noopener">操作系统概述及各类操作系统特点</a><br><a href="https://www.cnblogs.com/gxl666/p/11155528.html" target="_blank" rel="noopener">操作系统的四大基本特征</a><br><a href="https://www.cnblogs.com/suyuan1573/p/3971574.html" target="_blank" rel="noopener">批处理、分时、实时各个操作系统特点</a><br><a href="https://blog.csdn.net/sexyluna/article/details/88851414" target="_blank" rel="noopener">分布式操作系统入门</a></p><p><a href="http://c.biancheng.net/view/1264.html" target="_blank" rel="noopener">连续内存分配及其方式详解</a><br><a href="https://www.cnblogs.com/sjlove/archive/2013/06/05/3119683.html" target="_blank" rel="noopener">外部碎片和内部碎片的区别</a><br><a href="https://www.cnblogs.com/lightmare/p/10398835.html" target="_blank" rel="noopener">C编译器、链接器、加载器详解</a><br><a href="https://blog.csdn.net/shang_0122/article/details/100605717" target="_blank" rel="noopener">操作系统——内存管理之内存分配（分页，分段，段页）</a><br><a href="https://blog.csdn.net/weixin_40539125/article/details/90734973" target="_blank" rel="noopener">编译过程中链接器的作用</a><br><a href="https://www.cnblogs.com/axing-articles/p/11409998.html" target="_blank" rel="noopener">分段、分页&amp;&amp;内存碎片、外存碎片</a><br><a href="https://www.pianshen.com/article/8728468314/" target="_blank" rel="noopener">操作系统概念复习</a><br><a href="http://c.biancheng.net/view/1269.html" target="_blank" rel="noopener">页表结构完全攻略</a></p><p><a href="https://blog.csdn.net/ajian005/article/details/18370511" target="_blank" rel="noopener">操作系统基础知识之进程管理</a><br><a href="https://blog.csdn.net/liujinen_/article/details/78974275" target="_blank" rel="noopener">同一进程中的线程究竟共享哪些资源</a></p><p><a href="https://zhuanlan.zhihu.com/p/96837860" target="_blank" rel="noopener">CPU调度算法</a><br><a href="https://blog.csdn.net/qq_19018277/article/details/98738492" target="_blank" rel="noopener">操作系统之调度算法评价指标 (十二) —- 利用率、系统吞吐量、周转时间、等待时间、响应时间…</a></p><p><a href="https://www.cnblogs.com/lqerio/p/11117663.html" target="_blank" rel="noopener">信号量解决理发师问题</a><br><a href="https://zhidao.baidu.com/question/2117056499260142027.html" target="_blank" rel="noopener">TestAndSet()解决硬体同步的原理</a><br><a href="https://www.cnblogs.com/niuyourou/p/12004183.html" target="_blank" rel="noopener">从哲学家就餐问题彻底认识死锁</a><br><a href="https://www.jianshu.com/p/99f10708b1e1" target="_blank" rel="noopener">哲学家就餐问题与死锁总结</a></p><p><a href="https://www.cnblogs.com/iBinary/p/8307728.html" target="_blank" rel="noopener">内核知识第八讲：PDE,PTE,页目录表,页表的内存管理</a><br><a href="https://elixir.bootlin.com/linux/v5.8-rc4/source/include/linux/list.h" target="_blank" rel="noopener">linux内核函数库list.h官方文档</a></p><p><a href="https://xueqiu.com/9217191040/128243323" target="_blank" rel="noopener">流处理系统正确性基石：ExactlyOnce的设计和实现</a></p><p><a href="https://blog.csdn.net/wangdd_199326/article/details/76180514" target="_blank" rel="noopener">Linux下fork函数及pthread函数的总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2020/06/20/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2020/06/20/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="#1171">soj 1171 —The Game of Efil</a><br><a href="#1014">soj 1014 —Specialized Four-Dig</a><br><a href="#1709">soj 1709 —PropBot</a><br><a href="#1108">soj 1108 —Online Selection</a><br><a href="#1471">soj 1471 —No Left Turns</a><br><a href="#1710">soj 1710 —Painted Calculator</a><br><a href="#7144">soj 7144 —Different Triangles</a></p><hr><p>⭐⭐<a name="1171"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1171 --The Game of Efil</span><br><span class="line">题目：细胞生命游戏在一个矩形的单元格场上进行，每个单元格都有八个邻居（相邻的单元格）。一个单元只有被占用和不被占用两种状态。从上一代产生一代的规则是：</span><br><span class="line">· 如果一个被占用的小区有0、1、4、5、6、7或8个被占用的邻居，则该生物死亡（0、1：孤独； 4至8：过度拥挤）。</span><br><span class="line">· 如果一个被占用的细胞有两个或三个被占用的邻居，则该生物可以存活到下一个世代。</span><br><span class="line">· 如果一个未被占用的小区具有三个被占用的邻居，则该小区将被占用（即产生下一代）。</span><br><span class="line">给定一个初始配置，它可以有多少种父配置？</span><br></pre></td></tr></table></figure><br>因为问题规模限制比较小，所以可以直接使用暴力枚举所有可能状态，通过深度优先搜索每次得到一种状态，再根据题目给出的规则计算得到该状态的子状态，将子状态与当前状态比较，如果完全一致，则该状态是当前状态的祖先之一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define DIRECTION 8</span><br><span class="line">#define SIZE 16</span><br><span class="line">int row, col, ancestors;</span><br><span class="line">int cells[SIZE][SIZE];</span><br><span class="line">int search[SIZE][SIZE];</span><br><span class="line">int to_x[DIRECTION] &#x3D; &#123; -1,0,1,-1,1,-1,0,1 &#125;;</span><br><span class="line">int to_y[DIRECTION] &#x3D; &#123; -1,-1,-1,0,0,1,1,1 &#125;;</span><br><span class="line">void calculate() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; row; ++i) &#123;</span><br><span class="line">for (int j &#x3D; 0; j &lt; col; ++j) &#123;</span><br><span class="line">int neighbors &#x3D; 0;</span><br><span class="line">for (int k &#x3D; 0; k &lt; DIRECTION; ++k) &#123;</span><br><span class="line">if (search[(i + to_x[k] + row) % row][(j + to_y[k] + col) % col] &#x3D;&#x3D; 1)</span><br><span class="line">++neighbors;</span><br><span class="line">&#125;</span><br><span class="line">int cell;</span><br><span class="line">if (neighbors &#x3D;&#x3D; 3 || (search[i][j] &#x3D;&#x3D; 1 &amp;&amp; (neighbors &#x3D;&#x3D; 2 || neighbors &#x3D;&#x3D; 3)))</span><br><span class="line">cell &#x3D; 1;</span><br><span class="line">elsecell &#x3D; 0;</span><br><span class="line">if (cells[i][j] !&#x3D; cell)return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++ancestors;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x, int y) &#123;</span><br><span class="line">if (x &#x3D;&#x3D; row)calculate();</span><br><span class="line">else &#123;</span><br><span class="line">search[x][y] &#x3D; 0;</span><br><span class="line">if (y &#x3D;&#x3D; col - 1)dfs(x + 1, 0);</span><br><span class="line">elsedfs(x, y + 1);</span><br><span class="line">search[x][y] &#x3D; 1;</span><br><span class="line">if (y &#x3D;&#x3D; col - 1)dfs(x + 1, 0);</span><br><span class="line">elsedfs(x, y + 1);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int count &#x3D; 1;</span><br><span class="line">while (cin &gt;&gt; row &gt;&gt; col &amp;&amp; row &amp;&amp; col) &#123;</span><br><span class="line">int k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">int x, y;</span><br><span class="line">memset(cells, 0, sizeof(cells));</span><br><span class="line">while (k--) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cells[x][y] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ancestors &#x3D; 0;</span><br><span class="line">memset(search, 0, sizeof(search));</span><br><span class="line">dfs(0, 0);</span><br><span class="line">if (ancestors)</span><br><span class="line">cout &lt;&lt; &quot;Case &quot; &lt;&lt; count &lt;&lt; &quot;: &quot; &lt;&lt; ancestors &lt;&lt; &quot; possible ancestors.&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">cout &lt;&lt; &quot;Case &quot; &lt;&lt; count &lt;&lt; &quot;: Garden of Eden.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id=""><a href="#" class="headerlink" title=""></a><br/></h2><p>⭐⭐<a name="1014"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1014 --Specialized Four-Dig</span><br><span class="line">题目：查找并列出所有以十进制表示法表示的符合以下规则的四位数字：该四位数的和等于其以十六进制表示时的数字之和，且以十二进制表示时也等于其数字的总和。</span><br></pre></td></tr></table></figure><br>由于题目限制四位数并提示第一个数为2992，故直接对2992~9999的每个数分别计算它们的十进制、十二进制和十六进制各个数字之和并进行比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int cal(int cur, int index) &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 4; ++i) &#123;</span><br><span class="line">sum +&#x3D; (cur % index);</span><br><span class="line">cur &#x2F;&#x3D; index;</span><br><span class="line">if (cur &#x3D;&#x3D; 0)break;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool judge(int num) &#123;</span><br><span class="line">int temp &#x3D; num;</span><br><span class="line">int sum10 &#x3D; cal(num, 10), sum12 &#x3D; cal(num, 12), sum16 &#x3D; cal(num, 16);</span><br><span class="line">return (sum10 &#x3D;&#x3D; sum12) &amp;&amp; (sum12 &#x3D;&#x3D; sum16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">for (int i &#x3D; 2992; i &lt; 10000; ++i) &#123;</span><br><span class="line">if (judge(i))cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><br/></h2><p>⭐⭐<a name="1709"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1709 --PropBot</span><br><span class="line">题目：PropBot只能做出两个不同的动作：向前移动10厘米，或向右旋转45度。这些单个动作中的每个动作都花费一秒钟的时间。</span><br><span class="line">给定平面上一点的坐标和可以用来移动的最大秒数，求PropBot与目标点在给定时间内可以达到的最近距离。开始时PropBot位于原点并指向 +x 方向。</span><br></pre></td></tr></table></figure><br>题目要求的输出看上去似乎是求解最短路径，实际上如果不遍历所有可能解的话并不能确定这个最小量，因为Propbot最终能到达的点并不是已知的确定点，而是以终点为中心的一定范围内的点，只有遍历所有的可能性才能确定最接近终点的点集。因此，选用深度优先搜索更合适。<br>具体做法是每走到一个点都考虑直走和右转45度以达到下一个点的情况，在搜索过程中更新达到目标点的最小距离，直到所有可能路径的终点都无法再靠近目标点（剩余时间为零或者行动一步的距离超过了当前点到目标点的直线距离）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double MUL &#x3D; sqrt(2) &#x2F; 2;</span><br><span class="line">int seconds;</span><br><span class="line">double x, y, min_dis;</span><br><span class="line">struct Node &#123;</span><br><span class="line">double x, y;</span><br><span class="line">Node() &#123;</span><br><span class="line">x &#x3D; y &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">Node(double X, double Y) &#123;</span><br><span class="line">x &#x3D; X;</span><br><span class="line">y &#x3D; Y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node target;</span><br><span class="line"></span><br><span class="line">double dis(Node n1, Node n2) &#123;</span><br><span class="line">return sqrt((n1.x - n2.x) * (n1.x - n2.x) + (n1.y - n2.y) * (n1.y - n2.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(Node cur, int dir, int time) &#123;&#x2F;&#x2F;dir: 0 presents +x and rotate clockwise.</span><br><span class="line">double temp &#x3D; dis(cur, target);</span><br><span class="line">dir %&#x3D; 8;</span><br><span class="line">min_dis &#x3D; min(min_dis, temp);</span><br><span class="line">if (time &#x3D;&#x3D; seconds) return;</span><br><span class="line">if (temp - 10 * (seconds - time) &gt; min_dis) return;</span><br><span class="line">switch (dir)&#123;</span><br><span class="line">case 0:</span><br><span class="line">dfs(Node(cur.x + 10, cur.y), 0, time + 1);</span><br><span class="line">break;</span><br><span class="line">case 1:</span><br><span class="line">dfs(Node(cur.x + MUL * 10, cur.y - MUL * 10), 1, time + 1);</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">dfs(Node(cur.x, cur.y - 10), 2, time + 1);</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">dfs(Node(cur.x - MUL * 10, cur.y - MUL * 10), 3, time + 1);</span><br><span class="line">break;</span><br><span class="line">case 4:</span><br><span class="line">dfs(Node(cur.x - 10, cur.y), 4, time + 1);</span><br><span class="line">break;</span><br><span class="line">case 5:</span><br><span class="line">dfs(Node(cur.x - MUL * 10, cur.y + MUL * 10), 5, time + 1);</span><br><span class="line">break;</span><br><span class="line">case 6:</span><br><span class="line">dfs(Node(cur.x, cur.y + 10), 6, time + 1);</span><br><span class="line">break;</span><br><span class="line">case 7:</span><br><span class="line">dfs(Node(cur.x + MUL * 10, cur.y + MUL * 10), 7, time + 1);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">dfs(cur, dir + 1, time + 1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int cases;</span><br><span class="line">cin &gt;&gt; cases;</span><br><span class="line">while (cases--) &#123;</span><br><span class="line">cin &gt;&gt; seconds &gt;&gt; x &gt;&gt; y;</span><br><span class="line">target &#x3D; Node(x, y);</span><br><span class="line">Node start(0, 0);</span><br><span class="line">min_dis &#x3D; dis(start, target);</span><br><span class="line">dfs(start, 0, 0);</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; min_dis &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><br/></h2><p>⭐⭐<a name="1108"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1108 --Online Selection</span><br><span class="line">题目：节目组有0到n-1共n组问题，每组问题的答案相同，并且每个问题的答案只有0、1两种。一开始参与者的状态是0，拥有0分。在状态i的参与者被给出第i组中的一个问题，如果参与者答对问题，那么分数加1。另外如果参与者回答的是0，状态i就会转移到状态i0，回答的是1，则转移到状态i1。</span><br><span class="line">给定第i组的问题的答案，以及i0和i1，并且已知这个过程持续了k轮，选手得到了m分，求在这个过程中，选手回答0的次数最多的情况。</span><br></pre></td></tr></table></figure><br>用dp[i][j][m]表示当当前状态为i、已响应次数为j、当前得分为m时“0”响应总数的最大值。在互动过程中，候选人的状态、得分和“0”响应总数始终依赖于上一次互动的情况，那么可以考虑从初始状态开始每次都向状态i0和i1进行记忆化搜索。状态转移方程如下：</p><script type="math/tex; mode=display">\left\{\begin{array}{lr}dp[i0[j]][i + 1][k + 1] = max(dp[i0[j]][i + 1][k + 1],dp[j][i][k] + 1) & \\& {ans[j] = 0} & \\dp[i1[j]][i + 1][k] = max⁡(dp[i1[j]][i + 1][k],dp[j][i][k]) & \\\end{array}\right.</script><script type="math/tex; mode=display">\left\{\begin{array}{lr}dp[i0[j]][i + 1][k] = max(dp[i0[j]][i + 1][k],dp[j][i][k] + 1) & \\& {ans[j] = 1} & \\dp[i1[j]][i + 1][k + 1] = max(dp[i1[j]][i + 1][k + 1],dp[j][i][k]) & \\\end{array}\right.</script><p>边界条件：</p><script type="math/tex; mode=display">\left\{\begin{array}{lr}dp[i0[0]][1][1] = 1 & \\& {ans[0] = 0} & \\dp[i1[0]][1][0] = 0 & \\\end{array}\right.</script><script type="math/tex; mode=display">\left\{\begin{array}{lr}dp[i0[0]][1][0] = 1 & \\& {ans[0] = 1} & \\dp[i1[0]][1][1] = 0 & \\\end{array}\right.</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define SIZE 35</span><br><span class="line">int i0[SIZE], i1[SIZE], ans[SIZE];</span><br><span class="line">int dp[SIZE][SIZE][SIZE];&#x2F;&#x2F;表示当前的状态; 已经进行的轮数; 当前获得的分数</span><br><span class="line">int main() &#123;</span><br><span class="line">int cases, n, res_limit, total_score;</span><br><span class="line">while (cin &gt;&gt; cases &amp;&amp; cases) &#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; res_limit &gt;&gt; total_score;</span><br><span class="line">memset(dp, -1, sizeof(dp));</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; i0[i] &gt;&gt; i1[i] &gt;&gt; ans[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[0][0][0] &#x3D; 0;</span><br><span class="line">if (ans[0] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">dp[i0[0]][1][1] &#x3D; 1;</span><br><span class="line">dp[i1[0]][1][0] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">if (ans[0] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">dp[i0[0]][1][0] &#x3D; 1;</span><br><span class="line">dp[i1[0]][1][1] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; res_limit; ++i) &#123;&#x2F;&#x2F;games</span><br><span class="line">for (int j &#x3D; 0; j &lt; n; ++j) &#123;&#x2F;&#x2F;status</span><br><span class="line">for (int k &#x3D; 0; k &lt;&#x3D; total_score; ++k) &#123;&#x2F;&#x2F;scores</span><br><span class="line">if (dp[j][i][k] !&#x3D; -1) &#123;</span><br><span class="line">if (ans[j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">dp[i0[j]][i + 1][k + 1] &#x3D; max(dp[i0[j]][i + 1][k + 1], dp[j][i][k] + 1);</span><br><span class="line">dp[i1[j]][i + 1][k] &#x3D; max(dp[i1[j]][i + 1][k], dp[j][i][k]);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">dp[i0[j]][i + 1][k] &#x3D; max(dp[i0[j]][i + 1][k], dp[j][i][k] + 1);</span><br><span class="line">dp[i1[j]][i + 1][k + 1] &#x3D; max(dp[i1[j]][i + 1][k + 1], dp[j][i][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int result &#x3D; -1;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">result &#x3D; max(result, dp[i][res_limit][total_score]);</span><br><span class="line">cout &lt;&lt; cases &lt;&lt; &quot; &quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><br/></h2><p>⭐⭐<a name="1471"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1471 --No Left Turns</span><br><span class="line">题目：一个迷宫，从起点走到终点，每一步有直走和直走再右转两个选择（注意不能原地转弯），问在这种情况下的最短路径是多少。已知起始方向可以任意选择，且保证这样的路径一定存在。</span><br></pre></td></tr></table></figure><br>当尝试向不同方向前进时，若条件满足（朝向正确、不碰墙壁），则每前进一步，路径长度加1。基于上述设定，应该选择广度优先搜索。初始时将起点位置满需条件的不同朝向的状态送入队列，搜索过程中考虑朝向不变和右转两种情况，首次搜索到终点的路径即是最短路径。要注意输入的字符有空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define SIZE 20</span><br><span class="line">#define DIRECTION 4</span><br><span class="line"></span><br><span class="line">int row, column;</span><br><span class="line">int start_x , start_y;</span><br><span class="line">char puzzle[SIZE][SIZE];</span><br><span class="line">int to_x[DIRECTION] &#x3D; &#123;0, -1, 0, 1&#125;;</span><br><span class="line">int to_y[DIRECTION] &#x3D; &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">int dis[SIZE][SIZE][DIRECTION];&#x2F;&#x2F;N W S E</span><br><span class="line">int visit[SIZE][SIZE][DIRECTION];</span><br><span class="line">struct Node &#123;</span><br><span class="line">int x, y, d;</span><br><span class="line">Node() &#123;</span><br><span class="line">x &#x3D; y &#x3D; d &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">Node(int X, int Y, int D) &#123;</span><br><span class="line">x &#x3D; X;</span><br><span class="line">y &#x3D; Y;</span><br><span class="line">d &#x3D; D;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int bfs() &#123;</span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 4; ++i) &#123;</span><br><span class="line">if (puzzle[start_x + to_x[i]][start_y + to_y[i]] !&#x3D; &#39;X&#39;) &#123;</span><br><span class="line">Node temp(start_x, start_y, i);</span><br><span class="line">q.push(temp);</span><br><span class="line">dis[temp.x][temp.y][temp.d] &#x3D; 0;</span><br><span class="line">visit[temp.x][temp.y][temp.d] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">Node temp &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">Node next;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 2; ++i) &#123;</span><br><span class="line">if (i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">next.d &#x3D; temp.d;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">next.d &#x3D; (temp.d + 1) % 4;</span><br><span class="line">&#125; </span><br><span class="line">int next_x &#x3D; temp.x + to_x[next.d];</span><br><span class="line">int next_y &#x3D; temp.y + to_y[next.d];</span><br><span class="line">if (next_x &gt;&#x3D; 0 &amp;&amp; next_x &lt; row &amp;&amp; next_y &gt;&#x3D; 0 &amp;&amp; next_y &lt; column) &#123;</span><br><span class="line">if (puzzle[next_x][next_y] !&#x3D; &#39;X&#39; &amp;&amp; (!visit[next_x][next_y][next.d])) &#123;</span><br><span class="line">if (puzzle[next_x][next_y] &#x3D;&#x3D; &#39;F&#39;)return dis[temp.x][temp.y][temp.d] + 1;</span><br><span class="line">visit[next_x][next_y][next.d] &#x3D; 1;</span><br><span class="line">dis[next_x][next_y][next.d] &#x3D; dis[temp.x][temp.y][temp.d] + 1;</span><br><span class="line">next.x &#x3D; next_x;</span><br><span class="line">next.y &#x3D; next_y;</span><br><span class="line">q.push(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int N;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line">while (N--) &#123;</span><br><span class="line">cin &gt;&gt; row &gt;&gt; column;</span><br><span class="line">for (int i &#x3D; 0; i &lt; row; ++i) &#123;</span><br><span class="line">getchar();</span><br><span class="line">for (int j &#x3D; 0; j &lt; column; ++j) &#123;</span><br><span class="line">cin.get(puzzle[i][j]);</span><br><span class="line">if (puzzle[i][j] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line">start_x &#x3D; i;</span><br><span class="line">start_y &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(dis, -1, sizeof(dis));</span><br><span class="line">memset(visit, 0, sizeof(visit));</span><br><span class="line">cout &lt;&lt; bfs() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><br/></h2><p>⭐⭐<a name="1710"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1710 --Painted Calculator</span><br><span class="line">题目：计算器中，一个数的一个译码管亮起需要消耗5毫安，如果是负数的话，那个负号需要单独消耗5毫安。已知运用这个计算器进行了一个四则运算(a ? b &#x3D; c形式，且如果所做的运算是除法则b不为0)，得到每个数的功耗，问一共有多少个这样的运算满足条件。已知每个数绝对值都小于1000。</span><br></pre></td></tr></table></figure><br>对每一项输入，暴力搜索匹配的数字组合，并枚举四则运算进行验证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int MA[10] &#x3D; &#123;30, 10, 25, 25, 20, 25, 30, 15, 35, 30&#125;;&#x2F;&#x2F; 0 - 9</span><br><span class="line"></span><br><span class="line">int getMA(int num) &#123;</span><br><span class="line">int res &#x3D; 0;</span><br><span class="line">if (num &#x3D;&#x3D; 0) return MA[0];</span><br><span class="line">if (num &lt; 0)res +&#x3D; 5;</span><br><span class="line">num &#x3D; abs(num);</span><br><span class="line">while (num) &#123;</span><br><span class="line">res +&#x3D; MA[num % 10];</span><br><span class="line">num &#x2F;&#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">while (cin &gt;&gt; x &amp;&amp; x) &#123;</span><br><span class="line">cin &gt;&gt; y &gt;&gt; z;</span><br><span class="line">if ((x &gt; 110 || y &gt; 110 || z &gt; 110) || (x % 5 !&#x3D; 0 || y % 5 !&#x3D; 0 || z % 5 !&#x3D; 0)) &#123;</span><br><span class="line">cout &lt;&lt; &quot;0 solutions for &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">for (int i &#x3D; -999; i &lt;&#x3D; 999; ++i) &#123;</span><br><span class="line">int X &#x3D; getMA(i);</span><br><span class="line">if (X !&#x3D; x)continue;</span><br><span class="line">for (int j &#x3D; -999; j &lt;&#x3D; 999; ++j) &#123;</span><br><span class="line">int Y &#x3D; getMA(j);</span><br><span class="line">if (Y !&#x3D; y)continue;</span><br><span class="line">int Z;</span><br><span class="line">if (i + j &gt;&#x3D; -999 &amp;&amp; i + j &lt;&#x3D; 999) &#123;</span><br><span class="line">Z &#x3D; getMA(i + j);</span><br><span class="line">if (Z &#x3D;&#x3D; z)++count;</span><br><span class="line">&#125;</span><br><span class="line">if (i - j &gt;&#x3D; -999 &amp;&amp; i - j &lt;&#x3D; 999) &#123;</span><br><span class="line">Z &#x3D; getMA(i - j);</span><br><span class="line">if (Z &#x3D;&#x3D; z)++count;</span><br><span class="line">&#125;</span><br><span class="line">if (i * j &gt;&#x3D; -999 &amp;&amp; i * j &lt;&#x3D; 999) &#123;</span><br><span class="line">Z &#x3D; getMA(i * j);</span><br><span class="line">if (Z &#x3D;&#x3D; z)++count;</span><br><span class="line">&#125;</span><br><span class="line">if (j &#x3D;&#x3D; 0)continue;</span><br><span class="line">if (i &#x2F; j &gt;&#x3D; -999 &amp;&amp; i &#x2F; j &lt;&#x3D; 999) &#123;</span><br><span class="line">Z &#x3D; getMA(i &#x2F; j);</span><br><span class="line">if (Z &#x3D;&#x3D; z)++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (count &#x3D;&#x3D; 1)cout &lt;&lt; &quot;1 solution for &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; count &lt;&lt; &quot; solutions for &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><br/></h2><p>⭐⭐<a name="7144"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 7144 --Different Triangles</span><br><span class="line">题目：给出n根棍子的长度(n&lt;&#x3D;100)，求出用其中的三根棍子可以摆出的三角形的个数。</span><br></pre></td></tr></table></figure><br>问题规模较小，直接使用枚举，对sticks数组排序可以适当减少循环次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int cases;</span><br><span class="line">cin &gt;&gt; cases;</span><br><span class="line">while (cases--) &#123;</span><br><span class="line">int num, sticks[101];</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">for (int i &#x3D; 0; i &lt; num; ++i) &#123;</span><br><span class="line">cin &gt;&gt; sticks[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(sticks, sticks + num);</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; num; ++i) &#123;</span><br><span class="line">for (int j &#x3D; i + 1; j &lt; num; ++j) &#123;</span><br><span class="line">for (int k &#x3D; j + 1; k &lt; num; ++k) &#123;</span><br><span class="line">if (sticks[k] &gt;&#x3D; sticks[i] + sticks[j])break;</span><br><span class="line">else ++sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br/></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨交换机VLAN通信（资料）</title>
      <link href="/2020/06/09/%E8%B7%A8%E4%BA%A4%E6%8D%A2%E6%9C%BAVLAN%E9%80%9A%E4%BF%A1%EF%BC%88%E8%B5%84%E6%96%99%EF%BC%89/"/>
      <url>/2020/06/09/%E8%B7%A8%E4%BA%A4%E6%8D%A2%E6%9C%BAVLAN%E9%80%9A%E4%BF%A1%EF%BC%88%E8%B5%84%E6%96%99%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="跨交换机实现VLAN的相关资料。"><a href="#跨交换机实现VLAN的相关资料。" class="headerlink" title="跨交换机实现VLAN的相关资料。"></a>跨交换机实现VLAN的相关资料。</h4><p><strong>·</strong> <a href="https://wenku.baidu.com/view/ea05cf943b3567ec112d8a12.html" target="_blank" rel="noopener">思科交换机接口的三种模式</a><br><strong>·</strong> <a href="https://www.cnblogs.com/qiyeboy/p/5930573.html" target="_blank" rel="noopener">交换机地址表与MAC泛洪攻击</a><br><strong>·</strong> <a href="https://max.book118.com/html/2019/0128/8076051051002004.shtm" target="_blank" rel="noopener">前人的参考报告</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划（二）</title>
      <link href="/2020/05/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/05/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="#1121">soj 1121 —Tri Tiling</a><br><a href="#1264">soj 1264 —Atomic Car Race</a><br><a href="#1828">soj 1828 —Minimal</a><br><a href="#1527">soj 1527 —Tiling a Grid With Dominoes</a><br><a href="#1148">soj 1148 —过河</a><br><a href="#1163">soj 1163 —Tour</a><br><a href="#1345">soj 1345 —能量项链</a><br><a href="#1687">soj 1687 —Permutation</a></p><hr><p>⭐⭐⭐⭐<a name="1121"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1121 --Tri Tiling</span><br><span class="line">题目：用1*2的长方形铺满3*n的长方形，有多少种方法？（如下图）</span><br></pre></td></tr></table></figure><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.9/image/1121-0.png"  alt=""><br/><br>初始状态，n=2时，可以平铺出矩形（3种情况）和非矩形（2种情况），如下图所示。<br/><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.1/image/1121-1.png"  alt=""><br/><br/><br><strong>题解一</strong>：用f[i]表示铺满3 <em> (2i)的长方形的方案数，用g[i]表示铺满3 </em> (2i)的长方形，并且向后伸展出部分形状的方案数。则有：</p><ul><li>f[i]=3 * f[i-1]+g[i-1]</li></ul><p>3 <em> f[i-1]即在f[i-1]的基础上要加上恰好的3 </em> 2矩形才能构成f[i]，而3 * 2矩形有3种情况（如上图）；g[i-1]即对于每一种非矩形都只有一种方式可以填补其使之恰为矩形。</p><ul><li>g[i]=2 * f[i-1]+g[i-1]</li></ul><p>2 * f[i-1]即在f[i-1]的基础上要加上2种非矩形之一才能构成g[i]；g[i-1]即对于每一种非矩形都只有一种方式可以填补其使之恰为非矩形。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 32;</span><br><span class="line">int f[maxn], g[maxn];</span><br><span class="line"></span><br><span class="line">int dp(int n) &#123;</span><br><span class="line">if (n % 2 &#x3D;&#x3D; 1)return 0;</span><br><span class="line">if (n &#x3D;&#x3D; 0)return f[0] &#x3D; 1;</span><br><span class="line">f[1] &#x3D; 3;</span><br><span class="line">g[1] &#x3D; 2;</span><br><span class="line">int tmp &#x3D; n &#x2F; 2;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; tmp; ++i) &#123;</span><br><span class="line">f[i]&#x3D;3*f[i-1]+g[i-1];</span><br><span class="line">g[i]&#x3D;2*f[i-1]+g[i-1];</span><br><span class="line">&#125;</span><br><span class="line">return f[tmp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (cin &gt;&gt; n &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">cout &lt;&lt; dp(n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br/></p><p><strong>题解二：数学规律推算法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">要使3*n是一个矩形，有两种可能:</span><br><span class="line">    1. 3*(n-2)也是一个矩形，那么只要再拼上一个3*2的就可以了。这个3*2有3种情况,所以是3*f(n-2);</span><br><span class="line"></span><br><span class="line">    2. 3*(n-2)不是一个矩形，这种情况下，你只有一种添加2*1块的方法使得3*n是矩形，还需要对3*(n-4)的形状做判断：</span><br><span class="line"></span><br><span class="line">        1. 3*(n-4)是一个矩形，那么只要再拼一个L形或者倒L形就可以使得3*(n-2)不是矩形了，这里就是2*f(n-4);</span><br><span class="line"></span><br><span class="line">        2. 3*(n-4)不是一个矩形，那么也是只有一种添加2*1块的方法能使3*(n-2)不是矩形，接下来就来考虑3*(n-6)：</span><br><span class="line"></span><br><span class="line">             1. 3*(n-6)是一个矩形，那么只要再拼一个L形或者倒L形就可以使得3*(n-4)不是矩形了，这里就是2*f(n-6);</span><br><span class="line"></span><br><span class="line">             2. 3*(n-6)不是一个矩形，……</span><br></pre></td></tr></table></figure><br>综上，可以得到递推式：<strong>f(n) = 3 <em> f(n-2) + 2 </em> f(n-4) + 2 <em> f(n-6) + … + 2 </em> f(0)</strong>，其中初始值<strong>f(0)=1</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 30;</span><br><span class="line">int f[maxn] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int dp(int n) &#123;</span><br><span class="line">if (n % 2 &#x3D;&#x3D; 1)return 0;</span><br><span class="line">if (n &#x3D;&#x3D; 0)return f[0] &#x3D; 1;</span><br><span class="line">if (n &#x3D;&#x3D; 2)return f[2] &#x3D; 3;</span><br><span class="line">if (f[n] !&#x3D; 0)return f[n];</span><br><span class="line">f[n] +&#x3D; 3 * dp(n - 2);</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; n&#x2F;2; ++i) &#123;</span><br><span class="line">f[n] +&#x3D; 2 * dp(n - 2 * i);</span><br><span class="line">&#125;</span><br><span class="line">return f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (cin &gt;&gt; n &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">cout &lt;&lt; dp(n) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>⭐⭐⭐⭐⭐<a name="1264"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1264 --Atomic Car Race</span><br><span class="line">题目：在一次赛车比赛中，共有n个检查点，在每个检查点可以选择是否更换轮胎，更换轮胎需要花费b秒。在一次更换轮胎之后，赛车的速度先增加（轮胎变热），后减少（轮胎损坏），每公里行驶需要的时间可以表达为（x为当前检查点与最近一次更换轮胎的检查点的距离，从x公里跑到x+1公里）：</span><br><span class="line">1&#x2F;(v - e * (x - r)) (if x &gt;&#x3D; r)</span><br><span class="line">1&#x2F;(v - f * (r - x)) (if x &lt; r)</span><br><span class="line">求从起点到终点需要耗费的最少时间。</span><br><span class="line">限制：</span><br><span class="line">· 0 &lt; n &lt;&#x3D; 100</span><br><span class="line">· 0 &lt;&#x3D; r &lt;&#x3D; an-1</span><br><span class="line">· 0 &lt; a1 &lt; a2 &lt; … &lt; an &lt;&#x3D; 10000</span><br><span class="line">· v – e * (x - r)&gt;&#x3D;0.01</span><br><span class="line">· v - f * r &gt;&#x3D; 0.01</span><br></pre></td></tr></table></figure><br>好难啊…总是不容易想到用辅助数组的。<br/>这里主要维护两个数组，先看辅助数组 <strong>cost[k]</strong> (0 &lt;= k &lt;= a<sub>n</sub>)，<strong>抛开对最优解的思考</strong>，它表示距离上一次换轮胎已连续行驶了 k 公里耗费的总时间，由于换轮胎之后的用时与换之前的状态无关，所以我们可以推出：<br/></p><ul><li>cost[0] = 0</li><li>cost[k] = cost[k-1] + T(k-1)</li></ul><p>其中，T(k-1)表示更换轮胎后从第 k-1 公里处行驶至第 k 公里处消耗的时间，由题目可知</p><ul><li>当 k &lt; r 时，T(k-1) = 1 / (v - f * (r - (k - 1)))</li><li>当 k &gt;= r 时，T(k-1) = 1 / (v - e * ((k - 1) - r))</li></ul><p>接下来我们思考要求解的问题。用数组 <strong>dp[i]</strong> 表示<strong>从起点到达第 i 个检查点所用的最短时间</strong>。<br/>对于一个最优解，<strong>假设</strong>在这个最优解中行驶到<strong>第 j 个检查点</strong>完成了<strong>最后一次换轮胎</strong>,则有 dp[n] = dp[j] + cost[a<sub>n</sub> - a<sub>j</sub>] + b。<br/>那么dp[i]的递推式即为：<strong>dp[i] = min(dp[0] + cost[a<sub>i</sub> - a<sub>0</sub>] + b, dp[1] + cost[a<sub>i</sub> - a<sub>1</sub>] + b…dp[i-1] + cost[a<sub>i</sub> - a<sub>i-1</sub>] + b)</strong>。<br/>需要注意的是，Sicily对该题目的输出有精度要求，故使用流操作符 <strong>fixed</strong> 来使浮点输出应该以小数点表示法显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (cin &gt;&gt; n &amp;&amp; n !&#x3D; 0) &#123;</span><br><span class="line">int a[10001];</span><br><span class="line">a[0] &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double b, r, v, e, f;</span><br><span class="line">cin &gt;&gt; b &gt;&gt; r &gt;&gt; v &gt;&gt; e &gt;&gt; f;</span><br><span class="line"></span><br><span class="line">double cost[10001];</span><br><span class="line">cost[0] &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; a[n]; ++i) &#123;</span><br><span class="line">cost[i] &#x3D; i - 1 &lt; r ? cost[i - 1] + 1 &#x2F; (v - f * (r - i + 1)) : cost[i - 1] + 1 &#x2F; (v - e * (i - 1 - r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double dp[10001];</span><br><span class="line">dp[0] &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">double min_time &#x3D; dp[0] + cost[a[i]];</span><br><span class="line">for (int j &#x3D; 1; j &lt; i; ++j) &#123;</span><br><span class="line">min_time &#x3D; min(min_time, dp[j] + cost[a[i] - a[j]] + b);</span><br><span class="line">&#125;</span><br><span class="line">dp[i] &#x3D; min_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>⭐⭐⭐⭐⭐<a name="1828"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1828 --Minimal</span><br><span class="line">题目：There are two sets S1 and S2 subjecting to:</span><br><span class="line">(1) S1, S2 are both the subsets of &#123;x| x is an integer and 0 &lt; x &lt; 1,000,000&#125;</span><br><span class="line">(2) 0 &lt; |S1| &lt; |S2| &lt; 500</span><br><span class="line"> </span><br><span class="line">F(S1, S2) &#x3D; min &#123;|a1-b1| + |a2-b2| + … + |aN-bN|&#125; in which ai ∈S1, bi ∈S2, ai ≠aj if i≠j, bi ≠bj if i≠j (i, j &#x3D; 1, 2 … N，N &#x3D; |S1|)</span><br><span class="line"></span><br><span class="line">For each test case, print the result of F(S1 ,S2).</span><br></pre></td></tr></table></figure><br>最开始我的想法是，将S1和S2作笛卡尔积（定义X为两数差距），在一个二维数组里记录两两之差的绝对值，对S1每个元素都匹配以S2某个元素使得差距尽可能小。<strong>尝试了几个测例都过了，但是OJ上面WA了，这个解法个人觉得也有些牵强，无法证明，但又无法证伪😭。</strong></p><p><font color='gray'>&lt; 以下解释参考相关资料信息 &gt;</font><br>假设我们从S2中选择了某些数，假设选出的数组成S3，那么S3中最小的数肯定匹配S1中最小的数，S3中次小的数匹配S1中次小的数…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">证明：</span><br><span class="line">假设S1中有了a1,a2,S3中有b1,b2</span><br><span class="line">且a1&lt;&#x3D;a2,b1&lt;&#x3D;b2</span><br><span class="line">那么有|a1-b1|+|a2-b2|&lt;&#x3D;|a1-b2|+|a2-b1|（数学问题）</span><br><span class="line">所以从小到大一个个匹配不会更差，只会更好。</span><br></pre></td></tr></table></figure><br><strong>解法：</strong><br>对S1和S2分别从小到大排序，用f[i][j]表示S1中的前i个数，与S2中的前j个数匹配（从j个数选i个数出来），显然有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] &#x3D; inf(j &lt; i)</span><br><span class="line">f[0][0] &#x3D; 0</span><br><span class="line">f[i][j] &#x3D; min&#123;f[i-1][j-1]+|a[i]-b[j]|,f[i][j-1]&#125;,j&gt;&#x3D;i</span><br></pre></td></tr></table></figure><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define inf 1&lt;&lt;30</span><br><span class="line">const int maxn &#x3D; 501;</span><br><span class="line">int f[maxn][maxn];</span><br><span class="line">int S1[maxn], S2[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int cases;</span><br><span class="line">cin &gt;&gt; cases;</span><br><span class="line">while (cases--) &#123;</span><br><span class="line">int N, M;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">cin &gt;&gt; S1[i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; M; ++i) &#123;</span><br><span class="line">cin &gt;&gt; S2[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(S1+1, S1+N+1);</span><br><span class="line">sort(S2+1, S2+M+1);</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">for (int j &#x3D; 0; j &lt;&#x3D; M; ++j) &#123;</span><br><span class="line">if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)</span><br><span class="line">f[i][j] &#x3D; 0;</span><br><span class="line">else if (i &gt; j) &#123;</span><br><span class="line">f[i][j] &#x3D; inf;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">f[i][j] &#x3D; inf;</span><br><span class="line">if (i &gt; 0)</span><br><span class="line">f[i][j] &#x3D; min(f[i][j], f[i-1][j-1]+abs(S1[i]-S2[j]));</span><br><span class="line">if (j &gt; 0)</span><br><span class="line">f[i][j] &#x3D; min(f[i][j], f[i][j-1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[N][M] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>⭐⭐⭐⭐⭐<a name="1527"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1527 --Tiling a Grid With Dominoes</span><br><span class="line">题目：用1*2的长方形铺满4*n的长方形，有多少种方法？（如下图）</span><br></pre></td></tr></table></figure><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1527-0.png"  alt=""><br/><br>处理方式与soj 1121有些相似，但思路有所不同：<strong>用f[i][j]表示前4 * i列已经完全填满，并且第(i+1)列情况为第j种形状的方案数。</strong>其中，共有5种形状，分别是：<br/><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.1.0/image/1527-1.jpg"  alt=""><br/></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1001;</span><br><span class="line">int f[maxn][5];</span><br><span class="line"></span><br><span class="line">int dp(int N) &#123;</span><br><span class="line">f[0][0] &#x3D; f[1][0] &#x3D; f[1][1] &#x3D; f[1][3] &#x3D; f[1][4] &#x3D; 1;</span><br><span class="line">f[1][2] &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">f[i][0] &#x3D; f[i-2][0]+f[i-1][0]+f[i-1][1]+f[i-1][3]+f[i-1][4];</span><br><span class="line">f[i][1] &#x3D; f[i-1][0]+f[i-1][4];</span><br><span class="line">f[i][2] &#x3D; f[i-1][3];</span><br><span class="line">f[i][3] &#x3D; f[i-1][0]+f[i-1][2];</span><br><span class="line">f[i][4] &#x3D; f[i-1][0]+f[i-1][1];</span><br><span class="line">&#125;</span><br><span class="line">return f[N][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int cases;</span><br><span class="line">cin &gt;&gt; cases;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; cases; ++i) &#123;</span><br><span class="line">int N;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dp(N) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>⭐⭐⭐⭐⭐<a name="1148"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1148 --过河</span><br><span class="line">题目：在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0，1，……，L（其中 L 是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是 S 到 T 之间的任意正整数（包括S, T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。</span><br><span class="line">给定独木桥的长度 L，青蛙跳跃的距离范围 S、T ，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 1 &lt;&#x3D; L &lt;&#x3D; 10^9</span><br><span class="line">· 1 &lt;&#x3D; S &lt;&#x3D; T &lt;&#x3D; 10</span><br><span class="line">· 1 &lt;&#x3D; M &lt; &#x3D; 100</span><br></pre></td></tr></table></figure><br>用数组 $dp[i]$ 表示走到位置 $i$ 至少需要踩到的石子数，易得 $dp[i] = min(dp[i-j])(S &lt;= j &lt;=T)$。因为只要青蛙跳到或跳过坐标为L的点时就算已经跳出独木桥，所以最终结果落在$[dp[L], dp[L+T-1]]$的范围内。<br>本题更为关键的一点是，L 的范围比较大，直接开长度为 L 的数组几乎不可能，所以要进行状态压缩来达到节省空间的目的。从题目限制来看，S 和 T 比较小，当两个石子之间的距离相对大时，总可以从前一个石子跳到后一个石子，而中间的路程便可以舍去不计。<br>那么该压缩多少？先从最简单的想起，假如一次只能走 S 或者 T 步，从原点开始走，那么显然一定可以走到LCM(S,T)这个位置。在这种情况下，如果(0, LCM(S,T)]之间没有石子，那么(0,LCM(S,T)]就是无用的，因为它不会对答案产生任何影响，可以把这一段删去。<br>推广一下就可以知道，从点 i 开始，一次走[S, T]步，一定可以到达 i + LCM(S…T)这个点，利用这个结论，就可以对两点之间的距离进行缩短。<br>为了免去对 LCM 的计算，直接取100代替 LCM 对距离进行压缩。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int stones[102];</span><br><span class="line">int f[10200] &#x3D; &#123; 0 &#125;;</span><br><span class="line">int dp[10200];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int L, S, T, M;</span><br><span class="line">cin &gt;&gt; L &gt;&gt; S &gt;&gt; T &gt;&gt; M;</span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">if (S &#x3D;&#x3D; T) &#123;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; M; ++i) &#123;</span><br><span class="line">int temp;</span><br><span class="line">cin &gt;&gt; temp;</span><br><span class="line">if (temp % S &#x3D;&#x3D; 0)++result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">stones[0] &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; M; ++i) &#123;</span><br><span class="line">cin &gt;&gt; stones[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(stones + 1, stones + M + 1);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; M; ++i) &#123;&#x2F;&#x2F; 状态压缩</span><br><span class="line">if (stones[i] - stones[i-1] &gt; 99) &#123;</span><br><span class="line">int dis &#x3D; stones[i] - stones[i - 1] - 99;</span><br><span class="line">for (int j &#x3D; i; j &lt;&#x3D; M; ++j) &#123;</span><br><span class="line">stones[j] -&#x3D; dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[stones[i]] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[0] &#x3D; 0;&#x2F;&#x2F; 走到位置i需要踩到的最小石子数</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; stones[M] + T; ++i) &#123;</span><br><span class="line">if (i - S &lt; 0) &#123;</span><br><span class="line">dp[i] &#x3D; -1;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] &#x3D; 200;</span><br><span class="line">for (int j &#x3D; S; j &lt;&#x3D; T; ++j) &#123;</span><br><span class="line">if (i - j &gt;&#x3D; 0 &amp;&amp; dp[i - j] !&#x3D; -1)dp[i] &#x3D; min(dp[i - j], dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">if (f[i]) ++dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result &#x3D; dp[stones[M]];</span><br><span class="line">for (int i &#x3D; stones[M] + 1; i &lt;&#x3D; stones[M] + T; ++i) &#123;</span><br><span class="line">result &#x3D; min(dp[i], result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>⭐⭐⭐⭐<a name="1163"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1163 --Tour</span><br><span class="line">题目：飞行员John Doe喜欢旅行。度假时，他租了一架小飞机，开始游览美丽的地方。为了节省金钱，约翰必须确定连接他的目的地的最短封闭路线。每个目的地由平面中的一个点表示。John使用以下策略：他从最左边的点开始，然后严格地从左到右转到最右边的点，然后他严格地从右边回到起点。已知这些点具有不同的x坐标。</span><br><span class="line">给定平面中的n个点，根据John的策略计算连接这些点的最短闭合行程。</span><br></pre></td></tr></table></figure><br>显然从左到右再从右到左的并不方便思考，不如看作是“有两个人均从最左边的点出发，沿着两条不同的路径走，直到其中一个人走到了最右边的点，并且除了起点外其他每个点都恰好被一个人经过”，这样，可以用 dp[i][j] 表示两人分别走到了第 i 个点和第 j 个点后剩下的最小总路程。始终规定：i &lt; j，并且前 j 个点都已经有人经过了。可得状态转移方程：<br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/soj-1163.png"  alt=""><br>两人的次序对结果没有影响，所以 dp[j+1][j] = dp[j][j+1]，确保遵循上述规定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double dp[100][100];</span><br><span class="line">double dist[100][100];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int N;</span><br><span class="line">while (cin &gt;&gt; N) &#123;</span><br><span class="line">int points[100][2];</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">cin &gt;&gt; points[i][0] &gt;&gt; points[i][1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">for (int j &#x3D; i + 1; j &lt;&#x3D; N; ++j) &#123;</span><br><span class="line">dist[i][j] &#x3D; sqrt(pow(points[i][0] - points[j][0], 2) + pow(points[i][1] - points[j][1], 2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int j &#x3D; N; j &gt;&#x3D; 2; --j) &#123;</span><br><span class="line">for (int i &#x3D; 1; i &lt; j; ++i) &#123;</span><br><span class="line">if (j &#x3D;&#x3D; N)dp[i][j] &#x3D; dist[i][j];</span><br><span class="line">elsedp[i][j] &#x3D; min(dp[i][j + 1] + dist[j][j + 1], dp[j][j + 1] + dist[i][j + 1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; setprecision(2)&lt;&lt; dp[1][2] + dist[1][2] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>⭐⭐⭐<a name="1345"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1345 --能量项链</span><br><span class="line">题目：在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为 m*r*n（Mars单位），新产生的珠子的头标记为m，尾标记为n。</span><br><span class="line"></span><br><span class="line">需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。</span><br><span class="line"></span><br><span class="line">例如：设N&#x3D;4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号⊕表示两颗珠子的聚合操作，(j⊕k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为：</span><br><span class="line"></span><br><span class="line">(4⊕1)&#x3D;10*2*3&#x3D;60。</span><br><span class="line"></span><br><span class="line">这一串项链可以得到最优值的一个聚合顺序所释放的总能量为</span><br><span class="line"></span><br><span class="line">((4⊕1)⊕2)⊕3）&#x3D;10*2*3+10*3*5+10*5*10&#x3D;710。</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 4 &lt;&#x3D; N &lt;&#x3D; 100</span><br><span class="line">· 每个输出都是一个正整数E（E ≤ 2.1*10^9）</span><br></pre></td></tr></table></figure><br>暂时把环看成链，用 $f[i][j]$ 表示从第 $i$ 个珠子聚合到第 $j$ 个珠子所释放的总能量。易得状态转移方程：</p><script type="math/tex; mode=display">f[i][j] = \left\{\begin{array}{lcl}0 & & {i = j}\\max(f[i][k] + f[k+1][j] + energy[i][left]*energy[k][right]*energy[j][right]) & & {i \leq k < j} \\\end{array}\right.</script><p>由于项链是一个环形，聚合总可以从链的后部绕回到链的前部，所以还要考虑环的处理。<br>我的想法是对下标进行取模处理并且当聚合跨越尾部和首部时进行再分割讨论，本质上仍然是环，代码量相对另一种方法多一点。<br>官方则采用了破环为链的方法，具体做法是把链扩充到原来的两倍长，把前半部分复制到后半部分，在长度为 2 * N 的链上直接作链的思考。<br>为了代码更加可懂多创建了数组energy[][]表示珠子头尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;破环为链</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int f[202][202] &#x3D; &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int N;</span><br><span class="line">while (cin &gt;&gt; N) &#123;</span><br><span class="line">int pearl[101] &#x3D; &#123; 0 &#125;;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">cin &gt;&gt; pearl[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int energy[202][2];</span><br><span class="line">for (int i &#x3D; 1; i &lt; N; ++i) &#123;</span><br><span class="line">energy[i + N][0] &#x3D; energy[i][0] &#x3D; pearl[i];</span><br><span class="line">energy[i + N][1] &#x3D; energy[i][1] &#x3D; pearl[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">energy[N][0] &#x3D; energy[2 * N][0] &#x3D; pearl[N];</span><br><span class="line">energy[N][1] &#x3D; energy[2 * N][1] &#x3D; pearl[1];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组定义在main函数外，每次执行要重置f[][]以覆盖之前的数据，否则出错</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 2 * N; ++i) &#123;</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; 2 * N; ++j) &#123;</span><br><span class="line">f[i][j] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int len &#x3D; 2; len &lt;&#x3D; N; ++len) &#123;</span><br><span class="line">for (int start &#x3D; 1; start + len &lt;&#x3D; 2 * N; ++start) &#123;</span><br><span class="line">int end &#x3D; start + len - 1;</span><br><span class="line">for (int mid &#x3D; start; mid &lt; end; ++mid) &#123;</span><br><span class="line">f[start][end] &#x3D; max(f[start][end], f[start][mid] + f[mid + 1][end] + energy[start][0] * energy[mid][1] * energy[end][1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">result &#x3D; max(result, f[i][i + N - 1]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;非破环为链</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int f[101][101] &#x3D; &#123; 0 &#125;;</span><br><span class="line">int N;</span><br><span class="line">int energy[101][2];</span><br><span class="line"></span><br><span class="line">int dp(int start, int end) &#123;</span><br><span class="line">if (start &#x3D;&#x3D; end)return 0;</span><br><span class="line">if (f[start][end] !&#x3D; 0)return f[start][end];</span><br><span class="line">f[start][end] &#x3D; 0;</span><br><span class="line">if (start &lt; end) &#123;</span><br><span class="line">for (int k &#x3D; start; k &lt; end; ++k) &#123;</span><br><span class="line">f[start][end] &#x3D; max(f[start][end], dp(start, k) + dp(k + 1, end) + energy[start][0] * energy[k][1] * energy[end][1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">for (int k &#x3D; start; k &lt;&#x3D; N; ++k) &#123;</span><br><span class="line">f[start][end] &#x3D; max(f[start][end], dp(start, k) + dp(((k + 1) &gt; N ? k + 1 - N : k + 1), end) + energy[start][0] * energy[k][1] * energy[end][1]);</span><br><span class="line">&#125;</span><br><span class="line">for (int k &#x3D; 1; k &lt; end; ++k) &#123;</span><br><span class="line">f[start][end] &#x3D; max(f[start][end], dp(start, k) + dp(k + 1, end) + energy[start][0] * energy[k][1] * energy[end][1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[start][end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">while (cin &gt;&gt; N) &#123;</span><br><span class="line">int pearl[101] &#x3D; &#123; 0 &#125;;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">cin &gt;&gt; pearl[i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 1; i &lt; N; ++i) &#123;</span><br><span class="line">energy[i][0] &#x3D; pearl[i];</span><br><span class="line">energy[i][1] &#x3D; pearl[i + 1];</span><br><span class="line">&#125;</span><br><span class="line">energy[N][0] &#x3D; pearl[N];</span><br><span class="line">energy[N][1] &#x3D; pearl[1];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组定义在main函数外，每次执行要重置f[][]以覆盖之前的数据，否则出错</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; N; ++j) &#123;</span><br><span class="line">f[i][j] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f[N][1] &#x3D; energy[N][0] * energy[1][0] * energy[1][1];</span><br><span class="line"></span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; ++i) &#123;</span><br><span class="line">if (i &#x3D;&#x3D; 1)result &#x3D; max(result, dp(i, i + N - 1));</span><br><span class="line">elseresult &#x3D; max(result, dp(i, (i + N - 1) % N));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>⭐⭐⭐⭐<a name="1687"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1687 --Permutation</span><br><span class="line">题目：众所周知，对n个数进行排列得到的序列数目为 n!。 </span><br><span class="line">例如，1 2 3 4 5 和 1 3 5 4 2 都是 5-permutations。</span><br><span class="line">如果我们在每对连续数字之间插入符号“ &lt; ”或“ &gt; ”，则可以获得带有符号的排列。</span><br><span class="line">例如，可以将 1 2 3 4 5 写成 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5， 1 3 5 4 2 可以写成 1 &lt; 3 &lt; 5 &gt; 4 &gt; 2。 </span><br><span class="line">请计算带有 k 个“ &lt; ”符号的n-permutations的数量。对结果取模2007。</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 1 &lt;&#x3D; n, k &lt;&#x3D; 100</span><br></pre></td></tr></table></figure><br>假设我们已经对长度为 i - 1 的序列的“ &lt; ”数目进行计算了，现在遍历到第 i 个数，即数字  i ，显然数字 i 比当前序列中所有的数都大，那么把数字 i 插进当前序列便有两种情况：</p><ul><li>当前序列的 i - 1 个数中有 j 个“ &lt; ”: 为使插进数字 i 后 <strong>“ &lt; ”数目保持不变</strong>，可以在序列的开头插入，或者在当前序列的“ &lt; ”的位置插入，此时共有 <strong>j + 1</strong> 种选择。</li><li>当前序列的 i - 1 个数中有 j - 1 个“ &lt; ”: 为使插进数字 i 后 <strong>“ &lt; ”数目加一</strong>，可以在序列的末尾插入，或者在当前序列的“ &gt; ”的位置插入，此时共有 i - 2 - (j - 1) + 1 = <strong>i - j</strong> 种选择。</li></ul><p>用数组 <strong>dp[i][j] 表示长度为 i 且“ &lt; ”个数为 j 的序列的数目</strong>，则有递推式：<strong>dp[i][j] = dp[i-1][j-1] <em> (i - j) + dp[i-1][j] </em> (j + 1)</strong>。<br/>比较巧妙的一个处理是，由于一次测试中可能会有多个测例，而给定的 n 和 k 又比较小，故而把动态规划的过程放在了输入 n, k 的循环体之外来避免存在多个测例时的重复计算。<br/>另外，在main函数中好像不能定义太大的数组，会导致堆栈溢出？总之把它放在main函数外面了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int dp[101][101] &#x3D; &#123; &#123;0&#125; &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, k;</span><br><span class="line">dp[1][0] &#x3D; 1;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; 101; ++i) &#123;</span><br><span class="line">dp[i][0] &#x3D; 1;</span><br><span class="line">for (int j &#x3D; 1; j &lt; i; ++j) &#123;</span><br><span class="line">dp[i][j] &#x3D; (dp[i - 1][j - 1] * (i - j) + dp[i - 1][j] * (j + 1)) % 2007;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (cin &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">cout &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划（一）</title>
      <link href="/2020/05/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/05/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="📝算法介绍"><a href="#📝算法介绍" class="headerlink" title="📝算法介绍"></a><strong>📝算法介绍</strong></h2><p><strong>动态规划</strong>（Dynamic programming）常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。<br/><br>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于<strong>优化递归问题</strong>，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。<br/><br>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<strong>记忆化存储</strong>，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。<br/></p><hr><h2 id="👉一个例题"><a href="#👉一个例题" class="headerlink" title="👉一个例题"></a><strong>👉一个例题</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1176 --Two Ends</span><br><span class="line">题目：给一个长度为n的数列ai，两个人在上面做交替取数，每个人的每一轮从这个数列的两端中取出一个数（不能不操作）。先手可以自由选择策略，后手选择贪心策略。贪心策略是指，如果两端数大小不同，选择大的那个；如果相同选择左边那个。问最后先手能赢后手多少分。(1&lt;&#x3D;n&lt;&#x3D;1000且n为偶数)</span><br></pre></td></tr></table></figure><p>我们定义一个二维数组values储存所有的解的情况，定义一维数组num储存数字序列；然后定义动态规划函数dp(int left, int right)，其中left, right分别表示左右边界的牌，玩家每一次选择都有两种情况：选择最左边的牌或最右边的牌。故每一次动态规划都有两种方案：<br/></p><ul><li>第一种，先手选择最左边的牌left，那么后手就会进行贪心算法选择剩下的左右边界中最大的那张牌，如果最左边大，则后手取走牌left+1，下一次dp序列为left+2到right；如果最右边大，则后手取走牌right，下一次dp序列为left+1到right-1；<br/></li><li>第二种，先手选择最右边的牌right，那么后手就会进行贪心算法选择剩下的左右边界中最大的那张牌，如果最左边大，则后手取走牌left，下一次dp序列为left+1到right-1；如果最右边大，则后手取走牌right-1，下一次dp序列为left到right-2；<br/></li></ul><p>每一次dp都对上述两种方案进行比较，选择先手分值比较高的方案对values[left][right]进行赋值，最终找出最好的方案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000;</span><br><span class="line">int num[maxn];</span><br><span class="line">int values[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int dp(int left, int right) &#123;&#x2F;&#x2F;参数都是index</span><br><span class="line">if (left &gt; right)return 0;</span><br><span class="line">if (values[left][right] !&#x3D; -1)return values[left][right];</span><br><span class="line">values[left][right] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">values[left][right] &#x3D; max(values[left][right], num[left+1] &gt;&#x3D; num[right] ? num[left]+dp(left+2,right) : num[left]+dp(left+1,right-1));&#x2F;&#x2F;先手拿了左边</span><br><span class="line">values[left][right] &#x3D; max(values[left][right], num[left] &gt;&#x3D; num[right-1] ? num[right]+dp(left+1,right-1) : num[right]+dp(left,right-2));&#x2F;&#x2F;先手拿了右边</span><br><span class="line">return values[left][right];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">while (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">count++;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; num[i];</span><br><span class="line">sum +&#x3D; num[i];</span><br><span class="line">for (int j &#x3D; 0; j &lt; n; ++j) &#123;</span><br><span class="line">values[i][j] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;In game &quot; &lt;&lt; count &lt;&lt; &quot;, the greedy strategy might lose by as many as &quot; &lt;&lt; 2*dp(0, n - 1)-sum &lt;&lt; &quot; points.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="👉另一个例题"><a href="#👉另一个例题" class="headerlink" title="👉另一个例题"></a><strong>👉另一个例题</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1011 --Lenny&#39;s Lucky Lotto</span><br><span class="line">题目：给定N，M，问有多少个长度为N的整数序列，满足所有数都在[1,M]内，并且后一个数都至少是前一个数的两倍。</span><br></pre></td></tr></table></figure><p>用f[i][j]表示长度为i，最大数为j的序列的数目；用s[i][j]表示长度为i，最大数不超过j的序列的数目，那么可以推出：s[i][j]=s[i][j-1]+f[i][j]、f[i][j]=s[i-1][j/2]。<br/><br>在这组递推式中我们进行了<strong>记忆存储</strong>，长度每增加1，利用已记录的原长度的相关数据简单计算得到新长度的数据并记录，<strong>自底向上</strong>递推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">long long dp(int n, int m) &#123;</span><br><span class="line">long long s[11][2001] &#x3D; &#123;0&#125;;</span><br><span class="line">long long f[11][2001] &#x3D; &#123;0&#125;;</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">f[1][j] &#x3D; 1;</span><br><span class="line">s[1][j] &#x3D; j;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">f[i][0] &#x3D; s[i][0] &#x3D; 0;</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class="line">f[i][j] &#x3D; s[i-1][j&#x2F;2];</span><br><span class="line">s[i][j] &#x3D; s[i][j-1] + f[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return s[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>❗ Sicily的题设中意于很大的数，所以写的时候注意看看需不需要把int改成long long（没错我就时常因为这个问题WA）。<br><br/></p><hr><h2 id="📝小结"><a href="#📝小结" class="headerlink" title="📝小结"></a><strong>📝小结</strong></h2><p>可见，上述例题最主要的共同点：<strong>记忆存储</strong>，即建立二维数组-&gt;代入参数-&gt;逐层递推的过程。这是动态规划问题最常见的套路之一。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICMP协议</title>
      <link href="/2020/05/18/ICMP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/05/18/ICMP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="ping命令使用的协议为ICMP。下面是关于ICMP的相关资料。"><a href="#ping命令使用的协议为ICMP。下面是关于ICMP的相关资料。" class="headerlink" title="ping命令使用的协议为ICMP。下面是关于ICMP的相关资料。"></a>ping命令使用的协议为ICMP。下面是关于ICMP的相关资料。</h3><p><strong>·</strong> <a href="https://wenku.baidu.com/view/d4a4ed0303d8ce2f0066232b.html" target="_blank" rel="noopener">RFC792—ICMP协议（中文版）</a><br><strong>·</strong> <a href="https://blog.csdn.net/deramer1/article/details/73480825" target="_blank" rel="noopener">ICMP详解和实例分析</a><br><strong>·</strong> <a href="https://blog.csdn.net/tigerjibo/article/details/7356936" target="_blank" rel="noopener">ICMP报文分析</a><br><strong>·</strong> <a href="https://blog.csdn.net/qq_40467670/article/details/83820606" target="_blank" rel="noopener">ICMP数据包BE、LE解释</a><br><strong>·</strong> <a href="https://wenku.baidu.com/view/429144d6c850ad02de8041c9.html" target="_blank" rel="noopener">ICMP数据报和IP数据报分片分析实验报告</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> ICMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件传输服务-FTP</title>
      <link href="/2020/05/17/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1-FTP/"/>
      <url>/2020/05/17/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1-FTP/</url>
      
        <content type="html"><![CDATA[<h3 id="FTP使用的唯一传输层协议为TCP。下面是关于FTP和TCP的相关资料。"><a href="#FTP使用的唯一传输层协议为TCP。下面是关于FTP和TCP的相关资料。" class="headerlink" title="FTP使用的唯一传输层协议为TCP。下面是关于FTP和TCP的相关资料。"></a>FTP使用的唯一传输层协议为TCP。下面是关于FTP和TCP的相关资料。</h3><p><strong>·</strong> 非常实用全面👉<a href="https://www.cnblogs.com/rainman/p/11647723.html" target="_blank" rel="noopener">FTP协议的主动模式和被动模式的区别</a><br><strong>·</strong> 关于FTP协议定义&amp;命令&amp;应答的种种👉<a href="https://wenku.baidu.com/view/fd5c3611f18583d049645969.html" target="_blank" rel="noopener">RFC959 FTP传输协议（中文版）</a><br><strong>·</strong> 详细介绍每个命令及其对应的应答👉<a href="https://blog.csdn.net/weiyuefei/article/details/51758288" target="_blank" rel="noopener">FTP协议（指令集）</a><br><strong>·</strong> 详解👉<a href="https://www.cnblogs.com/god-of-death/p/7236463.html" target="_blank" rel="noopener">TCP四次挥手（断开连接）及断开过程</a><br><strong>·</strong> 超全面👉<a href="https://blog.csdn.net/daaikuaichuan/article/details/83475809" target="_blank" rel="noopener">TCP协议详解（TCP报文、三次握手、四次挥手、TIME_WAIT状态、滑动窗口、拥塞控制、粘包问题、状态转换图）</a><br><strong>·</strong> <a href="https://blog.csdn.net/immortal_mcl/article/details/80543231" target="_blank" rel="noopener">Wireshark-TCP协议分析（包结构以及连接的建立和释放）</a><br><strong>·</strong> <a href="https://www.cnblogs.com/ImBit/p/5513401.html" target="_blank" rel="noopener">基础笔记（三）：网络协议之Tcp、Http</a><br><strong>·</strong> <a href="https://blog.csdn.net/daaikuaichuan/article/details/83475809" target="_blank" rel="noopener">TCP报文格式，TCP的三次握手和四次挥手&amp;hosts文件</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> FTP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-983 最低票价</title>
      <link href="/2020/05/07/LeetCode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/"/>
      <url>/2020/05/07/LeetCode-983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</span><br><span class="line"></span><br><span class="line">火车票有三种不同的销售方式：</span><br><span class="line"></span><br><span class="line">· 一张为期一天的通行证售价为 costs[0] 美元；</span><br><span class="line">· 一张为期七天的通行证售价为 costs[1] 美元；</span><br><span class="line">· 一张为期三十天的通行证售价为 costs[2] 美元。</span><br><span class="line"></span><br><span class="line">通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</span><br><span class="line"></span><br><span class="line">返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：days &#x3D; [1,4,6,7,8,20], costs &#x3D; [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] &#x3D; $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：days &#x3D; [1,2,3,4,5,6,7,8,9,10,30,31], costs &#x3D; [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] &#x3D; $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] &#x3D; $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 1 &lt;&#x3D; days.length &lt;&#x3D; 365</span><br><span class="line">· 1 &lt;&#x3D; days[i] &lt;&#x3D; 365</span><br><span class="line">· days 按顺序严格递增</span><br><span class="line">· costs.length &#x3D;&#x3D; 3</span><br><span class="line">· 1 &lt;&#x3D; costs[i] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>主干思路：</p><ul><li>今天不需要出门，不用买票</li><li>今天如果要出门，需要买几天？<ul><li>看往后几天（最多30天内）要不要出门<ul><li>30天内都没有要出行的，那只买今天就好</li><li>有要出门的（不同决策）<ul><li>这次 和 后面几次 分开买更省</li><li>这次 和 后面几次 一起买更省</li></ul></li></ul></li></ul></li></ul><p>上述思路显而易见，最关键在于：「今天买多少，得看后几天怎么安排」，即「前面依赖后面」——从后向前来买。<br/><br>如图所示，例如：$days = [1,4,6,7,8,20]$<br/></p><ul><li>第 21 及以后的日子都不需要出门，不用买票</li><li>第 20 需要出门，需要买几天？<ul><li>不考虑 20 之前要不要出门，否则与思路相违背</li><li>第 20 之后没有出门日，故买「一天」的 costs[0] 最省钱。</li></ul></li><li>第 9 - 19 不需要出门，则不用买</li><li>第 8 需要出门，需要买几天？<ul><li>往后（只需看往后30天）有出门的需求<ul><li>决策1：买一天期，后面的不包</li><li>决策2：买七天期，包到第 8 + 7 - 1 天，第 8 + 7 天往后的不包</li><li>决策3：买三十天期，包到第 8 + 30 - 1 天，第 8 + 30 天往后的不包<ul><li>可见，决策3 包三十天期的话，第 20 可不用花钱</li></ul></li></ul></li></ul></li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/983-1.png"  alt=""></p><ul><li>…</li><li>抽象，定义状态：dp[i] 为第 i 天开始，累计所需最小费用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; min(决策1, 决策2, 决策3);    </span><br><span class="line">      &#x3D; min(c[0] + 1天后不包, c[1] + 7天后不包, c[2] + 30天不包);</span><br><span class="line">      &#x3D; min(c[0] + dp[i + 1], c[1] + dp[i + 7], c[2] + dp[i + 30]);</span><br></pre></td></tr></table></figure></li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/983-2.png"  alt=""><br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123;</span><br><span class="line">    int len &#x3D; days.size();</span><br><span class="line">    int dp[400] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    for (int d &#x3D; days[len-1], i &#x3D; len-1; d &gt;&#x3D; days[0]; --d)&#123;</span><br><span class="line">        if (d &#x3D;&#x3D; days[i])&#123;</span><br><span class="line">            dp[d] &#x3D; min(costs[0]+dp[d+1], costs[1]+dp[d+7]);</span><br><span class="line">            dp[d] &#x3D; min(costs[2]+dp[d+30], dp[d]);</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        else dp[d] &#x3D; dp[d+1];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[days[0]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-101 对称二叉树</title>
      <link href="/2020/05/07/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/05/07/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，检查它是否是镜像对称的。 </span><br><span class="line"></span><br><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   2</span><br><span class="line">  &#x2F; \ &#x2F; \</span><br><span class="line"> 3  4 4  3 </span><br><span class="line"></span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>递归，思路与 <a href="https://whitebeerhouse.github.io/2020/05/07/LeetCode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91" target="_blank" rel="noopener">LeetCode-572 另一个树的子树</a> 类似。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool isSymmetricTree(TreeNode* root1, TreeNode* root2)&#123; &#x2F;&#x2F;辅助函数</span><br><span class="line">    if (root1 &#x3D;&#x3D; NULL &amp;&amp; root2 &#x3D;&#x3D; NULL) return true;</span><br><span class="line">    if (root1 &#x3D;&#x3D; NULL || root2 &#x3D;&#x3D; NULL) return false;</span><br><span class="line">    return (root1-&gt;val &#x3D;&#x3D; root2-&gt;val &amp;&amp; isSymmetricTree(root1-&gt;left, root2-&gt;right) &amp;&amp; isSymmetricTree(root1-&gt;right, root2-&gt;left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSymmetric(TreeNode* root)&#123; &#x2F;&#x2F;主函数</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)   return true;</span><br><span class="line">    return isSymmetricTree(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-572 另一个树的子树</title>
      <link href="/2020/05/07/LeetCode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
      <url>/2020/05/07/LeetCode-572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定的树 s:</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 t：</span><br><span class="line"></span><br><span class="line">   4 </span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定的树 s：</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">    &#x2F;</span><br><span class="line">   0</span><br><span class="line">给定的树 t：</span><br><span class="line"></span><br><span class="line">   4</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">返回 false。</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>判断 t 是否为 s 的<strong>子树</strong>的三个条件：</p><ul><li>当前两棵树相等；</li><li><strong>或者</strong>，t 是 s 的左子树；</li><li><strong>或者</strong>，t 是 s 的右子树。</li></ul><p>而判断两个树是否<strong>相等</strong>的三个条件：</p><ul><li>当前两个树的根节点值相等；</li><li><strong>并且</strong>，s 的左子树和 t 的左子树相等；</li><li><strong>并且</strong>，s 的右子树和 t 的右子树相等。</li></ul><p>🐣：曾有过中序遍历得到所有节点值的序列的尝试，再一推敲发觉其实并不可行，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      3</span><br><span class="line">     &#x2F; \               </span><br><span class="line">    4   5                              4</span><br><span class="line">   &#x2F; \                &amp;               &#x2F; \</span><br><span class="line">  1   2                              1   2</span><br><span class="line"> &#x2F;                    </span><br><span class="line">0</span><br></pre></td></tr></table></figure><br><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool isSametree(TreeNode* s, TreeNode* t)&#123; &#x2F;&#x2F;辅助函数</span><br><span class="line">    if (s &#x3D;&#x3D; NULL &amp;&amp; t &#x3D;&#x3D; NULL) return true;</span><br><span class="line">    if (s &#x3D;&#x3D; NULL || t &#x3D;&#x3D; NULL)  return false;</span><br><span class="line">    return (s-&gt;val &#x3D;&#x3D; t-&gt;val &amp;&amp; isSametree(s-&gt;left, t-&gt;left) &amp;&amp; isSametree(s-&gt;right, t-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isSubtree(TreeNode* s, TreeNode* t)&#123; &#x2F;&#x2F;主函数</span><br><span class="line">    if (s &#x3D;&#x3D; NULL &amp;&amp; t &#x3D;&#x3D; NULL) return true;</span><br><span class="line">    if (s &#x3D;&#x3D; NULL || t &#x3D;&#x3D; NULL)  return false;</span><br><span class="line">    return isSametree(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-45 跳跃游戏II</title>
      <link href="/2020/05/04/LeetCode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
      <url>/2020/05/04/LeetCode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。</span><br><span class="line"></span><br><span class="line">数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><br><span class="line"></span><br><span class="line">你的目标是使用最少的跳跃次数到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">说明: 假设你总是可以到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>贪心算法，我们每次在可跳范围内选择可以使得跳的更远的位置。<br/>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4…<br/>在具体的实现中，维护当前能够到达的最大下标位置，记为边界。从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。<br/>遍历数组时，<strong>不访问最后一个元素</strong>，因为在访问最后一个元素之前，边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，会增加一次「不必要的跳跃次数」，因此不必访问最后一个元素。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len &#x3D; nums.size();</span><br><span class="line">    int end &#x3D; 0, result &#x3D; 0, maxPos &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len-1; ++i)&#123;</span><br><span class="line">        if(i &lt;&#x3D; maxPos)&#123;</span><br><span class="line">            maxPos &#x3D; max(maxPos, i+nums[i]);</span><br><span class="line">            if (i &gt;&#x3D; end)&#123;</span><br><span class="line">                end &#x3D; maxPos;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;      </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1386 安排电影院座位⭐</title>
      <link href="/2020/05/02/LeetCode-1386-%E5%AE%89%E6%8E%92%E7%94%B5%E5%BD%B1%E9%99%A2%E5%BA%A7%E4%BD%8D%E2%AD%90/"/>
      <url>/2020/05/02/LeetCode-1386-%E5%AE%89%E6%8E%92%E7%94%B5%E5%BD%B1%E9%99%A2%E5%BA%A7%E4%BD%8D%E2%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">如图一所示，电影院的观影厅中有 n 行座位，行编号从 1 到 n ，且每一行内总共有 10 个座位，列编号从 1 到 10 。</span><br><span class="line"></span><br><span class="line">给你数组 reservedSeats ，包含所有已经被预约了的座位。比如说，researvedSeats[i]&#x3D;[3,8] ，它表示第 3 行第 8 个座位被预约了。</span><br><span class="line"></span><br><span class="line">请你返回最多能安排多少个 4 人家庭 。4 人家庭要占据 同一行内连续 的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 3, reservedSeats &#x3D; [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]</span><br><span class="line">输出：4</span><br><span class="line">解释：图二所示是最优的安排方案，总共可以安排 4 个家庭。蓝色的叉表示被预约的座位，橙色的连续座位表示一个 4 人家庭。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 2, reservedSeats &#x3D; [[2,1],[1,8],[2,6]]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 4, reservedSeats &#x3D; [[4,3],[1,4],[4,6],[1,7]]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">· 1 &lt;&#x3D; n &lt;&#x3D; 10^9</span><br><span class="line">· 1 &lt;&#x3D; reservedSeats.length &lt;&#x3D; min(10*n, 10^4)</span><br><span class="line">· reservedSeats[i].length &#x3D;&#x3D; 2</span><br><span class="line">· 1 &lt;&#x3D; reservedSeats[i][0] &lt;&#x3D; n</span><br><span class="line">· 1 &lt;&#x3D; reservedSeats[i][1] &lt;&#x3D; 10</span><br><span class="line">· 所有 reservedSeats[i] 都是互不相同的。</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1386-1.png"  alt="图一"><br/><br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1386-2.png"  alt="图二"><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>对于一个家庭而言，只有以下三种给他们安排座位的方法：</p><ul><li>安排位置 2，3，4，5；</li><li>安排位置 4，5，6，7；</li><li>安排位置 6，7，8，9。</li></ul><p>因此每一排的位置 1 和位置 10 都是没有意义的，即使被预约了也对答案没有任何影响，所以，忽略所有在位置 1 和位置 10 的预约。同时可以发现，如果一排位置（不含位置 1 和位置 10 ，下同）没有被预约，那么恰好可以安排给两个家庭；如果一排位置被预约了至少一个座位，那么最多只能安排给一个家庭了。<br/>对于只能安排一个家庭的情况，有两种方法计算。<br/><br/>方法一：<strong>查找</strong>。即利用STL自定义的函数暴力查找。<br/><br/>方法二：<strong>位运算</strong>。<br>用<strong>哈希表</strong>来存储每一排以及它们的二进制数。对于哈希映射中的每个键值对，键表示电影院中的一排，值表示这一排对应的二进制数。如果某一排没有任何位置被预约（例如上面的第三排），那么这一排一定可以安排给两个家庭，因此可以不必将这个键值对存放在哈希映射中。也就是说，只有某一排的某一座位被预约了，才将这一排放入哈希映射。<br/>在处理完了所有的预约之后，遍历哈希映射。对于一个键值对 (row,bitmask)，如何知道 row 这一排可以安排给几个家庭呢？根据之前的分析，被存储在哈希映射中的这些排最多只能安排给一个家庭，那么对于三种安排座位的方法：</p><ul><li>对于安排位置 2，3，4，5，如果 bitmask 中第 0，1，2，3 个二进制位均为 0，那么就可以安排给一个家庭；也就是说，bitmask 和 (11110000)<sub>2</sub> 的按位或值保持为 (11110000)<sub>2</sub> 不变；</li><li>对于安排位置 4，5，6，7，如果 bitmask 中第 2，3，4，5 个二进制位均为 0，那么就可以安排给一个家庭；也就是说，bitmask 和 (11000011)<sub>2</sub> 的按位或值保持为 (11000011)<sub>2</sub> 不变；</li><li>对于安排位置 6，7，8，9，如果 bitmask 中第 4，5，6，7 个二进制位均为 0，那么就可以安排给一个家庭；也就是说，bitmask 和 (00001111)<sub>2</sub> 的按位或值保持为 (00001111)<sub>2</sub> 不变；</li></ul><p>这样以来，我们只需要将 bitmask 分别与 (11110000)<sub>2</sub>、 (11000011)<sub>2</sub> 和 (00001111)<sub>2</sub>进行按位或运算，如果其中有一个在运算后保持不变，那么 row 这一排就可以安排给一个家庭。<br/>🐣：auto冒号遍历为 C++11 新特性，参见 <a href="https://blog.csdn.net/qq_40213457/article/details/80720170" target="_blank" rel="noopener">C++11 auto冒号遍历</a>、<a href="https://blog.csdn.net/zyc2018/article/details/93591189" target="_blank" rel="noopener">C++之auto使用</a>；温习一下<a href="https://www.cnblogs.com/fightfor/p/3871624.html" target="_blank" rel="noopener">左移/右移运算符</a>。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">int maxNumberOfFamilies(int n, vector&lt;vector&lt;int&gt;&gt;&amp; reservedSeats) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    unordered_map&lt;int, unordered_set&lt;int&gt;&gt; record;</span><br><span class="line">    for (auto i : reservedSeats)&#123;</span><br><span class="line">        if (i[1] &gt;&#x3D; 2 &amp;&amp; i[1] &lt;&#x3D; 9)  </span><br><span class="line">            record[i[0]].insert(i[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    result +&#x3D; (n - record.size()) * 2;</span><br><span class="line"></span><br><span class="line">    for (auto i : record)&#123;</span><br><span class="line">        bool side &#x3D; false;</span><br><span class="line">        if (!(i.second.count(2) || i.second.count(3) || i.second.count(4) || i.second.count(5)))    ++result, side &#x3D; true;</span><br><span class="line">        if (!(i.second.count(6) || i.second.count(7) || i.second.count(8) || i.second.count(9)))    ++result, side &#x3D; true;</span><br><span class="line">        if (!(i.second.count(4) || i.second.count(5) || i.second.count(6) || i.second.count(7)) &amp;&amp; !side)    ++result;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">int maxNumberOfFamilies(int n, vector&lt;vector&lt;int&gt;&gt;&amp; reservedSeats) &#123;</span><br><span class="line">    int left &#x3D; 0b11110000; &#x2F;&#x2F; 2~9</span><br><span class="line">    int middle &#x3D; 0b11000011;</span><br><span class="line">    int right &#x3D; 0b00001111;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;int, int&gt; record;</span><br><span class="line">    for (auto iter : reservedSeats)&#123;</span><br><span class="line">        if (iter[1] &gt;&#x3D; 2 &amp;&amp; iter[1] &lt;&#x3D; 9)</span><br><span class="line">            record[iter[0]] |&#x3D; (1 &lt;&lt; (iter[1]-2));</span><br><span class="line">    &#125;</span><br><span class="line">    result +&#x3D; (n - record.size()) * 2;</span><br><span class="line"></span><br><span class="line">    for (auto iter : record)&#123;</span><br><span class="line">        if ((iter.second | left) &#x3D;&#x3D; left || (iter.second | middle) &#x3D;&#x3D; middle || (iter.second | right) &#x3D;&#x3D; right)</span><br><span class="line">            ++result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> STL </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1029 两地调度</title>
      <link href="/2020/04/30/LeetCode-1029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6/"/>
      <url>/2020/04/30/LeetCode-1029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。</span><br><span class="line"></span><br><span class="line">返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">输出：110</span><br><span class="line">解释：</span><br><span class="line">第一个人去 A 市，费用为 10。</span><br><span class="line">第二个人去 A 市，费用为 30。</span><br><span class="line">第三个人去 B 市，费用为 50。</span><br><span class="line">第四个人去 B 市，费用为 20。</span><br><span class="line"></span><br><span class="line">最低总费用为 10 + 30 + 50 + 20 &#x3D; 110，每个城市都有一半的人在面试。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">· 1 &lt;&#x3D; costs.length &lt;&#x3D; 100</span><br><span class="line">· costs.length 为偶数</span><br><span class="line">· 1 &lt;&#x3D; costs[i][0], costs[i][1] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>这样来看这个问题，公司首先将这 2N 个人全都安排飞往 A 市，再选出 N 个人改变它们的行程，让他们飞往 A 市。因为全部去往 A 市的总费用 $Sum$ 是确定的，改变 N 个人的行程后总费用为 $Sum - \sum_{n=1}^{len/2} (cost[n][0] - cost[n][1])$，自然是每一组A、B费用差值越大越好了😃。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;</span><br><span class="line">    int len &#x3D; costs.size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    vector&lt;int&gt; diff;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        result +&#x3D; costs[i][0];</span><br><span class="line">        diff.push_back(costs[i][0]-costs[i][1]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(diff.begin(), diff.end());</span><br><span class="line">    for (int i &#x3D; len-1; i &gt;&#x3D; len&#x2F;2; --i)&#123;</span><br><span class="line">        result -&#x3D; diff[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1424 对角线遍历II⭐</title>
      <link href="/2020/04/28/LeetCode-1424-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86II%E2%AD%90/"/>
      <url>/2020/04/28/LeetCode-1424-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86II%E2%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,4,2,7,5,3,8,6,9]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]</span><br><span class="line">输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3],[4],[5,6,7],[8],[9,10,11]]</span><br><span class="line">输出：[1,4,2,5,3,8,6,9,7,10,11]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [[1,2,3,4,5,6]]</span><br><span class="line">输出：[1,2,3,4,5,6] </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">· 1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5</span><br><span class="line">· 1 &lt;&#x3D; nums[i].length &lt;&#x3D; 10^5</span><br><span class="line">· 1 &lt;&#x3D; nums[i][j] &lt;&#x3D; 10^9</span><br><span class="line">nums 中最多有 10^5 个数字。</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1424-1.png"  alt="示例1"><br><br/></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/1424-2.png"  alt="示例2"><br><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>因为矩阵不是完整填充的，所以不能直接遍历。考虑到是顺着对角线的同一方向，那么x+y就是相等的且次序一致，那么可以按照x+y去分类，建立一个二维数组ans[i] [j]，i表示（x+y），然后正常遍历这个nums，每遍历到一个元素，看看它的x+y，把它丢到ans[x+y]中。<br/>对角线遍历的另一种设定👉<a href="https://whitebeerhouse.github.io/2020/04/26/LeetCode-498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/#%F0%9F%93%9D%E9%A2%98%E7%9B%AE" target="_blank" rel="noopener">LeetCode-498 对角线遍历</a>。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    int row &#x3D; nums.size();</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; arr;&#x2F;&#x2F;[i+j][count]</span><br><span class="line">    arr.resize(1e5);</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; row; ++i)&#123;            </span><br><span class="line">        int column &#x3D; nums[i].size();</span><br><span class="line">        for (int j &#x3D; 0; j &lt; column; ++j)&#123;</span><br><span class="line">            arr[i+j].push_back(nums[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        max &#x3D; column &gt; max ? column : max;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; row+max; ++i)&#123;</span><br><span class="line">        while (!arr[i].empty())&#123;</span><br><span class="line">            result.push_back(arr[i].back());</span><br><span class="line">            arr[i].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-27 移除元素</title>
      <link href="/2020/04/28/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2020/04/28/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>被归类为“<strong>双指针</strong>”的一类吧…因为要求非暴力解法&amp;空间复杂度O(1)，那么就记录下不为val的那些值吧，<strong>原地记录</strong>。<br/>解法几乎一致的另一道题👉<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">LeetCode-26 删除排序数组中的重复项</a>。<br/>🐣：双指针究竟是哪些个流程至今还没系统了解，但我尝试了一下，朝着用双指针框住数组片段进行拷贝覆盖的死胡同里钻了…✊<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">    int len &#x3D; nums.size();</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (nums[i] !&#x3D; val)&#123;</span><br><span class="line">            nums[count] &#x3D; nums[i];</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-150 逆波兰表达式求值</title>
      <link href="/2020/04/27/LeetCode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/2020/04/27/LeetCode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">根据逆波兰表示法，求表达式的值。</span><br><span class="line"></span><br><span class="line">有效的运算符包括 +, -, *, &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">· 整数除法只保留整数部分。</span><br><span class="line">· 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) &#x3D; 9</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p><strong>栈</strong>的经典应用。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">    int len &#x3D; tokens.size();</span><br><span class="line">    stack&lt;int&gt; record;        </span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (tokens[i] !&#x3D; &quot;+&quot; &amp;&amp; tokens[i] !&#x3D; &quot;-&quot; &amp;&amp; tokens[i] !&#x3D; &quot;*&quot; &amp;&amp; tokens[i] !&#x3D; &quot;&#x2F;&quot;)&#123;</span><br><span class="line">            int temp &#x3D; stoi(tokens[i], 0, 10);</span><br><span class="line">            record.push(temp);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;                </span><br><span class="line">        int temp_right &#x3D; record.top();</span><br><span class="line">        record.pop();</span><br><span class="line">        int temp_left &#x3D; record.top();</span><br><span class="line">        record.pop();</span><br><span class="line">        </span><br><span class="line">        if (tokens[i] &#x3D;&#x3D; &quot;+&quot;)   record.push(temp_left + temp_right);</span><br><span class="line">        else if (tokens[i] &#x3D;&#x3D; &quot;-&quot;)  record.push(temp_left - temp_right);</span><br><span class="line">        else if (tokens[i] &#x3D;&#x3D; &quot;*&quot;)  record.push(temp_left * temp_right); </span><br><span class="line">        else   record.push(temp_left &#x2F; temp_right);  </span><br><span class="line">        </span><br><span class="line">    &#125;        </span><br><span class="line">    return record.top();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-739 每日温度</title>
      <link href="/2020/04/27/LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
      <url>/2020/04/27/LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</span><br><span class="line"></span><br><span class="line">例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</span><br><span class="line"></span><br><span class="line">提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>准备两个<strong>栈</strong>保存还未得到匹配的温度和下标，遍历 temperatures 。如果该日温度超过栈顶的温度，则把栈中所有小于该日温度的数据都弹出（按照这个算法，栈中的数据必然是从大到小（底-&gt;顶）排列的）；如果该日温度低于栈顶温度，必然低于栈中所有温度，则 push 入栈中。注意栈空时的处理。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;</span><br><span class="line">    int len &#x3D; T.size();</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    result.resize(len);</span><br><span class="line">    </span><br><span class="line">    stack&lt;int&gt; key;</span><br><span class="line">    stack&lt;int&gt; value;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        while (!value.empty() &amp;&amp; T[i] &gt; value.top())&#123;</span><br><span class="line">            int t_key &#x3D; key.top();</span><br><span class="line">            result[t_key] &#x3D; i-t_key;</span><br><span class="line">            value.pop();</span><br><span class="line">            key.pop();</span><br><span class="line">        &#125;       </span><br><span class="line">        key.push(i);</span><br><span class="line">        value.push(T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (!key.empty())&#123;</span><br><span class="line">        int temp &#x3D; key.top();</span><br><span class="line">        key.pop();</span><br><span class="line">        result[temp] &#x3D; 0;</span><br><span class="line">    &#125;      </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-892 三维形体的表面积</title>
      <link href="/2020/04/27/LeetCode-892-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/"/>
      <url>/2020/04/27/LeetCode-892-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。</span><br><span class="line"></span><br><span class="line">每个值 v &#x3D; grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。</span><br><span class="line"></span><br><span class="line">请你返回最终形体的表面积。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">· 1 &lt;&#x3D; N &lt;&#x3D; 50</span><br><span class="line">· 0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 50</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>做加法</strong>。<br/>我们可以将单元格 (i, j) 上堆叠的 v 个正方体看成一个高度为 v 的柱子，然后分别计算每个柱子的表面积。<br/>首先，v &gt; 0 的话，柱子顶部、底部的表面积都是 1。<br/>然后是上、下、左、右四个侧面的表面积。以左侧的表面积为例：</p><ul><li>如果柱子位于网格左边缘，左侧没有其他柱子，那么左侧表面积为 v；</li><li>如果柱子比左边的柱子矮，那么左侧露不出来，表面积为 0；</li><li>如果柱子比左边的柱子高，假设左边柱子高度为 v’，那么左边露出来的表面积为 v - v’。</li></ul><p>其余的三个侧面以此类推。<br/><br>想法二：<strong>做减法</strong>。<br/>先计算全部的表面积，然后再减去重叠的部分。<br/>假设一共有 n 个立方体，每个立方体都有六个面，那么总的表面积应该是 6n。但是这些正方体堆叠在了一起，需要减掉一些因为堆叠而露不出来的表面积。每一对相邻的立方体接触在一起，都会让表面积减少 2。假设一共有 e 对相接触的立方体，即有 e 个接触面，表面积就会减少 2e。那么，最终的表面积就应该是 6n - 2e。<br/>那么如何计算立方体的接触面呢？很简单，我们还是把每个单元格上堆叠的 v 个立方体看成一个柱子。立方体的接触面可以分为柱子内部和柱子之间的接触面：</p><ul><li>v 个立方体的柱子内部，有 v - 1 个接触面</li><li>高度分别为 v、w 的两个立方体之间的接触面为 min(v, w)。</li></ul><p>🐣：Sicily线上赛有一道几乎一样的！！但当时我竟死磕用三视图去解🤦<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加法</span><br><span class="line"></span><br><span class="line">int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123;</span><br><span class="line">    int n &#x3D; grid.size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; ++j)&#123;</span><br><span class="line">            &#x2F;&#x2F;上下</span><br><span class="line">            if (grid[i][j]) result +&#x3D; 2;</span><br><span class="line">            &#x2F;&#x2F;左右</span><br><span class="line">            if (j &#x3D;&#x3D; 0) result +&#x3D; grid[i][j];</span><br><span class="line">            if (j &#x3D;&#x3D; n-1) result +&#x3D; grid[i][j];</span><br><span class="line">            if (j &gt; 0 &amp;&amp; grid[i][j] &gt; grid[i][j-1]) result +&#x3D; (grid[i][j] - grid[i][j-1]);</span><br><span class="line">            if (j &lt; n-1 &amp;&amp; grid[i][j] &gt; grid[i][j+1])   result +&#x3D; (grid[i][j] - grid[i][j+1]);</span><br><span class="line">            &#x2F;&#x2F;前后</span><br><span class="line">            if (i &#x3D;&#x3D; 0) result +&#x3D; grid[i][j];</span><br><span class="line">            if (i &#x3D;&#x3D; n-1) result +&#x3D; grid[i][j];</span><br><span class="line">            if (i &gt; 0 &amp;&amp; grid[i][j] &gt; grid[i-1][j]) result +&#x3D; (grid[i][j] - grid[i-1][j]);</span><br><span class="line">            if (i &lt; n-1 &amp;&amp; grid[i][j] &gt; grid[i+1][j])   result +&#x3D; (grid[i][j] - grid[i+1][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;减法</span><br><span class="line"></span><br><span class="line">int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123;</span><br><span class="line">    int n &#x3D; grid.size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; ++j)&#123;</span><br><span class="line">            if (grid[i][j]) result +&#x3D; 4*grid[i][j]+2;</span><br><span class="line">            if (i &lt; n-1)</span><br><span class="line">                result -&#x3D; 2*min(grid[i][j], grid[i+1][j]);</span><br><span class="line">            if (j &lt; n-1)</span><br><span class="line">                result -&#x3D; 2*min(grid[i][j], grid[i][j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-498 对角线遍历</title>
      <link href="/2020/04/26/LeetCode-498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/"/>
      <url>/2020/04/26/LeetCode-498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出:  [1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/498.png"  alt=""><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>找规律，分奇偶讨论。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    int row &#x3D; matrix.size();</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    if (row &lt;&#x3D; 0)   return result;</span><br><span class="line">    int column &#x3D; matrix[0].size();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; row; ++i)&#123;</span><br><span class="line">        if (i % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; column; ++j)</span><br><span class="line">                if (i - j &gt;&#x3D; 0) result.push_back(matrix[i-j][j]);                </span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int j &#x3D; column-1; j &gt;&#x3D; 0; --j)</span><br><span class="line">                if (i - j &gt;&#x3D; 0) result.push_back(matrix[i-j][j]);                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 1; j &lt; column; ++j)&#123;</span><br><span class="line">        if ((row+j) % 2 &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; column-j; ++i)</span><br><span class="line">                if (row-1-i &gt;&#x3D; 0) result.push_back(matrix[row-1-i][j+i]);                 </span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int i &#x3D; column-j-1; i &gt;&#x3D; 0; --i)</span><br><span class="line">                if (row-1-i &gt;&#x3D; 0) result.push_back(matrix[row-1-i][j+i]);                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-5393 可获得的最大点数</title>
      <link href="/2020/04/26/LeetCode-5393-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/"/>
      <url>/2020/04/26/LeetCode-5393-%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</span><br><span class="line"></span><br><span class="line">每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</span><br><span class="line"></span><br><span class="line">你的点数就是你拿到手中的所有卡牌的点数之和。</span><br><span class="line"></span><br><span class="line">给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [1,2,3,4,5,6,1], k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 &#x3D; 12 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [2,2,2], k &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [9,7,7,9,7,7,9], k &#x3D; 7</span><br><span class="line">输出：55</span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [1,1000,1], k &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：cardPoints &#x3D; [1,79,80,1,1,1,200,1], k &#x3D; 3</span><br><span class="line">输出：202</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 1 &lt;&#x3D; cardPoints.length &lt;&#x3D; 10^5</span><br><span class="line">· 1 &lt;&#x3D; cardPoints[i] &lt;&#x3D; 10^4</span><br><span class="line">· 1 &lt;&#x3D; k &lt;&#x3D; cardPoints.length</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>先求出前k个数的总和，然后前面去掉一个，后面加上一个，前面去掉一个，后面加上一个…每一次比较得到最大值就好了。<br/>🐣：天知道我试过多少种动态规划方案…是我迷糊了嘛动不动就dp🙇‍♀️<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int maxScore(vector&lt;int&gt;&amp; cardPoints, int k) &#123;</span><br><span class="line">    int len &#x3D; cardPoints.size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; ++i)&#123;</span><br><span class="line">        result +&#x3D; cardPoints[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp &#x3D; result;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; ++i)&#123;</span><br><span class="line">        temp -&#x3D; cardPoints[k-1-i];</span><br><span class="line">        temp +&#x3D; cardPoints[len-1-i];</span><br><span class="line">        if (temp &gt; result)  result &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-200 岛屿数量⭐</title>
      <link href="/2020/04/25/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%E2%AD%90/"/>
      <url>/2020/04/25/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%E2%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。 </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>深度优先遍历DFS</strong>。</p><ul><li>目标是找到矩阵中 “岛屿的数量” ，上下左右相连的 1 都被认为是连续岛屿。</li><li>dfs方法： 设目前指针指向一个岛屿中的某一点 (i, j)，寻找包括此点的岛屿边界。<ul><li>从 (i, j) 向此点的上下左右 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 做深度搜索。</li><li>终止条件：<ul><li>(i, j) 越过矩阵边界;</li><li>grid[i][j] == 0，代表此分支已越过岛屿边界。</li></ul></li><li>搜索岛屿的同时，执行 grid[i][j] = ‘0’，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。</li></ul></li><li>主循环：遍历整个矩阵，当遇到 grid[i][j] == ‘1’ 时，从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。</li></ul><p>想法二：<strong>广度优先遍历BFS</strong>。</p><ul><li>主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。</li><li>bfs 方法：<ul><li>借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1：<ul><li>若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列；</li><li>若不是则跳过此节点；</li></ul></li><li>循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿。<br><br/><br/></li></ul></li></ul><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;DFS（深度优先搜索）</span><br><span class="line"></span><br><span class="line">void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; copy, int i, int j)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; copy.size() || j &gt;&#x3D; copy[0].size() || copy[i][j] &#x3D;&#x3D; &#39;0&#39;) return;</span><br><span class="line">    copy[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">    dfs(copy, i, j-1);</span><br><span class="line">    dfs(copy, i, j+1);</span><br><span class="line">    dfs(copy, i-1, j);</span><br><span class="line">    dfs(copy, i+1, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int row_num &#x3D; grid.size();</span><br><span class="line">    if (row_num &#x3D;&#x3D; 0)   return 0;</span><br><span class="line">    int column_num &#x3D; grid[0].size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    vector&lt;vector&lt;char&gt;&gt;&amp; copy &#x3D; grid;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; row_num; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; column_num; ++j)&#123;</span><br><span class="line">            if (grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">                dfs(copy, i, j);</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BFS（广度优先搜索）</span><br><span class="line"></span><br><span class="line">void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)&#123;</span><br><span class="line">    queue&lt;vector&lt;int&gt;&gt; q;</span><br><span class="line">    q.push(&#123;i, j&#125;);</span><br><span class="line">    while (!q.empty())&#123;</span><br><span class="line">        vector&lt;int&gt; first &#x3D; q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        i &#x3D; first[0];</span><br><span class="line">        j &#x3D; first[1];</span><br><span class="line">        if (i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0 &amp;&amp; i &lt; grid.size() &amp;&amp; j &lt; grid[0].size() &amp;&amp; grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">            grid[i][j] &#x3D; &#39;0&#39;;</span><br><span class="line">            q.push(&#123;i, j-1&#125;);</span><br><span class="line">            q.push(&#123;i, j+1&#125;);</span><br><span class="line">            q.push(&#123;i-1, j&#125;);</span><br><span class="line">            q.push(&#123;i+1, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">    int row_nums &#x3D; grid.size();</span><br><span class="line">    if (row_nums &#x3D;&#x3D; 0)  return 0;</span><br><span class="line">    int column_nums &#x3D; grid[0].size();</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; row_nums; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; column_nums; ++j)&#123;</span><br><span class="line">            if (grid[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;</span><br><span class="line">                bfs(grid, i, j);</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写，不在怕的；轮子，没想到的。</title>
      <link href="/2020/04/25/%E6%89%8B%E5%86%99%EF%BC%8C%E4%B8%8D%E5%9C%A8%E6%80%95%E7%9A%84%EF%BC%9B%E8%BD%AE%E5%AD%90%EF%BC%8C%E6%B2%A1%E6%83%B3%E5%88%B0%E7%9A%84%E3%80%82/"/>
      <url>/2020/04/25/%E6%89%8B%E5%86%99%EF%BC%8C%E4%B8%8D%E5%9C%A8%E6%80%95%E7%9A%84%EF%BC%9B%E8%BD%AE%E5%AD%90%EF%BC%8C%E6%B2%A1%E6%83%B3%E5%88%B0%E7%9A%84%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><br/><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;轮子</span><br><span class="line"></span><br><span class="line">string replaceSpace(string s) &#123;</span><br><span class="line">    return s.replace(&quot; &quot;,&quot;%20&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;手写</span><br><span class="line"></span><br><span class="line">string replaceSpace(string s) &#123;</span><br><span class="line">    int len &#x3D; s.size();</span><br><span class="line">    string result &#x3D; &quot;&quot;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39; &#39;)    result +&#x3D; &quot;%20&quot;;</span><br><span class="line">        else    result +&#x3D; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><hr><h2 id="📝题目-1"><a href="#📝题目-1" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><br/><h2 id="📝题解-1"><a href="#📝题解-1" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;轮子</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; result;</span><br><span class="line">    ListNode* temp &#x3D; head;</span><br><span class="line">    while (temp)&#123;</span><br><span class="line">        result.push_back(temp-&gt;val);</span><br><span class="line">        temp &#x3D; temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;指的是下面这一步</span><br><span class="line">    reverse(result.begin(), result.end());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;手写</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">    vector&lt;int&gt; result, tmp;</span><br><span class="line">    ListNode* temp &#x3D; head;</span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line">    while (temp)&#123;</span><br><span class="line">        tmp.push_back(temp-&gt;val);</span><br><span class="line">        ++len;</span><br><span class="line">        temp &#x3D; temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;指的是下面这一步</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        result.push_back(tmp.back());</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 一些奇奇怪怪的原理/轮子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1541 数组中重复的数字</title>
      <link href="/2020/04/25/LeetCode-1541-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/04/25/LeetCode-1541-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[3, 1, 2, 3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>与<a href="https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fromtitle=%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86&fromid=731656&fr=aladdin" target="_blank" rel="noopener">抽屉原理</a>同理，即如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置。因为出现的元素值必然小于数组长度，所以可以把见到的元素放到索引的位置，如果交换时，发现索引处已存在该元素，则重复。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int len &#x3D; nums.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        while (i !&#x3D; nums[i])&#123;</span><br><span class="line">            if (nums[i] &#x3D;&#x3D; nums[nums[i]])   return nums[i];</span><br><span class="line">            int temp &#x3D; nums[i];</span><br><span class="line">            nums[i] &#x3D; nums[temp];</span><br><span class="line">            nums[temp] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 一些奇奇怪怪的原理/轮子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-42 接雨水⭐</title>
      <link href="/2020/04/23/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%AD%90/"/>
      <url>/2020/04/23/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E2%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/42.png"  alt=""><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>动态规划</strong>。对于每一列，找到该列左边最高的墙和右边最高的墙，根据木桶效应，取矮的那面墙与该列比较，若高于该列，则该列可蓄水。为避免重复计算左右最高墙高度，采用动态规划思想记忆化存储。<br/>想法二：<strong>栈</strong>。在遍历数组时维护一个栈。如果当前的条形块小于或等于栈顶的条形块，则将条形块的索引入栈，意思是当前的条形块被栈中的前一个条形块界定。如果一个条形块长于栈顶，可以确定栈顶的条形块被当前条形块和栈的前一个条形块界定，因此弹出栈顶元素并且累加。<br/><br>算法详细过程：</p><ul><li>使用栈来存储条形块的索引下标。</li><li>遍历数组：<ul><li>当栈非空且height[current] &gt; height[st.top()]<ul><li>意味着栈中元素可以被弹出。弹出栈顶元素top。</li><li>计算当前元素和栈顶元素的距离，准备进行填充操作: distance = current−st.top()−1</li><li>找出界定高度bounded_height = min(height[current], height[st.top()])</li><li>累加</li></ul></li><li>将当前索引下标入栈</li><li>将 current 移动到下个位置</li></ul></li></ul><p>🐣：看到题解前的乱七八糟的思路真是疯狂，疯狂WA，疯狂修改，脆败🙇‍♀️<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">int trap(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    if (len &lt; 3)    return 0;</span><br><span class="line">    int max_left[len], max_right[len];</span><br><span class="line">    max_left[0] &#x3D; height[0];</span><br><span class="line">    max_right[len-1] &#x3D; height[len-1];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; len-1; ++i)</span><br><span class="line">        max_left[i] &#x3D; max(max_left[i-1], height[i-1]);</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; len-2; i &gt;&#x3D; 0; --i)</span><br><span class="line">        max_right[i] &#x3D; max(max_right[i+1], height[i+1]);</span><br><span class="line"></span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; len-1; ++i)&#123;</span><br><span class="line">        int min_height &#x3D; min(max_left[i], max_right[i]);</span><br><span class="line">        if (height[i] &lt; min_height) result &#x3D; result+min_height-height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">int trap(vector&lt;int&gt;&amp; height) &#123;        </span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    int result &#x3D; 0, current &#x3D; 0;</span><br><span class="line">    stack&lt;int&gt; index;</span><br><span class="line">    while (current &lt; len)&#123;</span><br><span class="line">        while (!index.empty() &amp;&amp; height[current]&gt;height[index.top()])&#123;</span><br><span class="line">            int tmp_h &#x3D; height[index.top()];</span><br><span class="line">            index.pop();</span><br><span class="line">            if (index.empty())  break;</span><br><span class="line">            int distance &#x3D; current-index.top()-1;</span><br><span class="line">            int min_h &#x3D; min(height[current], height[index.top()]);</span><br><span class="line">            result +&#x3D; distance*(min_h-tmp_h);</span><br><span class="line">        &#125;</span><br><span class="line">        index.push(current);</span><br><span class="line">        ++current;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-884 两句话中的不常见单词</title>
      <link href="/2020/04/21/LeetCode-884-%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/"/>
      <url>/2020/04/21/LeetCode-884-%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定两个句子 A 和 B（句子是一串由空格分隔的单词。每个单词仅由小写字母组成）。</span><br><span class="line"></span><br><span class="line">如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。</span><br><span class="line"></span><br><span class="line">返回所有不常用单词的列表。</span><br><span class="line"></span><br><span class="line">您可以按任何顺序返回列表。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; &quot;this apple is sweet&quot;, B &#x3D; &quot;this apple is sour&quot;</span><br><span class="line">输出：[&quot;sweet&quot;,&quot;sour&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; &quot;apple apple&quot;, B &#x3D; &quot;banana&quot;</span><br><span class="line">输出：[&quot;banana&quot;]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">· 0 &lt;&#x3D; A.length &lt;&#x3D; 200</span><br><span class="line">· 0 &lt;&#x3D; B.length &lt;&#x3D; 200</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>学习一下map的用法，算法方面没啥好说的。<br/>🐣：STL强强强🤙<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; uncommonFromSentences(string A, string B) &#123;</span><br><span class="line">    unordered_map&lt;string, int&gt; record;</span><br><span class="line">    int lenA &#x3D; A.size(), lenB &#x3D; B.size();</span><br><span class="line">    string temp &#x3D; &quot;&quot;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; lenA; ++i)&#123;</span><br><span class="line">        if (A[i] &#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">            auto iter &#x3D; record.find(temp);</span><br><span class="line">            if (iter !&#x3D; record.end())   ++iter-&gt;second;</span><br><span class="line">            else    record.insert(pair&lt;string, int&gt;(temp, 1));</span><br><span class="line">            temp &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            temp +&#x3D; A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    auto iterator &#x3D; record.find(temp);</span><br><span class="line">    if (iterator !&#x3D; record.end())   ++iterator-&gt;second;</span><br><span class="line">    else    record.insert(pair&lt;string, int&gt;(temp, 1));</span><br><span class="line">    temp &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; lenB; ++i)&#123;</span><br><span class="line">        if (B[i] &#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">            auto iter &#x3D; record.find(temp);</span><br><span class="line">            if (iter !&#x3D; record.end())   ++iter-&gt;second;</span><br><span class="line">            else    record.insert(pair&lt;string, int&gt;(temp, 1));</span><br><span class="line">            temp &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            temp +&#x3D; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    iterator &#x3D; record.find(temp);</span><br><span class="line">    if (iterator !&#x3D; record.end())   ++iterator-&gt;second;</span><br><span class="line">    else    record.insert(pair&lt;string, int&gt;(temp, 1));</span><br><span class="line">    temp &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    auto iter &#x3D; record.begin();</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    for (; iter !&#x3D; record.end(); ++iter)&#123;</span><br><span class="line">        if (iter-&gt;second &#x3D;&#x3D; 1)  result.push_back(iter-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-11 盛最多水的容器</title>
      <link href="/2020/04/18/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/04/18/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br><span class="line"></span><br><span class="line">注意：你不能倾斜容器，且 n 的值至少为 2。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@latest/image/11.jpg"  alt=""><br/></p><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>暴力的解法三两分钟写了出来，提交上去后超时了…超…时了…了…<br/>官方双指针思路：一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了1。这种情况下我们<strong>想要让指针移动后的容器体积增大，就要使移动后的容器的高尽量大</strong>，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会。<br/>🐣：（一开始我还觉得双指针还能咋用啊不就是跟暴力法一样控制个边而已吗打扰了原来有更进一步考虑（全个想无🙇‍♀️<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;O(n^2)</span><br><span class="line"></span><br><span class="line">int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len-1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; i+1; j &lt; len; ++j)&#123;</span><br><span class="line">            int sum &#x3D; (height[i] &lt; height[j] ? height[i]*(j-i) : height[j]*(j-i));</span><br><span class="line">            max &#x3D; max &gt; sum ? max : sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;O(n)</span><br><span class="line"></span><br><span class="line">int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">    int len &#x3D; height.size();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; len-1;</span><br><span class="line">    while (left &lt; right)&#123;</span><br><span class="line">        int sum &#x3D; (height[left] &lt; height[right] ? height[left]*(right-left) : height[right]*(right-left));</span><br><span class="line">        max &#x3D; max &gt; sum ? max : sum;</span><br><span class="line">        if (height[left] &lt; height[right])   ++left;</span><br><span class="line">        else --right;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-877 石子游戏</title>
      <link href="/2020/04/15/LeetCode-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/04/15/LeetCode-877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</span><br><span class="line"></span><br><span class="line">游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</span><br><span class="line"></span><br><span class="line">亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</span><br><span class="line"></span><br><span class="line">假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">· 2 &lt;&#x3D; piles.length &lt;&#x3D; 500</span><br><span class="line">· 1 &lt;&#x3D; piles[i] &lt;&#x3D; 500</span><br><span class="line"> </span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[5,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</span><br><span class="line">假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</span><br><span class="line">如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</span><br><span class="line">如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</span><br><span class="line">这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>数学推<del>倒</del>导法</strong>。因为是偶数个堆，所以两个人最后拿到的堆数是一样的，但是因为石头的数量是奇数，所以最后两人拿到的石头数量肯定是一个多一个少，且和为奇数，所以先手的人只要选择多的那种方式拿就行了，所以先手必赢💪。<br/>想法二：<strong><del>标准</del>动态规划</strong>。跟<a href="https://whitebeerhouse.github.io/2020/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/#%F0%9F%93%9D%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">动态规划（一）</a>第一道例题算是同源，这里使用二维数组<strong>dp[i][j]表示从第i堆石子到第j堆石子先手和后手的最大分数差。</strong><br/>🐣：（靠…我是想做dp问题的怎么老遇上数学问题🙃<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;</span><br><span class="line">    &#x2F;&#x2F;dp[i][j]表示从i到j的最优分数差</span><br><span class="line"></span><br><span class="line">    int len &#x3D; piles.size();</span><br><span class="line">    int dp[len][len];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        dp[i][i] &#x3D; piles[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int length &#x3D; 1; length &lt;&#x3D; len-1; ++length)&#123;</span><br><span class="line">        for (int left &#x3D; 0; left &lt;&#x3D; len-length-1; ++left)&#123;</span><br><span class="line">            int right &#x3D; left + length;</span><br><span class="line">            dp[left][right] &#x3D; max(piles[left]-dp[left+1][right], piles[right]-dp[left][right-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[0][len-1] &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1277 统计全为1的正方形子矩阵</title>
      <link href="/2020/04/15/LeetCode-1277-%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/04/15/LeetCode-1277-%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的正方形子矩阵的个数。</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">· 1 &lt;&#x3D; arr.length &lt;&#x3D; 300</span><br><span class="line">· 1 &lt;&#x3D; arr[0].length &lt;&#x3D; 300</span><br><span class="line">· 0 &lt;&#x3D; arr[i][j] &lt;&#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [0,1,1,1],</span><br><span class="line">  [1,1,1,1],</span><br><span class="line">  [0,1,1,1]</span><br><span class="line">]</span><br><span class="line">输出：15</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,0],</span><br><span class="line">  [1,1,0]</span><br><span class="line">]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>用 f[i][j] 表示以 (i, j) 为右下角的正方形的最大边长，那么除此定义之外，f[i][j] = x 也表示以 (i, j) 为右下角的正方形的数目为 x（即边长为 1, 2, …, x 的正方形各一个）。在计算出所有的 f[i][j] 后将它们进行累加，就可以得到矩阵中正方形的数目。<br/><br>不难得到 <strong>f[i][j] 的递推式：</strong><br/></p><ul><li>if i = 0 or j = 0 : f[i][j] = matrix[i][j];</li><li>if matrix[i][j] = 0 : f[i][j] = 0;</li><li>otherwise : f[i][j] = min(f[i-1][j], f[i][j-1], f[i-1][j-1]) + 1;<br><br/><br/></li></ul><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    int len1 &#x3D; matrix.size();</span><br><span class="line">    int len2 &#x3D; matrix[0].size();</span><br><span class="line">    int f[len1][len2];</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len2; ++j)&#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0)</span><br><span class="line">                f[i][j] &#x3D; matrix[i][j];</span><br><span class="line">            else &#123;</span><br><span class="line">                if (matrix[i][j])&#123;</span><br><span class="line">                    f[i][j] &#x3D; min(min(f[i][j-1], f[i-1][j]), f[i-1][j-1])+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else    f[i][j] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            result +&#x3D; f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1025 除数博弈</title>
      <link href="/2020/04/15/LeetCode-1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"/>
      <url>/2020/04/15/LeetCode-1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</span><br><span class="line"></span><br><span class="line">最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</span><br><span class="line"></span><br><span class="line">· 选出任一 x，满足 0 &lt; x &lt; N 且 N % x &#x3D;&#x3D; 0 。</span><br><span class="line">· 用 N - x 替换黑板上的数字 N 。</span><br><span class="line">· 如果玩家无法执行这些操作，就会输掉游戏。</span><br><span class="line"></span><br><span class="line">只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>👉震惊全场之“洋洋洒洒十来行，一看题解就一行”🤙🤙🤙<br/><strong>如果N是奇数，因为奇数的所有因数都是奇数，因此 N 进行一次 N-x 的操作结果一定是偶数，所以如果 a 拿到了一个奇数，那么轮到 b 的时候，b 拿到的肯定是偶数，这个时候 b 只要进行 -1， 还给 a 一个奇数，那么这样子 b 就会一直拿到偶数，到最后 b 一定会拿到最小偶数2，a 就输了。</strong><br/>所以如果游戏开始时Alice拿到N为奇数，那么她必输，也就是false。如果拿到N为偶数，她只用 -1，让Bob拿到奇数，最后Bob必输，结果就是true。<br/>🐣：（我不配（以及这个判断奇偶的方式也过于高效<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool divisorGame(int N) &#123;</span><br><span class="line">    return !(N&amp;1);</span><br><span class="line">    &#x2F;&#x2F;return (N % 2 &#x3D;&#x3D; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-2 两数相加</title>
      <link href="/2020/04/15/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2020/04/15/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>原写法思路一样的，就是不够简洁，参考了评论区，这个三目运算符用得真是666啊！<br/>🐣：坐等一个困难版本的该题。<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">    ListNode* head &#x3D; new ListNode(0, nullptr);</span><br><span class="line">    ListNode* now &#x3D; head;</span><br><span class="line">    int carry &#x3D; 0, sum &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;ListNode *p &#x3D; l1, *q &#x3D; l2;&#x2F;&#x2F;最好是不破坏参数</span><br><span class="line">    while (l1 || l2 || carry)&#123;</span><br><span class="line">        sum &#x3D; (l1?l1-&gt;val:0) + (l2?l2-&gt;val:0) + carry;</span><br><span class="line">        carry &#x3D; sum &#x2F; 10;</span><br><span class="line">        sum %&#x3D; 10;</span><br><span class="line">        ListNode*temp &#x3D; new ListNode(sum, nullptr);</span><br><span class="line">        now-&gt;next &#x3D; temp;</span><br><span class="line">        now &#x3D; now-&gt;next;</span><br><span class="line">        l1 &#x3D; l1?l1-&gt;next:l1;</span><br><span class="line">        l2 &#x3D; l2?l2-&gt;next:l2;</span><br><span class="line">    &#125;</span><br><span class="line">    return head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-62 不同路径</title>
      <link href="/2020/04/14/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/04/14/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角，每次只能向下或者向右移动一步，机器人试图达到网格的右下角，总共有多少条不同的路径？（1 &lt;&#x3D; m, n &lt;&#x3D; 100；题目数据保证答案小于等于 2 * 10^9）</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>很简单入门的动态规划。不过最初想用排列组合公式解答的，无奈计算过程溢出了🤷‍♀️。<br/>🐣：评论区有大佬说遇到其他使用排列组合会溢出的题目可以转化成这个题👍思路清奇啊👍👍<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    int f[m][n];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; ++j)&#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0)   f[i][j] &#x3D; 1;</span><br><span class="line">            else    f[i][j] &#x3D; f[i-1][j]+f[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-5382 HTML 实体解析器</title>
      <link href="/2020/04/12/LeetCode-5382-HTML-%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
      <url>/2020/04/12/LeetCode-5382-HTML-%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>由于题目和代码中的特殊字符都被博客转义了，所以这篇先暂存在CSDN上<a href="https://blog.csdn.net/weixin_43864929/article/details/105468685" target="_blank" rel="noopener">LeetCode-5382 HTML 实体解析器</a>。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-102 二叉树的层序遍历</title>
      <link href="/2020/04/11/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2020/04/11/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，请你返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">二叉树：[3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">   </span><br><span class="line">返回其层次遍历结果：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：<strong>递归</strong>遍历。难点大概就是如何加入新的一层。<br/>想法二：<strong>BFS（广度优先搜索）</strong>。利用<a href="https://en.cppreference.com/w/cpp/container/queue" target="_blank" rel="noopener">队列</a>先进先出的特性逐层存储、读取和弹出子节点。<br/>🐣：都是上学期数据结构的内容，有点遗忘了…<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">void traverse(vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth, TreeNode* root)&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL)   return;</span><br><span class="line">    if (depth &gt;&#x3D; result.size())</span><br><span class="line">        result.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">    result[depth].push_back(root-&gt;val);</span><br><span class="line">    traverse(result, depth+1, root-&gt;left);</span><br><span class="line">    traverse(result, depth+1, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    traverse(result, 0, root);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    if (root !&#x3D; NULL)</span><br><span class="line">        q.push(root);</span><br><span class="line">    </span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int count &#x3D; q.size();</span><br><span class="line">        vector&lt;int&gt; layer;</span><br><span class="line">        while(count &gt; 0)&#123;</span><br><span class="line">            TreeNode* tmp &#x3D; q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            layer.push_back(tmp-&gt;val);</span><br><span class="line">            if (tmp-&gt;left !&#x3D; NULL)  q.push(tmp-&gt;left);</span><br><span class="line">            if (tmp-&gt;right !&#x3D; NULL)  q.push(tmp-&gt;right);</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(layer);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1419 旋转矩阵</title>
      <link href="/2020/04/11/LeetCode-1419-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/04/11/LeetCode-1419-%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">给定一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。（不占用额外空间能否做到？）</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定 matrix &#x3D;</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>想法一：按照数学规律直接改变相应位置的值，需要额外拷贝一个副本作为数据来源。<br/>想法二：<strong>不占用额外空间，</strong> 先将矩阵以对角线为轴翻转再左右对称翻转。<br/>🐣：不考虑性能的话简直就一水题，强制缩减时空复杂度的话，倒真不容易想到这个翻转法…<br/><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法一</span><br><span class="line"></span><br><span class="line">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; c_matrix &#x3D; matrix;</span><br><span class="line">    int len &#x3D; matrix.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; len; ++j)&#123;</span><br><span class="line">            matrix[i][j] &#x3D; c_matrix[len-1-j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;想法二</span><br><span class="line"></span><br><span class="line">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">    int len &#x3D; matrix.size();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;以对角线为轴翻转 </span><br><span class="line">    for (int i &#x3D; 0; i &lt; len-1; ++i)&#123;</span><br><span class="line">        for (int j &#x3D; i+1; j &lt; len; ++j)&#123;</span><br><span class="line">            int temp &#x3D; matrix[i][j];</span><br><span class="line">            matrix[i][j] &#x3D; matrix[j][i];</span><br><span class="line">            matrix[j][i] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;左右对称翻转</span><br><span class="line">    for (int j &#x3D; 0; j &lt; len&#x2F;2; ++j)&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">            int temp &#x3D; matrix[i][j];</span><br><span class="line">            matrix[i][j] &#x3D; matrix[i][len-1-j];</span><br><span class="line">            matrix[i][len-1-j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-151 翻转字符串里的单词</title>
      <link href="/2020/04/10/LeetCode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
      <url>/2020/04/10/LeetCode-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，逐个翻转字符串中的每个单词。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>毫不费力的思路：分割出单词-&gt;反向拼接<br/>可以用很多方式完成。Java支持库函数split()可以直接以空格为分隔符拆解，trim()筛掉前后空格，几行代码搞定；C++选手可以用stringstream或者手动实现分割拼接，据说此题的出题目的是考察双指针操作字符数组…<br/>我用的正则表达式辅助实现分割，vector容器实现反向拼接…总之题目不是很难，但是手动实现时难免踩到很多坑🤦‍♀️<br/><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/" target="_blank" rel="noopener">官方思路和题解请戳此😃</a><br><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">string reverseWords(string s) &#123;</span><br><span class="line">    vector&lt;string&gt; words;</span><br><span class="line">    int len &#x3D; s.size();</span><br><span class="line">    string tmp &#x3D; &quot;&quot;;</span><br><span class="line">    regex reg(&quot;[ ]*&quot;);&#x2F;&#x2F;空或纯空格时为真</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; ++i)&#123;</span><br><span class="line">        if (regex_match(tmp, reg))tmp &#x3D; &quot;&quot;;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; !regex_match(tmp, reg))&#123;</span><br><span class="line">            words.push_back(tmp);</span><br><span class="line">            tmp &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            tmp +&#x3D; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!regex_match(tmp, reg))words.push_back(tmp);</span><br><span class="line"></span><br><span class="line">    int len2 &#x3D; words.size();</span><br><span class="line">    if (len2 &#x3D;&#x3D; 0) return &quot;&quot;;&#x2F;&#x2F;题目没有讲但是输入为全空格时输出为空，这里容易被坑</span><br><span class="line">    string temp &#x3D; &quot;&quot;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len2-1; ++i)&#123;</span><br><span class="line">        temp +&#x3D; words.back();</span><br><span class="line">        temp +&#x3D; &quot; &quot;;</span><br><span class="line">        words.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    temp +&#x3D; words.back();</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-329 判断子序列</title>
      <link href="/2020/04/08/LeetCode-329-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2020/04/08/LeetCode-329-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="📝题目"><a href="#📝题目" class="headerlink" title="📝题目"></a><strong>📝题目</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</span><br><span class="line">你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。</span><br><span class="line">字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 true.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 false.</span><br></pre></td></tr></table></figure><br/><h2 id="📝思路"><a href="#📝思路" class="headerlink" title="📝思路"></a><strong>📝思路</strong></h2><p>注意，字符串t可能很长，所以不适合用下标去标记和遍历（大概率会溢出）。<br/>使用<strong>双指针</strong>方式进行遍历，判断方式以<strong>字符串s是否遍历完</strong>为标准。<br><br/></p><h2 id="📝题解"><a href="#📝题解" class="headerlink" title="📝题解"></a><strong>📝题解</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool isSubsequence(string s, string t) &#123;</span><br><span class="line">    char* spt &#x3D; &amp;s[0];</span><br><span class="line">    char* tpt &#x3D; &amp;t[0];</span><br><span class="line">    while(*spt &amp;&amp; *tpt)&#123;</span><br><span class="line">        if (*spt &#x3D;&#x3D; *tpt)   spt++;</span><br><span class="line">        tpt++;</span><br><span class="line">    &#125;</span><br><span class="line">    return (*spt &#x3D;&#x3D; &#39;\0&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心法（二）</title>
      <link href="/2020/03/28/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/03/28/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="#1035">soj 1035 –DNA matching</a><br><a href="#1681">soj 1681 –Matchsticks</a><br><a href="#1620">soj 1620 –SCVs and minerals</a><br><a href="#2503">soj 2503 –最长字符串</a><br><a href="#1783">soj 1783 –Large is Better</a><br><a href="#8536">soj 8536 –Happy Camper</a><br><a href="#6771">soj 6771 –Class Packing</a></p><hr><p>⭐⭐⭐<a name="1035"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1035 --DNA matching</span><br><span class="line">题目：给定n个DNA单链，问最多能组成多少对DNA双链，每一个DNA单链只能使用一次，且不可翻转。两个DNA单链能够形成一对DNA双链的条件是对应位置A&#x2F;T，C&#x2F;G配对。（1&lt;&#x3D;n&lt;&#x3D;100）</span><br></pre></td></tr></table></figure><p>第一段乍一看有点不大好处理，其实可以利用数组来解决对应位配对的情况！而对于整体的求解，类似于遍历去找配对的一对对，只不过这里是读入数据时便确定了配对情况：与集合里已有的DNA若可配对则计数+1，否则将读入的DNA装进待配对集合里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">int matching(int n)&#123;</span><br><span class="line">static char match_str[127];</span><br><span class="line">match_str[&#39;A&#39;] &#x3D; &#39;T&#39;;</span><br><span class="line">match_str[&#39;T&#39;] &#x3D; &#39;A&#39;;</span><br><span class="line">match_str[&#39;G&#39;] &#x3D; &#39;C&#39;;</span><br><span class="line">match_str[&#39;C&#39;] &#x3D; &#39;G&#39;;</span><br><span class="line"></span><br><span class="line">int matchNum &#x3D; 0;</span><br><span class="line">multiset&lt;string&gt; S;</span><br><span class="line">string str, matchedStr;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i)&#123;&#x2F;&#x2F; n条DNA</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">matchedStr &#x3D; &quot;&quot;;</span><br><span class="line">for (int j &#x3D; 0; j &lt; str.size(); ++j)&#123;</span><br><span class="line">matchedStr +&#x3D; match_str[str[j]];</span><br><span class="line">&#125;</span><br><span class="line">if (S.count(matchedStr))&#123;</span><br><span class="line">++ matchNum;</span><br><span class="line">S.erase(S.lower_bound(matchedStr));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">S.insert(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return matchNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>⭐⭐⭐<a name="1681"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1681 --Matchsticks</span><br><span class="line">题目：如下图所示，给定n根火柴，求其可以摆出的最小的数和最大的数（2&lt;&#x3D;n&lt;&#x3D;100）</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/sherryjw/StaticResource@v1.0.3/image/1681.jpg"  alt=""><br/><br>显然，由于数字1只需要2根火柴以及数字7只需要3根火柴，最大的数必然全为1（偶数根火柴）或打7开头后全为1（奇数根火柴）。<br/><br>而对于最小的数，先枚举火柴数少的情况，再通过递归对火柴数更多的情况进行选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">string minNum(int matchsticks)&#123;&#x2F;&#x2F;不喜用switch-case语句</span><br><span class="line">if (matchsticks &#x3D;&#x3D; 2)return &quot;1&quot;;</span><br><span class="line">else if (matchsticks &#x3D;&#x3D; 3)return &quot;7&quot;;</span><br><span class="line">else if (matchsticks &#x3D;&#x3D; 4)return &quot;4&quot;;</span><br><span class="line">else if (matchsticks &#x3D;&#x3D; 5)return &quot;2&quot;;</span><br><span class="line">else if (matchsticks &#x3D;&#x3D; 6)return &quot;6&quot;;</span><br><span class="line">else if (matchsticks &#x3D;&#x3D; 7)return &quot;8&quot;;</span><br><span class="line">else if (matchsticks &#x3D;&#x3D; 8) return &quot;10&quot;;</span><br><span class="line">else if (matchsticks &#x3D;&#x3D; 10) return &quot;22&quot;;</span><br><span class="line">else &#123;</span><br><span class="line">string min1&#x3D; minNum(matchsticks - 7) + &quot;8&quot;;</span><br><span class="line">string min2 &#x3D; minNum(matchsticks - 6) + &quot;0&quot;;</span><br><span class="line">if (min1.size() &lt; min2.size() || min1 &lt; min2)return min1;</span><br><span class="line">else return min2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string maxNum(int matchsticks)&#123;</span><br><span class="line">string tmp &#x3D; &quot;&quot;;</span><br><span class="line">if (matchsticks % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; matchsticks&#x2F;2; ++i) &#123;</span><br><span class="line">tmp +&#x3D; &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">tmp &#x3D; &quot;7&quot;;</span><br><span class="line">matchsticks -&#x3D; 3;</span><br><span class="line">for (int i &#x3D; 0; i &lt; matchsticks &#x2F; 2; ++i) &#123;</span><br><span class="line">tmp +&#x3D; &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题有两个坑：<strong>1.</strong> 题目要求”no leading zeroes”，这里也包括了一位数的情况，即给定6根火柴棒时最小数不取0。<br><strong>2.</strong> 虽然火柴数为9的情况可以由递归解决但为10时不可，所以也需另外给出。</p><hr><p>⭐⭐⭐⭐<a name="1620"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1620 --SCVs and minerals</span><br><span class="line">题目：游戏“ StarCraft”设定为，最初您有N个SCV和M个mineral。每个SCV可以在一秒钟内获得C个mineral，而指挥中心可以立即用P个mineral生产1个SCV。求在S秒后可获得的最多的mineral数量。</span><br></pre></td></tr></table></figure><p>最开始的想法就是递归调用，想在每一步都得到最多的mineral。样例输出很快否定了这个方法，仔细一想才发现，这个问题可以转换成我们熟悉的场景——生意买卖，只要作为生产设备的SCV能够在剩下的时间内产出不少于成本价P的mineral，那么赚得的肯定就最多了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int testNum &#x3D; 0;</span><br><span class="line">cin &gt;&gt; testNum;</span><br><span class="line">for (int i &#x3D; 0; i &lt; testNum; ++i) &#123;</span><br><span class="line">int N, M, C, P, S;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M &gt;&gt; C &gt;&gt; P &gt;&gt; S;</span><br><span class="line">for (int j &#x3D; 0; j &lt; S; ++j) &#123;</span><br><span class="line">if ((S - j) * C &gt;&#x3D; P) &#123;&#x2F;&#x2F;P是获得一个SCV的成本，(S-j)*C是该SCV能带来的收入</span><br><span class="line">N +&#x3D; M &#x2F; P;</span><br><span class="line">M %&#x3D; P;</span><br><span class="line">&#125;</span><br><span class="line">M +&#x3D; N * C;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; M &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>⭐⭐⭐⭐<a name="2503"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 2503 --最长字符串</span><br><span class="line">题目：要求你构造一个由字符&#39;A&#39;,&#39;B&#39;组成的字符串, 满足以下几个条件:</span><br><span class="line">1) A的个数&lt;&#x3D;countA</span><br><span class="line">2) B的个数&lt;&#x3D;countB</span><br><span class="line">3) 连续的A的个数不可以超过maxA.</span><br><span class="line">4) 连续的B的个数不可以超过maxB.</span><br><span class="line">5) 这个字符串的长度最长.</span><br><span class="line">给定countA, countB, maxA, maxB, 求输出字符串的最大长度。</span><br></pre></td></tr></table></figure><p>不知道是不是被算法名字所束缚了，总想着在每一步都积累最多的’A’或’B’以求整体最大，这个想法最大的漏洞在于：两者的数量差可能是<strong>悬殊</strong>的，这个时候尽可能更多地分组才是最优解。<br/><br/><br>此题解法：将A或B作为基准，另外一个进行分组作为分隔符。如果非分隔符多于分组数量，尽可能填满分隔符之间的空隙；若分组数量多于非分隔符，则尽可能填充更多的空隙。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int handler(int countA, int countB, int maxA, int maxB) &#123;&#x2F;&#x2F;以A为基准，以B为分隔符</span><br><span class="line">if (maxA &#x3D;&#x3D; 0)return min(maxB, countB);</span><br><span class="line">if (maxB &#x3D;&#x3D; 0)return min(maxA, countA);</span><br><span class="line"></span><br><span class="line">int despNum &#x3D; ceil(countB &#x2F; maxB);&#x2F;&#x2F;ceil()向上取整，即前n-1组B的数量同，最后一组可能不同</span><br><span class="line">if (countA &gt; despNum)return min(countA + countB, countB + (despNum + 1) * maxA);</span><br><span class="line">else returncountA + min(countB, (countA+1)*maxB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int countA, countB, maxA, maxB;</span><br><span class="line">cin &gt;&gt; countA &gt;&gt; countB &gt;&gt; maxA &gt;&gt; maxB;</span><br><span class="line">int len1 &#x3D; handler(countA, countB, maxA, maxB);</span><br><span class="line">int len2 &#x3D; handler(countB, countA, maxB, maxA);</span><br><span class="line">cout &lt;&lt; max(len1, len2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>⭐<a name="1783"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1783 --Large is Better</span><br><span class="line">题目：给定一个数字，除了0，可以交换任意数量的相邻数字，不允许用数字0去交换任何数字。求经过交换所能得到的最大数字。</span><br></pre></td></tr></table></figure><p>没有太大难度，就是分割排序。不过用<strong>迭代器</strong>这个骚操作真得学起来了啊…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int testNum;</span><br><span class="line">cin &gt;&gt; testNum;</span><br><span class="line">while (testNum--) &#123;</span><br><span class="line">string str1;</span><br><span class="line">cin &gt;&gt; str1;</span><br><span class="line">int length &#x3D; str1.size();</span><br><span class="line"></span><br><span class="line">if (length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进一步优化：用iterator去指向每个分割的部分</span><br><span class="line">string::iterator iter1 &#x3D; str1.begin();</span><br><span class="line">string::iterator iter2 &#x3D; iter1;</span><br><span class="line">for (int i &#x3D; 0; i &lt; length; ++i) &#123;</span><br><span class="line">if (*iter2 &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">sort(iter1, iter2, greater&lt;&gt;());</span><br><span class="line">iter1 &#x3D; iter2+1;</span><br><span class="line">&#125;</span><br><span class="line">++iter2;</span><br><span class="line">&#125;</span><br><span class="line">sort(iter1, iter2, greater&lt;&gt;());</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>⭐<a name="8536"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 8536 --Happy Camper</span><br><span class="line">题目：设整数1&lt;L&lt;P&lt;V，在任何连续的P天时间里，露营地的占用限于L天。Harry Camper拥有V天的假期。请问假期期间，他最多可以露营地住多少天？</span><br></pre></td></tr></table></figure><p>不知道为什么这么简单的题目会被放进课件里…就是分割啦跟上上道题同源的思想然而比那个水好多…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int L, P, V;</span><br><span class="line">int caseNum &#x3D; 1;</span><br><span class="line">while (cin &gt;&gt; L &gt;&gt; P &gt;&gt; V) &#123;</span><br><span class="line">if (!(L &amp;&amp; P &amp;&amp; V))return 0;</span><br><span class="line"></span><br><span class="line">int maxDays &#x3D; 0;</span><br><span class="line">int despNum &#x3D; V &#x2F; P;</span><br><span class="line">maxDays +&#x3D; L * despNum;</span><br><span class="line"></span><br><span class="line">if (despNum * P &lt; V) &#123;</span><br><span class="line">maxDays +&#x3D; min(L, V - despNum * P);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;Case &quot; &lt;&lt; caseNum &lt;&lt; &quot;: &quot; &lt;&lt; maxDays &lt;&lt; endl;</span><br><span class="line">++caseNum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>⭐⭐⭐⭐<a name="6771"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 6771 --Class Packing</span><br><span class="line">题目：年级为0~6共七个年级的学生，给定每个年级的学生数量。现为这些学生分配班级，需要满足以下条件：</span><br><span class="line">   1：一个班级只能有一个年级或两个相邻年级的学生，例如，四年级和五年级学生的班级人数不得超过25。</span><br><span class="line">   2: 拥有年级0-2的学生的班级，其人数最多为20。</span><br><span class="line">   3: 拥有年级3-4的学生的班级，其人数最多为25。</span><br><span class="line">   4: 拥有年级5-6的学生的班级，其人数最多为30。</span><br><span class="line">求至少需要分配多少个班级。</span><br></pre></td></tr></table></figure><p>emmm…看提示之前是思绪是非常乱的…纠结于how to divide them…Fine其实正确思路再简单不过了：<strong>如果人数多的话，将他们尽量分配到同一个班的结果是理想的（因为如果分配到其他的班，可能会影响到高年级的班级的容量）；如果人数有剩下的话，就从其上一年级中调派人员过来，使得该班的容量填满。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int grade[7];</span><br><span class="line">while (cin &gt;&gt; grade[0] &gt;&gt; grade[1] &gt;&gt; grade[2] &gt;&gt; grade[3] &gt;&gt; grade[4] &gt;&gt; grade[5] &gt;&gt; grade[6]) &#123;</span><br><span class="line">bool flag &#x3D; true;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 7; ++i) &#123;</span><br><span class="line">if (grade[i] !&#x3D; 0) &#123;</span><br><span class="line">flag &#x3D; false;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag)return 0;</span><br><span class="line"></span><br><span class="line">int limits[7] &#x3D; &#123; 20, 20, 20, 25, 25, 30, 30 &#125;;</span><br><span class="line"></span><br><span class="line">int num &#x3D; 0;</span><br><span class="line">int left &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 7; ++i) &#123;</span><br><span class="line">while (grade[i] &gt; 0) &#123;</span><br><span class="line">if (left !&#x3D; 0 &amp;&amp; grade[i-1] &lt; 0) &#123;</span><br><span class="line">grade[i] -&#x3D; left;</span><br><span class="line">left &#x3D; 0;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if (grade[i] &lt; limits[i]) &#123;</span><br><span class="line">left &#x3D; limits[i] - grade[i];</span><br><span class="line">&#125;</span><br><span class="line">++num;</span><br><span class="line">grade[i] -&#x3D; limits[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🐣最后一点点想法：C++标准库函数真的很实用！</p><p>（未完待续）</p><p>附录：</p><p><a href="https://blog.csdn.net/qq_28351609/article/details/84630535" target="_blank" rel="noopener">STL之map用法详解</a><br><a href="https://blog.csdn.net/sodacoco/article/details/84798621" target="_blank" rel="noopener">STL之multiset用法总结</a><br><a href="http://c.biancheng.net/view/545.html" target="_blank" rel="noopener">Multiset用法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 贪心法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心法（一）</title>
      <link href="/2020/03/22/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/03/22/%E8%B4%AA%E5%BF%83%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>久仰大名。没想到这么折腾人。先上定义 ↓</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">贪心算法：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</span><br><span class="line"></span><br><span class="line">贪心法的特点：</span><br><span class="line">· 不是对所有问题都能得到整体最优解，关键是贪心策略的选择</span><br><span class="line">· 选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</span><br></pre></td></tr></table></figure><p><br/>听起来挺简单对吧，但最优解的策略是真不好找，而且往往需要证明（哪怕不太严谨但也应说服自己信任该策略）。下面给出一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题号：soj 1198 --Substring</span><br><span class="line">题目：给定n个字符串，将其拼接形成一个字典序最小的字符串（1&lt;&#x3D;n&lt;&#x3D;8）</span><br></pre></td></tr></table></figure><p><br/>那么，我们可以考虑以下几种方案：</p><ul><li>直接对所有字符串按字典序大小排序后进行拼接。<br/></li><li>暴力枚举所有组合的可能性，再遍历得到字典序最小的组合。<br/></li><li><strong>传说中的贪心法</strong></li></ul><p>第一种方案咋一看可行，那么考虑这样一个输入：b、ba；按该方案得到的输出是”bba”，但实际上”bab”才是最优解。所以，存在反例，我们可以否定第一种方案。</p><p>显然，暴力枚举是可以得到正确结果的，时间复杂度O(n<sup>2</sup>)，相对于我们将要讨论的贪心法，既费时又费力。（文末会附上暴力枚举方案的代码）。</p><p>那么，在这个题目中贪心法的策略是如何呢？</p><p>合理的做法是先对这n个字符串进行某种<b>排序</b>再拼接。这里的排序方式是指，对于两个字符串str1、str2，如果str1+str2 &lt; str2+str1，那么把str1放在str2的前面所得到的字符串就是字典序更小的那个。当每两个字符串之间都按照这个标准进行比较并排序后，最终串起来的结果就是正确答案。</p><p>该策略证明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">证题：若a &lt;&#x3D; b，b &lt;&#x3D; c，那么a &lt;&#x3D; c(已重载比较符)。</span><br><span class="line">证明：</span><br><span class="line">    由 a &lt;&#x3D; b 得 ab &lt;&#x3D; ba； </span><br><span class="line">    由 b &lt;&#x3D; c 得 bc &lt;&#x3D; cb；</span><br><span class="line">    易得 ac &lt;&#x3D; ca，推出a &lt;&#x3D; c。证毕。</span><br></pre></td></tr></table></figure><p><br/>证明完成，将上述思想转化为代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(string str1, string str2)&#123;</span><br><span class="line">return str1+str2 &lt; str2+str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string subStr(int n, string str[])&#123;</span><br><span class="line">string ret &#x3D; &quot;&quot;;</span><br><span class="line">sort(str, str+n, cmp);</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i)&#123;</span><br><span class="line">ret +&#x3D; str[i];</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题写得略长了，之后的题目就点到为止吧。</p><p>附录：</p><p><a href="https://blog.csdn.net/weixin_43864929/article/details/105039150" target="_blank" rel="noopener">求字典序最小的拼接字符串之暴力枚举法</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 贪心法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客经营旅程</title>
      <link href="/2020/03/21/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BB%8F%E8%90%A5%E6%97%85%E7%A8%8B/"/>
      <url>/2020/03/21/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BB%8F%E8%90%A5%E6%97%85%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>庚子年清明，我把原来jekyll的博客迁到了hexo框架。</p><p>主题©<a href="https://jerryc.me/" target="_blank" rel="noopener">Butterfly</a>，目前只是根据配置文档做一些选择，尽量让界面清新简洁。</p><p>大佬们代码写得很好，得花一些时间研究一下配置文件，未来想再引进些什么。</p><p>未完待续…</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
